"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/recordrtc";
exports.ids = ["vendor-chunks/recordrtc"];
exports.modules = {

/***/ "(ssr)/./node_modules/recordrtc/RecordRTC.js":
/*!*********************************************!*\
  !*** ./node_modules/recordrtc/RecordRTC.js ***!
  \*********************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n// Last time updated: 2021-03-09 3:20:22 AM UTC\n// ________________\n// RecordRTC v5.6.2\n// Open-Sourced: https://github.com/muaz-khan/RecordRTC\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n// ____________\n// RecordRTC.js\n/**\r\n * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. \r\n * @summary Record audio, video or screen inside the browser.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTC\r\n * @class\r\n * @example\r\n * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {\r\n *     type: 'video', // audio or video or gif or canvas\r\n *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc\r\n * });\r\n * recorder.startRecording();\r\n * @see For further information:\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\r\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}\r\n */ function RecordRTC(mediaStream, config) {\n    if (!mediaStream) {\n        throw \"First parameter is required.\";\n    }\n    config = config || {\n        type: \"video\"\n    };\n    config = new RecordRTCConfiguration(mediaStream, config);\n    // a reference to user's recordRTC object\n    var self = this;\n    function startRecording(config2) {\n        if (!config.disableLogs) {\n            console.log(\"RecordRTC version: \", self.version);\n        }\n        if (!!config2) {\n            // allow users to set options using startRecording method\n            // config2 is similar to main \"config\" object (second parameter over RecordRTC constructor)\n            config = new RecordRTCConfiguration(mediaStream, config2);\n        }\n        if (!config.disableLogs) {\n            console.log(\"started recording \" + config.type + \" stream.\");\n        }\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder.record();\n            setState(\"recording\");\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n            return self;\n        }\n        initRecorder(function() {\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n        });\n        return self;\n    }\n    function initRecorder(initCallback) {\n        if (initCallback) {\n            config.initCallback = function() {\n                initCallback();\n                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.\n            };\n        }\n        var Recorder = new GetRecorderType(mediaStream, config);\n        mediaRecorder = new Recorder(mediaStream, config);\n        mediaRecorder.record();\n        setState(\"recording\");\n        if (!config.disableLogs) {\n            console.log(\"Initialized recorderType:\", mediaRecorder.constructor.name, \"for output-type:\", config.type);\n        }\n    }\n    function stopRecording(callback) {\n        callback = callback || function() {};\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n        if (self.state === \"paused\") {\n            self.resumeRecording();\n            setTimeout(function() {\n                stopRecording(callback);\n            }, 1);\n            return;\n        }\n        if (self.state !== \"recording\" && !config.disableLogs) {\n            console.warn('Recording state should be: \"recording\", however current state is: ', self.state);\n        }\n        if (!config.disableLogs) {\n            console.log(\"Stopped recording \" + config.type + \" stream.\");\n        }\n        if (config.type !== \"gif\") {\n            mediaRecorder.stop(_callback);\n        } else {\n            mediaRecorder.stop();\n            _callback();\n        }\n        setState(\"stopped\");\n        function _callback(__blob) {\n            if (!mediaRecorder) {\n                if (typeof callback.call === \"function\") {\n                    callback.call(self, \"\");\n                } else {\n                    callback(\"\");\n                }\n                return;\n            }\n            Object.keys(mediaRecorder).forEach(function(key) {\n                if (typeof mediaRecorder[key] === \"function\") {\n                    return;\n                }\n                self[key] = mediaRecorder[key];\n            });\n            var blob = mediaRecorder.blob;\n            if (!blob) {\n                if (__blob) {\n                    mediaRecorder.blob = blob = __blob;\n                } else {\n                    throw \"Recording failed.\";\n                }\n            }\n            if (blob && !config.disableLogs) {\n                console.log(blob.type, \"->\", bytesToSize(blob.size));\n            }\n            if (callback) {\n                var url;\n                try {\n                    url = URL.createObjectURL(blob);\n                } catch (e) {}\n                if (typeof callback.call === \"function\") {\n                    callback.call(self, url);\n                } else {\n                    callback(url);\n                }\n            }\n            if (!config.autoWriteToDisk) {\n                return;\n            }\n            getDataURL(function(dataURL) {\n                var parameter = {};\n                parameter[config.type + \"Blob\"] = dataURL;\n                DiskStorage.Store(parameter);\n            });\n        }\n    }\n    function pauseRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n        if (self.state !== \"recording\") {\n            if (!config.disableLogs) {\n                console.warn(\"Unable to pause the recording. Recording state: \", self.state);\n            }\n            return;\n        }\n        setState(\"paused\");\n        mediaRecorder.pause();\n        if (!config.disableLogs) {\n            console.log(\"Paused recording.\");\n        }\n    }\n    function resumeRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n        if (self.state !== \"paused\") {\n            if (!config.disableLogs) {\n                console.warn(\"Unable to resume the recording. Recording state: \", self.state);\n            }\n            return;\n        }\n        setState(\"recording\");\n        // not all libs have this method yet\n        mediaRecorder.resume();\n        if (!config.disableLogs) {\n            console.log(\"Resumed recording.\");\n        }\n    }\n    function readFile(_blob) {\n        postMessage(new FileReaderSync().readAsDataURL(_blob));\n    }\n    function getDataURL(callback, _mediaRecorder) {\n        if (!callback) {\n            throw \"Pass a callback function over getDataURL.\";\n        }\n        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;\n        if (!blob) {\n            if (!config.disableLogs) {\n                console.warn(\"Blob encoder did not finish its job yet.\");\n            }\n            setTimeout(function() {\n                getDataURL(callback, _mediaRecorder);\n            }, 1000);\n            return;\n        }\n        if (typeof Worker !== \"undefined\" && !navigator.mozGetUserMedia) {\n            var webWorker = processInWebWorker(readFile);\n            webWorker.onmessage = function(event) {\n                callback(event.data);\n            };\n            webWorker.postMessage(blob);\n        } else {\n            var reader = new FileReader();\n            reader.readAsDataURL(blob);\n            reader.onload = function(event) {\n                callback(event.target.result);\n            };\n        }\n        function processInWebWorker(_function) {\n            try {\n                var blob = URL.createObjectURL(new Blob([\n                    _function.toString(),\n                    \"this.onmessage =  function (eee) {\" + _function.name + \"(eee.data);}\"\n                ], {\n                    type: \"application/javascript\"\n                }));\n                var worker = new Worker(blob);\n                URL.revokeObjectURL(blob);\n                return worker;\n            } catch (e) {}\n        }\n    }\n    function handleRecordingDuration(counter) {\n        counter = counter || 0;\n        if (self.state === \"paused\") {\n            setTimeout(function() {\n                handleRecordingDuration(counter);\n            }, 1000);\n            return;\n        }\n        if (self.state === \"stopped\") {\n            return;\n        }\n        if (counter >= self.recordingDuration) {\n            stopRecording(self.onRecordingStopped);\n            return;\n        }\n        counter += 1000; // 1-second\n        setTimeout(function() {\n            handleRecordingDuration(counter);\n        }, 1000);\n    }\n    function setState(state) {\n        if (!self) {\n            return;\n        }\n        self.state = state;\n        if (typeof self.onStateChanged.call === \"function\") {\n            self.onStateChanged.call(self, state);\n        } else {\n            self.onStateChanged(state);\n        }\n    }\n    var WARNING = 'It seems that recorder is destroyed or \"startRecording\" is not invoked for ' + config.type + \" recorder.\";\n    function warningLog() {\n        if (config.disableLogs === true) {\n            return;\n        }\n        console.warn(WARNING);\n    }\n    var mediaRecorder;\n    var returnObject = {\n        /**\r\n         * This method starts the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var recorder = RecordRTC(mediaStream, {\r\n         *     type: 'video'\r\n         * });\r\n         * recorder.startRecording();\r\n         */ startRecording: startRecording,\n        /**\r\n         * This method stops the recording. It is strongly recommended to get \"blob\" or \"URI\" inside the callback to make sure all recorders finished their job.\r\n         * @param {function} callback - Callback to get the recorded blob.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     // use either \"this\" or \"recorder\" object; both are identical\r\n         *     video.src = this.toURL();\r\n         *     var blob = this.getBlob();\r\n         * });\r\n         */ stopRecording: stopRecording,\n        /**\r\n         * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo Firefox is unable to pause the recording. Fix it.\r\n         * @example\r\n         * recorder.pauseRecording();  // pause the recording\r\n         * recorder.resumeRecording(); // resume again\r\n         */ pauseRecording: pauseRecording,\n        /**\r\n         * This method resumes the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.pauseRecording();  // first of all, pause the recording\r\n         * recorder.resumeRecording(); // now resume it\r\n         */ resumeRecording: resumeRecording,\n        /**\r\n         * This method initializes the recording.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo This method should be deprecated.\r\n         * @example\r\n         * recorder.initRecorder();\r\n         */ initRecorder: initRecorder,\n        /**\r\n         * Ask RecordRTC to auto-stop the recording after 5 minutes.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var fiveMinutes = 5 * 1000 * 60;\r\n         * recorder.setRecordingDuration(fiveMinutes, function() {\r\n         *    var blob = this.getBlob();\r\n         *    video.src = this.toURL();\r\n         * });\r\n         * \r\n         * // or otherwise\r\n         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {\r\n         *    var blob = this.getBlob();\r\n         *    video.src = this.toURL();\r\n         * });\r\n         */ setRecordingDuration: function(recordingDuration, callback) {\n            if (typeof recordingDuration === \"undefined\") {\n                throw \"recordingDuration is required.\";\n            }\n            if (typeof recordingDuration !== \"number\") {\n                throw \"recordingDuration must be a number.\";\n            }\n            self.recordingDuration = recordingDuration;\n            self.onRecordingStopped = callback || function() {};\n            return {\n                onRecordingStopped: function(callback) {\n                    self.onRecordingStopped = callback;\n                }\n            };\n        },\n        /**\r\n         * This method can be used to clear/reset all the recorded data.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo Figure out the difference between \"reset\" and \"clearRecordedData\" methods.\r\n         * @example\r\n         * recorder.clearRecordedData();\r\n         */ clearRecordedData: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n            mediaRecorder.clearRecordedData();\n            if (!config.disableLogs) {\n                console.log(\"Cleared old recorded data.\");\n            }\n        },\n        /**\r\n         * Get the recorded blob. Use this method inside the \"stopRecording\" callback.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var blob = this.getBlob();\r\n         *\r\n         *     var file = new File([blob], 'filename.webm', {\r\n         *         type: 'video/webm'\r\n         *     });\r\n         *\r\n         *     var formData = new FormData();\r\n         *     formData.append('file', file); // upload \"File\" object rather than a \"Blob\"\r\n         *     uploadToServer(formData);\r\n         * });\r\n         * @returns {Blob} Returns recorded data as \"Blob\" object.\r\n         */ getBlob: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n            return mediaRecorder.blob;\n        },\n        /**\r\n         * Get data-URI instead of Blob.\r\n         * @param {function} callback - Callback to get the Data-URI.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     recorder.getDataURL(function(dataURI) {\r\n         *         video.src = dataURI;\r\n         *     });\r\n         * });\r\n         */ getDataURL: getDataURL,\n        /**\r\n         * Get virtual/temporary URL. Usage of this URL is limited to current tab.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     video.src = this.toURL();\r\n         * });\r\n         * @returns {String} Returns a virtual/temporary URL for the recorded \"Blob\".\r\n         */ toURL: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n            return URL.createObjectURL(mediaRecorder.blob);\n        },\n        /**\r\n         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * var internalRecorder = recorder.getInternalRecorder();\r\n         * if(internalRecorder instanceof MultiStreamRecorder) {\r\n         *     internalRecorder.addStreams([newAudioStream]);\r\n         *     internalRecorder.resetVideoStreams([screenStream]);\r\n         * }\r\n         * @returns {Object} Returns internal recording object.\r\n         */ getInternalRecorder: function() {\n            return mediaRecorder;\n        },\n        /**\r\n         * Invoke save-as dialog to save the recorded blob into your disk.\r\n         * @param {string} fileName - Set your own file name.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     this.save('file-name');\r\n         *\r\n         *     // or manually:\r\n         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');\r\n         * });\r\n         */ save: function(fileName) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n            invokeSaveAsDialog(mediaRecorder.blob, fileName);\n        },\n        /**\r\n         * This method gets a blob from indexed-DB storage.\r\n         * @param {function} callback - Callback to get the recorded blob.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.getFromDisk(function(dataURL) {\r\n         *     video.src = dataURL;\r\n         * });\r\n         */ getFromDisk: function(callback) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n            RecordRTC.getFromDisk(config.type, callback);\n        },\n        /**\r\n         * This method appends an array of webp images to the recorded video-blob. It takes an \"array\" object.\r\n         * @type {Array.<Array>}\r\n         * @param {Array} arrayOfWebPImages - Array of webp images.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @todo This method should be deprecated.\r\n         * @example\r\n         * var arrayOfWebPImages = [];\r\n         * arrayOfWebPImages.push({\r\n         *     duration: index,\r\n         *     image: 'data:image/webp;base64,...'\r\n         * });\r\n         * recorder.setAdvertisementArray(arrayOfWebPImages);\r\n         */ setAdvertisementArray: function(arrayOfWebPImages) {\n            config.advertisement = [];\n            var length = arrayOfWebPImages.length;\n            for(var i = 0; i < length; i++){\n                config.advertisement.push({\n                    duration: i,\n                    image: arrayOfWebPImages[i]\n                });\n            }\n        },\n        /**\r\n         * It is equivalent to <code class=\"str\">\"recorder.getBlob()\"</code> method. Usage of \"getBlob\" is recommended, though.\r\n         * @property {Blob} blob - Recorded Blob can be accessed using this property.\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var blob = this.blob;\r\n         *\r\n         *     // below one is recommended\r\n         *     var blob = this.getBlob();\r\n         * });\r\n         */ blob: null,\n        /**\r\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\r\n         * @property {number} bufferSize - Buffer-size used to encode the WAV container\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     alert('Recorder used this buffer-size: ' + this.bufferSize);\r\n         * });\r\n         */ bufferSize: 0,\n        /**\r\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\r\n         * @property {number} sampleRate - Sample-rates used to encode the WAV container\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     alert('Recorder used these sample-rates: ' + this.sampleRate);\r\n         * });\r\n         */ sampleRate: 0,\n        /**\r\n         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.\r\n         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @readonly\r\n         * @example\r\n         * recorder.stopRecording(function() {\r\n         *     var arrayBuffer = this.buffer;\r\n         *     alert(arrayBuffer.byteLength);\r\n         * });\r\n         */ buffer: null,\n        /**\r\n         * This method resets the recorder. So that you can reuse single recorder instance many times.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.reset();\r\n         * recorder.startRecording();\r\n         */ reset: function() {\n            if (self.state === \"recording\" && !config.disableLogs) {\n                console.warn(\"Stop an active recorder.\");\n            }\n            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === \"function\") {\n                mediaRecorder.clearRecordedData();\n            }\n            mediaRecorder = null;\n            setState(\"inactive\");\n            self.blob = null;\n        },\n        /**\r\n         * This method is called whenever recorder's state changes. Use this as an \"event\".\r\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @instance\r\n         * @example\r\n         * recorder.onStateChanged = function(state) {\r\n         *     console.log('Recorder state: ', state);\r\n         * };\r\n         */ onStateChanged: function(state) {\n            if (!config.disableLogs) {\n                console.log(\"Recorder state changed:\", state);\n            }\n        },\n        /**\r\n         * A recorder can have inactive, recording, paused or stopped states.\r\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\r\n         * @memberof RecordRTC\r\n         * @static\r\n         * @readonly\r\n         * @example\r\n         * // this looper function will keep you updated about the recorder's states.\r\n         * (function looper() {\r\n         *     document.querySelector('h1').innerHTML = 'Recorder\\'s state is: ' + recorder.state;\r\n         *     if(recorder.state === 'stopped') return; // ignore+stop\r\n         *     setTimeout(looper, 1000); // update after every 3-seconds\r\n         * })();\r\n         * recorder.startRecording();\r\n         */ state: \"inactive\",\n        /**\r\n         * Get recorder's readonly state.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @example\r\n         * var state = recorder.getState();\r\n         * @returns {String} Returns recording state.\r\n         */ getState: function() {\n            return self.state;\n        },\n        /**\r\n         * Destroy RecordRTC instance. Clear all recorders and objects.\r\n         * @method\r\n         * @memberof RecordRTC\r\n         * @example\r\n         * recorder.destroy();\r\n         */ destroy: function() {\n            var disableLogsCache = config.disableLogs;\n            config = {\n                disableLogs: true\n            };\n            self.reset();\n            setState(\"destroyed\");\n            returnObject = self = null;\n            if (Storage.AudioContextConstructor) {\n                Storage.AudioContextConstructor.close();\n                Storage.AudioContextConstructor = null;\n            }\n            config.disableLogs = disableLogsCache;\n            if (!config.disableLogs) {\n                console.log(\"RecordRTC is destroyed.\");\n            }\n        },\n        /**\r\n         * RecordRTC version number\r\n         * @property {String} version - Release version number.\r\n         * @memberof RecordRTC\r\n         * @static\r\n         * @readonly\r\n         * @example\r\n         * alert(recorder.version);\r\n         */ version: \"5.6.2\"\n    };\n    if (!this) {\n        self = returnObject;\n        return returnObject;\n    }\n    // if someone wants to use RecordRTC with the \"new\" keyword.\n    for(var prop in returnObject){\n        this[prop] = returnObject[prop];\n    }\n    self = this;\n    return returnObject;\n}\nRecordRTC.version = \"5.6.2\";\nif (true /* && !!module.exports*/ ) {\n    module.exports = RecordRTC;\n}\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return RecordRTC;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\nRecordRTC.getFromDisk = function(type, callback) {\n    if (!callback) {\n        throw \"callback is mandatory.\";\n    }\n    console.log(\"Getting recorded \" + (type === \"all\" ? \"blobs\" : type + \" blob \") + \" from disk!\");\n    DiskStorage.Fetch(function(dataURL, _type) {\n        if (type !== \"all\" && _type === type + \"Blob\" && callback) {\n            callback(dataURL);\n        }\n        if (type === \"all\" && callback) {\n            callback(dataURL, _type.replace(\"Blob\", \"\"));\n        }\n    });\n};\n/**\r\n * This method can be used to store recorded blobs into IndexedDB storage.\r\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\r\n * @method\r\n * @memberof RecordRTC\r\n * @example\r\n * RecordRTC.writeToDisk({\r\n *     audio: audioBlob,\r\n *     video: videoBlob,\r\n *     gif  : gifBlob\r\n * });\r\n */ RecordRTC.writeToDisk = function(options) {\n    console.log(\"Writing recorded blob(s) to disk!\");\n    options = options || {};\n    if (options.audio && options.video && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                options.gif.getDataURL(function(gifDataURL) {\n                    DiskStorage.Store({\n                        audioBlob: audioDataURL,\n                        videoBlob: videoDataURL,\n                        gifBlob: gifDataURL\n                    });\n                });\n            });\n        });\n    } else if (options.audio && options.video) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    videoBlob: videoDataURL\n                });\n            });\n        });\n    } else if (options.audio && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.video && options.gif) {\n        options.video.getDataURL(function(videoDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    videoBlob: videoDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.audio) {\n        options.audio.getDataURL(function(audioDataURL) {\n            DiskStorage.Store({\n                audioBlob: audioDataURL\n            });\n        });\n    } else if (options.video) {\n        options.video.getDataURL(function(videoDataURL) {\n            DiskStorage.Store({\n                videoBlob: videoDataURL\n            });\n        });\n    } else if (options.gif) {\n        options.gif.getDataURL(function(gifDataURL) {\n            DiskStorage.Store({\n                gifBlob: gifDataURL\n            });\n        });\n    }\n};\n// __________________________\n// RecordRTC-Configuration.js\n/**\r\n * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.\r\n * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid \"config\" object.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTCConfiguration\r\n * @class\r\n * @example\r\n * var options = RecordRTCConfiguration(mediaStream, options);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}\r\n */ function RecordRTCConfiguration(mediaStream, config) {\n    if (!config.recorderType && !config.type) {\n        if (!!config.audio && !!config.video) {\n            config.type = \"video\";\n        } else if (!!config.audio && !config.video) {\n            config.type = \"audio\";\n        }\n    }\n    if (config.recorderType && !config.type) {\n        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || typeof WebAssemblyRecorder !== \"undefined\" && config.recorderType === WebAssemblyRecorder) {\n            config.type = \"video\";\n        } else if (config.recorderType === GifRecorder) {\n            config.type = \"gif\";\n        } else if (config.recorderType === StereoAudioRecorder) {\n            config.type = \"audio\";\n        } else if (config.recorderType === MediaStreamRecorder) {\n            if (getTracks(mediaStream, \"audio\").length && getTracks(mediaStream, \"video\").length) {\n                config.type = \"video\";\n            } else if (!getTracks(mediaStream, \"audio\").length && getTracks(mediaStream, \"video\").length) {\n                config.type = \"video\";\n            } else if (getTracks(mediaStream, \"audio\").length && !getTracks(mediaStream, \"video\").length) {\n                config.type = \"audio\";\n            } else {\n            // config.type = 'UnKnown';\n            }\n        }\n    }\n    if (typeof MediaStreamRecorder !== \"undefined\" && typeof MediaRecorder !== \"undefined\" && \"requestData\" in MediaRecorder.prototype) {\n        if (!config.mimeType) {\n            config.mimeType = \"video/webm\";\n        }\n        if (!config.type) {\n            config.type = config.mimeType.split(\"/\")[0];\n        }\n        if (!config.bitsPerSecond) {\n        // config.bitsPerSecond = 128000;\n        }\n    }\n    // consider default type=audio\n    if (!config.type) {\n        if (config.mimeType) {\n            config.type = config.mimeType.split(\"/\")[0];\n        }\n        if (!config.type) {\n            config.type = \"audio\";\n        }\n    }\n    return config;\n}\n// __________________\n// GetRecorderType.js\n/**\r\n * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.\r\n * @summary It returns best recorder-type available for your browser.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef GetRecorderType\r\n * @class\r\n * @example\r\n * var RecorderType = GetRecorderType(options);\r\n * var recorder = new RecorderType(options);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\r\n */ function GetRecorderType(mediaStream, config) {\n    var recorder;\n    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome\n    // todo: detect if it is Edge, then auto use: StereoAudioRecorder\n    if (isChrome || isEdge || isOpera) {\n        // Media Stream Recording API has not been implemented in chrome yet;\n        // That's why using WebAudio API to record stereo audio in WAV format\n        recorder = StereoAudioRecorder;\n    }\n    if (typeof MediaRecorder !== \"undefined\" && \"requestData\" in MediaRecorder.prototype && !isChrome) {\n        recorder = MediaStreamRecorder;\n    }\n    // video recorder (in WebM format)\n    if (config.type === \"video\" && (isChrome || isOpera)) {\n        recorder = WhammyRecorder;\n        if (typeof WebAssemblyRecorder !== \"undefined\" && typeof ReadableStream !== \"undefined\") {\n            recorder = WebAssemblyRecorder;\n        }\n    }\n    // video recorder (in Gif format)\n    if (config.type === \"gif\") {\n        recorder = GifRecorder;\n    }\n    // html2canvas recording!\n    if (config.type === \"canvas\") {\n        recorder = CanvasRecorder;\n    }\n    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== \"undefined\" && \"requestData\" in MediaRecorder.prototype) {\n        if (getTracks(mediaStream, \"video\").length || getTracks(mediaStream, \"audio\").length) {\n            // audio-only recording\n            if (config.type === \"audio\") {\n                if (typeof MediaRecorder.isTypeSupported === \"function\" && MediaRecorder.isTypeSupported(\"audio/webm\")) {\n                    recorder = MediaStreamRecorder;\n                }\n            // else recorder = StereoAudioRecorder;\n            } else {\n                // video or screen tracks\n                if (typeof MediaRecorder.isTypeSupported === \"function\" && MediaRecorder.isTypeSupported(\"video/webm\")) {\n                    recorder = MediaStreamRecorder;\n                }\n            }\n        }\n    }\n    if (mediaStream instanceof Array && mediaStream.length) {\n        recorder = MultiStreamRecorder;\n    }\n    if (config.recorderType) {\n        recorder = config.recorderType;\n    }\n    if (!config.disableLogs && !!recorder && !!recorder.name) {\n        console.log(\"Using recorderType:\", recorder.name || recorder.constructor.name);\n    }\n    if (!recorder && isSafari) {\n        recorder = MediaStreamRecorder;\n    }\n    return recorder;\n}\n// _____________\n// MRecordRTC.js\n/**\r\n * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.\r\n * @summary MRecordRTC stands for \"Multiple-RecordRTC\".\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef MRecordRTC\r\n * @class\r\n * @example\r\n * var recorder = new MRecordRTC();\r\n * recorder.addStream(MediaStream);\r\n * recorder.mediaType = {\r\n *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder\r\n *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\r\n *     gif: true    // or GifRecorder\r\n * };\r\n * // mimeType is optional and should be set only in advance cases.\r\n * recorder.mimeType = {\r\n *     audio: 'audio/wav',\r\n *     video: 'video/webm',\r\n *     gif:   'image/gif'\r\n * };\r\n * recorder.startRecording();\r\n * @see For further information:\r\n * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @requires {@link RecordRTC}\r\n */ function MRecordRTC(mediaStream) {\n    /**\r\n     * This method attaches MediaStream object to {@link MRecordRTC}.\r\n     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.addStream(MediaStream);\r\n     */ this.addStream = function(_mediaStream) {\n        if (_mediaStream) {\n            mediaStream = _mediaStream;\n        }\n    };\n    /**\r\n     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.\r\n     * @property {object} mediaType - {audio: true, video: true, gif: true}\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * var recorder = new MRecordRTC();\r\n     * recorder.mediaType = {\r\n     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder\r\n     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\r\n     *     gif  : true  // TRUE or GifRecorder\r\n     * };\r\n     */ this.mediaType = {\n        audio: true,\n        video: true\n    };\n    /**\r\n     * This method starts recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.startRecording();\r\n     */ this.startRecording = function() {\n        var mediaType = this.mediaType;\n        var recorderType;\n        var mimeType = this.mimeType || {\n            audio: null,\n            video: null,\n            gif: null\n        };\n        if (typeof mediaType.audio !== \"function\" && isMediaRecorderCompatible() && !getTracks(mediaStream, \"audio\").length) {\n            mediaType.audio = false;\n        }\n        if (typeof mediaType.video !== \"function\" && isMediaRecorderCompatible() && !getTracks(mediaStream, \"video\").length) {\n            mediaType.video = false;\n        }\n        if (typeof mediaType.gif !== \"function\" && isMediaRecorderCompatible() && !getTracks(mediaStream, \"video\").length) {\n            mediaType.gif = false;\n        }\n        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {\n            throw \"MediaStream must have either audio or video tracks.\";\n        }\n        if (!!mediaType.audio) {\n            recorderType = null;\n            if (typeof mediaType.audio === \"function\") {\n                recorderType = mediaType.audio;\n            }\n            this.audioRecorder = new RecordRTC(mediaStream, {\n                type: \"audio\",\n                bufferSize: this.bufferSize,\n                sampleRate: this.sampleRate,\n                numberOfAudioChannels: this.numberOfAudioChannels || 2,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.audio,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp\n            });\n            if (!mediaType.video) {\n                this.audioRecorder.startRecording();\n            }\n        }\n        if (!!mediaType.video) {\n            recorderType = null;\n            if (typeof mediaType.video === \"function\") {\n                recorderType = mediaType.video;\n            }\n            var newStream = mediaStream;\n            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === \"function\") {\n                var videoTrack = getTracks(mediaStream, \"video\")[0];\n                if (isFirefox) {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n                    if (recorderType && recorderType === WhammyRecorder) {\n                        // Firefox does NOT supports webp-encoding yet\n                        // But Firefox do supports WebAssemblyRecorder\n                        recorderType = MediaStreamRecorder;\n                    }\n                } else {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n                }\n            }\n            this.videoRecorder = new RecordRTC(newStream, {\n                type: \"video\",\n                video: this.video,\n                canvas: this.canvas,\n                frameInterval: this.frameInterval || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.video,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp,\n                workerPath: this.workerPath,\n                webAssemblyPath: this.webAssemblyPath,\n                frameRate: this.frameRate,\n                bitrate: this.bitrate // used by WebAssemblyRecorder; values: 0 to 1000+\n            });\n            if (!mediaType.audio) {\n                this.videoRecorder.startRecording();\n            }\n        }\n        if (!!mediaType.audio && !!mediaType.video) {\n            var self = this;\n            var isSingleRecorder = isMediaRecorderCompatible() === true;\n            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {\n                isSingleRecorder = false;\n            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {\n                isSingleRecorder = false;\n            }\n            if (isSingleRecorder === true) {\n                self.audioRecorder = null;\n                self.videoRecorder.startRecording();\n            } else {\n                self.videoRecorder.initRecorder(function() {\n                    self.audioRecorder.initRecorder(function() {\n                        // Both recorders are ready to record things accurately\n                        self.videoRecorder.startRecording();\n                        self.audioRecorder.startRecording();\n                    });\n                });\n            }\n        }\n        if (!!mediaType.gif) {\n            recorderType = null;\n            if (typeof mediaType.gif === \"function\") {\n                recorderType = mediaType.gif;\n            }\n            this.gifRecorder = new RecordRTC(mediaStream, {\n                type: \"gif\",\n                frameRate: this.frameRate || 200,\n                quality: this.quality || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.gif\n            });\n            this.gifRecorder.startRecording();\n        }\n    };\n    /**\r\n     * This method stops recording.\r\n     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.stopRecording(function(recording){\r\n     *     var audioBlob = recording.audio;\r\n     *     var videoBlob = recording.video;\r\n     *     var gifBlob   = recording.gif;\r\n     * });\r\n     */ this.stopRecording = function(callback) {\n        callback = callback || function() {};\n        if (this.audioRecorder) {\n            this.audioRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, \"audio\");\n            });\n        }\n        if (this.videoRecorder) {\n            this.videoRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, \"video\");\n            });\n        }\n        if (this.gifRecorder) {\n            this.gifRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, \"gif\");\n            });\n        }\n    };\n    /**\r\n     * This method pauses recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.pauseRecording();\r\n     */ this.pauseRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.pauseRecording();\n        }\n        if (this.videoRecorder) {\n            this.videoRecorder.pauseRecording();\n        }\n        if (this.gifRecorder) {\n            this.gifRecorder.pauseRecording();\n        }\n    };\n    /**\r\n     * This method resumes recording.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.resumeRecording();\r\n     */ this.resumeRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.resumeRecording();\n        }\n        if (this.videoRecorder) {\n            this.videoRecorder.resumeRecording();\n        }\n        if (this.gifRecorder) {\n            this.gifRecorder.resumeRecording();\n        }\n    };\n    /**\r\n     * This method can be used to manually get all recorded blobs.\r\n     * @param {function} callback - All recorded blobs are passed back to the \"callback\" function.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.getBlob(function(recording){\r\n     *     var audioBlob = recording.audio;\r\n     *     var videoBlob = recording.video;\r\n     *     var gifBlob   = recording.gif;\r\n     * });\r\n     * // or\r\n     * var audioBlob = recorder.getBlob().audio;\r\n     * var videoBlob = recorder.getBlob().video;\r\n     */ this.getBlob = function(callback) {\n        var output = {};\n        if (this.audioRecorder) {\n            output.audio = this.audioRecorder.getBlob();\n        }\n        if (this.videoRecorder) {\n            output.video = this.videoRecorder.getBlob();\n        }\n        if (this.gifRecorder) {\n            output.gif = this.gifRecorder.getBlob();\n        }\n        if (callback) {\n            callback(output);\n        }\n        return output;\n    };\n    /**\r\n     * Destroy all recorder instances.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.destroy();\r\n     */ this.destroy = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.destroy();\n            this.audioRecorder = null;\n        }\n        if (this.videoRecorder) {\n            this.videoRecorder.destroy();\n            this.videoRecorder = null;\n        }\n        if (this.gifRecorder) {\n            this.gifRecorder.destroy();\n            this.gifRecorder = null;\n        }\n    };\n    /**\r\n     * This method can be used to manually get all recorded blobs' DataURLs.\r\n     * @param {function} callback - All recorded blobs' DataURLs are passed back to the \"callback\" function.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.getDataURL(function(recording){\r\n     *     var audioDataURL = recording.audio;\r\n     *     var videoDataURL = recording.video;\r\n     *     var gifDataURL   = recording.gif;\r\n     * });\r\n     */ this.getDataURL = function(callback) {\n        this.getBlob(function(blob) {\n            if (blob.audio && blob.video) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    getDataURL(blob.video, function(_videoDataURL) {\n                        callback({\n                            audio: _audioDataURL,\n                            video: _videoDataURL\n                        });\n                    });\n                });\n            } else if (blob.audio) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    callback({\n                        audio: _audioDataURL\n                    });\n                });\n            } else if (blob.video) {\n                getDataURL(blob.video, function(_videoDataURL) {\n                    callback({\n                        video: _videoDataURL\n                    });\n                });\n            }\n        });\n        function getDataURL(blob, callback00) {\n            if (typeof Worker !== \"undefined\") {\n                var webWorker = processInWebWorker(function readFile(_blob) {\n                    postMessage(new FileReaderSync().readAsDataURL(_blob));\n                });\n                webWorker.onmessage = function(event) {\n                    callback00(event.data);\n                };\n                webWorker.postMessage(blob);\n            } else {\n                var reader = new FileReader();\n                reader.readAsDataURL(blob);\n                reader.onload = function(event) {\n                    callback00(event.target.result);\n                };\n            }\n        }\n        function processInWebWorker(_function) {\n            var blob = URL.createObjectURL(new Blob([\n                _function.toString(),\n                \"this.onmessage =  function (eee) {\" + _function.name + \"(eee.data);}\"\n            ], {\n                type: \"application/javascript\"\n            }));\n            var worker = new Worker(blob);\n            var url;\n            if (typeof URL !== \"undefined\") {\n                url = URL;\n            } else if (typeof webkitURL !== \"undefined\") {\n                url = webkitURL;\n            } else {\n                throw \"Neither URL nor webkitURL detected.\";\n            }\n            url.revokeObjectURL(blob);\n            return worker;\n        }\n    };\n    /**\r\n     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.writeToDisk();\r\n     */ this.writeToDisk = function() {\n        RecordRTC.writeToDisk({\n            audio: this.audioRecorder,\n            video: this.videoRecorder,\n            gif: this.gifRecorder\n        });\n    };\n    /**\r\n     * This method can be used to invoke a save-as dialog for all recorded blobs.\r\n     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}\r\n     * @method\r\n     * @memberof MRecordRTC\r\n     * @example\r\n     * recorder.save({\r\n     *     audio: 'audio-file-name',\r\n     *     video: 'video-file-name',\r\n     *     gif  : 'gif-file-name'\r\n     * });\r\n     */ this.save = function(args) {\n        args = args || {\n            audio: true,\n            video: true,\n            gif: true\n        };\n        if (!!args.audio && this.audioRecorder) {\n            this.audioRecorder.save(typeof args.audio === \"string\" ? args.audio : \"\");\n        }\n        if (!!args.video && this.videoRecorder) {\n            this.videoRecorder.save(typeof args.video === \"string\" ? args.video : \"\");\n        }\n        if (!!args.gif && this.gifRecorder) {\n            this.gifRecorder.save(typeof args.gif === \"string\" ? args.gif : \"\");\n        }\n    };\n}\n/**\r\n * This method can be used to get all recorded blobs from IndexedDB storage.\r\n * @param {string} type - 'all' or 'audio' or 'video' or 'gif'\r\n * @param {function} callback - Callback function to get all stored blobs.\r\n * @method\r\n * @memberof MRecordRTC\r\n * @example\r\n * MRecordRTC.getFromDisk('all', function(dataURL, type){\r\n *     if(type === 'audio') { }\r\n *     if(type === 'video') { }\r\n *     if(type === 'gif')   { }\r\n * });\r\n */ MRecordRTC.getFromDisk = RecordRTC.getFromDisk;\n/**\r\n * This method can be used to store recorded blobs into IndexedDB storage.\r\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\r\n * @method\r\n * @memberof MRecordRTC\r\n * @example\r\n * MRecordRTC.writeToDisk({\r\n *     audio: audioBlob,\r\n *     video: videoBlob,\r\n *     gif  : gifBlob\r\n * });\r\n */ MRecordRTC.writeToDisk = RecordRTC.writeToDisk;\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.MRecordRTC = MRecordRTC;\n}\nvar browserFakeUserAgent = \"Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45\";\n(function(that) {\n    if (!that) {\n        return;\n    }\n    if (false) {}\n    if (typeof global === \"undefined\") {\n        return;\n    }\n    global.navigator = {\n        userAgent: browserFakeUserAgent,\n        getUserMedia: function() {}\n    };\n    if (!global.console) {\n        global.console = {};\n    }\n    if (typeof global.console.log === \"undefined\" || typeof global.console.error === \"undefined\") {\n        global.console.error = global.console.log = global.console.log || function() {\n            console.log(arguments);\n        };\n    }\n    if (typeof document === \"undefined\") {\n        /*global document:true */ that.document = {\n            documentElement: {\n                appendChild: function() {\n                    return \"\";\n                }\n            }\n        };\n        document.createElement = document.captureStream = document.mozCaptureStream = function() {\n            var obj = {\n                getContext: function() {\n                    return obj;\n                },\n                play: function() {},\n                pause: function() {},\n                drawImage: function() {},\n                toDataURL: function() {\n                    return \"\";\n                },\n                style: {}\n            };\n            return obj;\n        };\n        that.HTMLVideoElement = function() {};\n    }\n    if (typeof location === \"undefined\") {\n        /*global location:true */ that.location = {\n            protocol: \"file:\",\n            href: \"\",\n            hash: \"\"\n        };\n    }\n    if (typeof screen === \"undefined\") {\n        /*global screen:true */ that.screen = {\n            width: 0,\n            height: 0\n        };\n    }\n    if (typeof URL === \"undefined\") {\n        /*global screen:true */ that.URL = {\n            createObjectURL: function() {\n                return \"\";\n            },\n            revokeObjectURL: function() {\n                return \"\";\n            }\n        };\n    }\n    /*global window:true */ that.window = global;\n})(typeof global !== \"undefined\" ? global : null);\n// _____________________________\n// Cross-Browser-Declarations.js\n// animation-frame used in WebM recording\n/*jshint -W079 */ var requestAnimationFrame = window.requestAnimationFrame;\nif (typeof requestAnimationFrame === \"undefined\") {\n    if (typeof webkitRequestAnimationFrame !== \"undefined\") {\n        /*global requestAnimationFrame:true */ requestAnimationFrame = webkitRequestAnimationFrame;\n    } else if (typeof mozRequestAnimationFrame !== \"undefined\") {\n        /*global requestAnimationFrame:true */ requestAnimationFrame = mozRequestAnimationFrame;\n    } else if (typeof msRequestAnimationFrame !== \"undefined\") {\n        /*global requestAnimationFrame:true */ requestAnimationFrame = msRequestAnimationFrame;\n    } else if (typeof requestAnimationFrame === \"undefined\") {\n        // via: https://gist.github.com/paulirish/1579671\n        var lastTime = 0;\n        /*global requestAnimationFrame:true */ requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n}\n/*jshint -W079 */ var cancelAnimationFrame = window.cancelAnimationFrame;\nif (typeof cancelAnimationFrame === \"undefined\") {\n    if (typeof webkitCancelAnimationFrame !== \"undefined\") {\n        /*global cancelAnimationFrame:true */ cancelAnimationFrame = webkitCancelAnimationFrame;\n    } else if (typeof mozCancelAnimationFrame !== \"undefined\") {\n        /*global cancelAnimationFrame:true */ cancelAnimationFrame = mozCancelAnimationFrame;\n    } else if (typeof msCancelAnimationFrame !== \"undefined\") {\n        /*global cancelAnimationFrame:true */ cancelAnimationFrame = msCancelAnimationFrame;\n    } else if (typeof cancelAnimationFrame === \"undefined\") {\n        /*global cancelAnimationFrame:true */ cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}\n// WebAudio API representer\nvar AudioContext = window.AudioContext;\nif (typeof AudioContext === \"undefined\") {\n    if (typeof webkitAudioContext !== \"undefined\") {\n        /*global AudioContext:true */ AudioContext = webkitAudioContext;\n    }\n    if (typeof mozAudioContext !== \"undefined\") {\n        /*global AudioContext:true */ AudioContext = mozAudioContext;\n    }\n}\n/*jshint -W079 */ var URL = window.URL;\nif (typeof URL === \"undefined\" && typeof webkitURL !== \"undefined\") {\n    /*global URL:true */ URL = webkitURL;\n}\nif (typeof navigator !== \"undefined\" && typeof navigator.getUserMedia === \"undefined\") {\n    if (typeof navigator.webkitGetUserMedia !== \"undefined\") {\n        navigator.getUserMedia = navigator.webkitGetUserMedia;\n    }\n    if (typeof navigator.mozGetUserMedia !== \"undefined\") {\n        navigator.getUserMedia = navigator.mozGetUserMedia;\n    }\n}\nvar isEdge = navigator.userAgent.indexOf(\"Edge\") !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);\nvar isOpera = !!window.opera || navigator.userAgent.indexOf(\"OPR/\") !== -1;\nvar isFirefox = navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1 && \"netscape\" in window && / rv:/.test(navigator.userAgent);\nvar isChrome = !isOpera && !isEdge && !!navigator.webkitGetUserMedia || isElectron() || navigator.userAgent.toLowerCase().indexOf(\"chrome/\") !== -1;\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nif (isSafari && !isChrome && navigator.userAgent.indexOf(\"CriOS\") !== -1) {\n    isSafari = false;\n    isChrome = true;\n}\nvar MediaStream = window.MediaStream;\nif (typeof MediaStream === \"undefined\" && typeof webkitMediaStream !== \"undefined\") {\n    MediaStream = webkitMediaStream;\n}\n/*global MediaStream:true */ if (typeof MediaStream !== \"undefined\") {\n    // override \"stop\" method for all browsers\n    if (typeof MediaStream.prototype.stop === \"undefined\") {\n        MediaStream.prototype.stop = function() {\n            this.getTracks().forEach(function(track) {\n                track.stop();\n            });\n        };\n    }\n}\n// below function via: http://goo.gl/B3ae8c\n/**\r\n * Return human-readable file size.\r\n * @param {number} bytes - Pass bytes and get formatted string.\r\n * @returns {string} - formatted string\r\n * @example\r\n * bytesToSize(1024*1024*5) === '5 GB'\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ function bytesToSize(bytes) {\n    var k = 1000;\n    var sizes = [\n        \"Bytes\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\"\n    ];\n    if (bytes === 0) {\n        return \"0 Bytes\";\n    }\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\n    return (bytes / Math.pow(k, i)).toPrecision(3) + \" \" + sizes[i];\n}\n/**\r\n * @param {Blob} file - File or Blob object. This parameter is required.\r\n * @param {string} fileName - Optional file name e.g. \"Recorded-Video.webm\"\r\n * @example\r\n * invokeSaveAsDialog(blob or file, [optional] fileName);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ function invokeSaveAsDialog(file, fileName) {\n    if (!file) {\n        throw \"Blob object is required.\";\n    }\n    if (!file.type) {\n        try {\n            file.type = \"video/webm\";\n        } catch (e) {}\n    }\n    var fileExtension = (file.type || \"video/webm\").split(\"/\")[1];\n    if (fileExtension.indexOf(\";\") !== -1) {\n        // extended mimetype, e.g. 'video/webm;codecs=vp8,opus'\n        fileExtension = fileExtension.split(\";\")[0];\n    }\n    if (fileName && fileName.indexOf(\".\") !== -1) {\n        var splitted = fileName.split(\".\");\n        fileName = splitted[0];\n        fileExtension = splitted[1];\n    }\n    var fileFullName = (fileName || Math.round(Math.random() * 9999999999) + 888888888) + \".\" + fileExtension;\n    if (typeof navigator.msSaveOrOpenBlob !== \"undefined\") {\n        return navigator.msSaveOrOpenBlob(file, fileFullName);\n    } else if (typeof navigator.msSaveBlob !== \"undefined\") {\n        return navigator.msSaveBlob(file, fileFullName);\n    }\n    var hyperlink = document.createElement(\"a\");\n    hyperlink.href = URL.createObjectURL(file);\n    hyperlink.download = fileFullName;\n    hyperlink.style = \"display:none;opacity:0;color:transparent;\";\n    (document.body || document.documentElement).appendChild(hyperlink);\n    if (typeof hyperlink.click === \"function\") {\n        hyperlink.click();\n    } else {\n        hyperlink.target = \"_blank\";\n        hyperlink.dispatchEvent(new MouseEvent(\"click\", {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        }));\n    }\n    URL.revokeObjectURL(hyperlink.href);\n}\n/**\r\n * from: https://github.com/cheton/is-electron/blob/master/index.js\r\n **/ function isElectron() {\n    // Renderer process\n    if (false) {}\n    // Main process\n    if (typeof process !== \"undefined\" && typeof process.versions === \"object\" && !!process.versions.electron) {\n        return true;\n    }\n    // Detect the user agent when the `nodeIntegration` option is set to true\n    if (typeof navigator === \"object\" && typeof navigator.userAgent === \"string\" && navigator.userAgent.indexOf(\"Electron\") >= 0) {\n        return true;\n    }\n    return false;\n}\nfunction getTracks(stream, kind) {\n    if (!stream || !stream.getTracks) {\n        return [];\n    }\n    return stream.getTracks().filter(function(t) {\n        return t.kind === (kind || \"audio\");\n    });\n}\nfunction setSrcObject(stream, element) {\n    if (\"srcObject\" in element) {\n        element.srcObject = stream;\n    } else if (\"mozSrcObject\" in element) {\n        element.mozSrcObject = stream;\n    } else {\n        element.srcObject = stream;\n    }\n}\n/**\r\n * @param {Blob} file - File or Blob object.\r\n * @param {function} callback - Callback function.\r\n * @example\r\n * getSeekableBlob(blob or file, callback);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ function getSeekableBlob(inputBlob, callback) {\n    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml\n    if (typeof EBML === \"undefined\") {\n        throw new Error(\"Please link: https://www.webrtc-experiment.com/EBML.js\");\n    }\n    var reader = new EBML.Reader();\n    var decoder = new EBML.Decoder();\n    var tools = EBML.tools;\n    var fileReader = new FileReader();\n    fileReader.onload = function(e) {\n        var ebmlElms = decoder.decode(this.result);\n        ebmlElms.forEach(function(element) {\n            reader.read(element);\n        });\n        reader.stop();\n        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\n        var body = this.result.slice(reader.metadataSize);\n        var newBlob = new Blob([\n            refinedMetadataBuf,\n            body\n        ], {\n            type: \"video/webm\"\n        });\n        callback(newBlob);\n    };\n    fileReader.readAsArrayBuffer(inputBlob);\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;\n    RecordRTC.getTracks = getTracks;\n    RecordRTC.getSeekableBlob = getSeekableBlob;\n    RecordRTC.bytesToSize = bytesToSize;\n    RecordRTC.isElectron = isElectron;\n}\n// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129\n// Storage.js\n/**\r\n * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. \"new AudioContext\".\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @example\r\n * Storage.AudioContext === webkitAudioContext\r\n * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ var Storage = {};\nif (typeof AudioContext !== \"undefined\") {\n    Storage.AudioContext = AudioContext;\n} else if (typeof webkitAudioContext !== \"undefined\") {\n    Storage.AudioContext = webkitAudioContext;\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.Storage = Storage;\n}\nfunction isMediaRecorderCompatible() {\n    if (isFirefox || isSafari || isEdge) {\n        return true;\n    }\n    var nVer = navigator.appVersion;\n    var nAgt = navigator.userAgent;\n    var fullVersion = \"\" + parseFloat(navigator.appVersion);\n    var majorVersion = parseInt(navigator.appVersion, 10);\n    var nameOffset, verOffset, ix;\n    if (isChrome || isOpera) {\n        verOffset = nAgt.indexOf(\"Chrome\");\n        fullVersion = nAgt.substring(verOffset + 7);\n    }\n    // trim the fullVersion string at semicolon/space if present\n    if ((ix = fullVersion.indexOf(\";\")) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n    if ((ix = fullVersion.indexOf(\" \")) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n    majorVersion = parseInt(\"\" + fullVersion, 10);\n    if (isNaN(majorVersion)) {\n        fullVersion = \"\" + parseFloat(navigator.appVersion);\n        majorVersion = parseInt(navigator.appVersion, 10);\n    }\n    return majorVersion >= 49;\n}\n// ______________________\n// MediaStreamRecorder.js\n/**\r\n * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.\r\n * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://github.com/muaz-khan|Muaz Khan}\r\n * @typedef MediaStreamRecorder\r\n * @class\r\n * @example\r\n * var config = {\r\n *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis\r\n *     audioBitsPerSecond : 256 * 8 * 1024,\r\n *     videoBitsPerSecond : 256 * 8 * 1024,\r\n *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two\r\n *     checkForInactiveTracks: true,\r\n *     timeSlice: 1000, // concatenate intervals based blobs\r\n *     ondataavailable: function() {} // get intervals based blobs\r\n * }\r\n * var recorder = new MediaStreamRecorder(mediaStream, config);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n *\r\n *     // or\r\n *     var blob = recorder.blob;\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {disableLogs:true, initCallback: function, mimeType: \"video/webm\", timeSlice: 1000}\r\n * @throws Will throw an error if first argument \"MediaStream\" is missing. Also throws error if \"MediaRecorder API\" are not supported by the browser.\r\n */ function MediaStreamRecorder(mediaStream, config) {\n    var self = this;\n    if (typeof mediaStream === \"undefined\") {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n    if (typeof MediaRecorder === \"undefined\") {\n        throw \"Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.\";\n    }\n    config = config || {\n        // bitsPerSecond: 256 * 8 * 1024,\n        mimeType: \"video/webm\"\n    };\n    if (config.type === \"audio\") {\n        if (getTracks(mediaStream, \"video\").length && getTracks(mediaStream, \"audio\").length) {\n            var stream;\n            if (!!navigator.mozGetUserMedia) {\n                stream = new MediaStream();\n                stream.addTrack(getTracks(mediaStream, \"audio\")[0]);\n            } else {\n                // webkitMediaStream\n                stream = new MediaStream(getTracks(mediaStream, \"audio\"));\n            }\n            mediaStream = stream;\n        }\n        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf(\"audio\") === -1) {\n            config.mimeType = isChrome ? \"audio/webm\" : \"audio/ogg\";\n        }\n        if (config.mimeType && config.mimeType.toString().toLowerCase() !== \"audio/ogg\" && !!navigator.mozGetUserMedia) {\n            // forcing better codecs on Firefox (via #166)\n            config.mimeType = \"audio/ogg\";\n        }\n    }\n    var arrayOfBlobs = [];\n    /**\r\n     * This method returns array of blobs. Use only with \"timeSlice\". Its useful to preview recording anytime, without using the \"stop\" method.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var arrayOfBlobs = recorder.getArrayOfBlobs();\r\n     * @returns {Array} Returns array of recorded blobs.\r\n     */ this.getArrayOfBlobs = function() {\n        return arrayOfBlobs;\n    };\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        // set defaults\n        self.blob = null;\n        self.clearRecordedData();\n        self.timestamps = [];\n        allStates = [];\n        arrayOfBlobs = [];\n        var recorderHints = config;\n        if (!config.disableLogs) {\n            console.log(\"Passing following config over MediaRecorder API.\", recorderHints);\n        }\n        if (mediaRecorder) {\n            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.\n            mediaRecorder = null;\n        }\n        if (isChrome && !isMediaRecorderCompatible()) {\n            // to support video-only recording on stable\n            recorderHints = \"video/vp8\";\n        }\n        if (typeof MediaRecorder.isTypeSupported === \"function\" && recorderHints.mimeType) {\n            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {\n                if (!config.disableLogs) {\n                    console.warn(\"MediaRecorder API seems unable to record mimeType:\", recorderHints.mimeType);\n                }\n                recorderHints.mimeType = config.type === \"audio\" ? \"audio/webm\" : \"video/webm\";\n            }\n        }\n        // using MediaRecorder API here\n        try {\n            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);\n            // reset\n            config.mimeType = recorderHints.mimeType;\n        } catch (e) {\n            // chrome-based fallback\n            mediaRecorder = new MediaRecorder(mediaStream);\n        }\n        // old hack?\n        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && \"canRecordMimeType\" in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {\n            if (!config.disableLogs) {\n                console.warn(\"MediaRecorder API seems unable to record mimeType:\", recorderHints.mimeType);\n            }\n        }\n        // Dispatching OnDataAvailable Handler\n        mediaRecorder.ondataavailable = function(e) {\n            if (e.data) {\n                allStates.push(\"ondataavailable: \" + bytesToSize(e.data.size));\n            }\n            if (typeof config.timeSlice === \"number\") {\n                if (e.data && e.data.size) {\n                    arrayOfBlobs.push(e.data);\n                    updateTimeStamp();\n                    if (typeof config.ondataavailable === \"function\") {\n                        // intervals based blobs\n                        var blob = config.getNativeBlob ? e.data : new Blob([\n                            e.data\n                        ], {\n                            type: getMimeType(recorderHints)\n                        });\n                        config.ondataavailable(blob);\n                    }\n                }\n                return;\n            }\n            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {\n                // make sure that stopRecording always getting fired\n                // even if there is invalid data\n                if (self.recordingCallback) {\n                    self.recordingCallback(new Blob([], {\n                        type: getMimeType(recorderHints)\n                    }));\n                    self.recordingCallback = null;\n                }\n                return;\n            }\n            self.blob = config.getNativeBlob ? e.data : new Blob([\n                e.data\n            ], {\n                type: getMimeType(recorderHints)\n            });\n            if (self.recordingCallback) {\n                self.recordingCallback(self.blob);\n                self.recordingCallback = null;\n            }\n        };\n        mediaRecorder.onstart = function() {\n            allStates.push(\"started\");\n        };\n        mediaRecorder.onpause = function() {\n            allStates.push(\"paused\");\n        };\n        mediaRecorder.onresume = function() {\n            allStates.push(\"resumed\");\n        };\n        mediaRecorder.onstop = function() {\n            allStates.push(\"stopped\");\n        };\n        mediaRecorder.onerror = function(error) {\n            if (!error) {\n                return;\n            }\n            if (!error.name) {\n                error.name = \"UnknownError\";\n            }\n            allStates.push(\"error: \" + error);\n            if (!config.disableLogs) {\n                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary\n                if (error.name.toString().toLowerCase().indexOf(\"invalidstate\") !== -1) {\n                    console.error(\"The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.\", error);\n                } else if (error.name.toString().toLowerCase().indexOf(\"notsupported\") !== -1) {\n                    console.error(\"MIME type (\", recorderHints.mimeType, \") is not supported.\", error);\n                } else if (error.name.toString().toLowerCase().indexOf(\"security\") !== -1) {\n                    console.error(\"MediaRecorder security error\", error);\n                } else if (error.name === \"OutOfMemory\") {\n                    console.error(\"The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.\", error);\n                } else if (error.name === \"IllegalStreamModification\") {\n                    console.error(\"A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.\", error);\n                } else if (error.name === \"OtherRecordingError\") {\n                    console.error(\"Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.\", error);\n                } else if (error.name === \"GenericError\") {\n                    console.error(\"The UA cannot provide the codec or recording option that has been requested.\", error);\n                } else {\n                    console.error(\"MediaRecorder Error\", error);\n                }\n            }\n            (function(looper) {\n                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === \"inactive\") {\n                    delete config.timeslice;\n                    // 10 minutes, enough?\n                    mediaRecorder.start(10 * 60 * 1000);\n                    return;\n                }\n                setTimeout(looper, 1000);\n            })();\n            if (mediaRecorder.state !== \"inactive\" && mediaRecorder.state !== \"stopped\") {\n                mediaRecorder.stop();\n            }\n        };\n        if (typeof config.timeSlice === \"number\") {\n            updateTimeStamp();\n            mediaRecorder.start(config.timeSlice);\n        } else {\n            // default is 60 minutes; enough?\n            // use config => {timeSlice: 1000} otherwise\n            mediaRecorder.start(3.6e+6);\n        }\n        if (config.initCallback) {\n            config.initCallback(); // old code\n        }\n    };\n    /**\r\n     * @property {Array} timestamps - Array of time stamps\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * console.log(recorder.timestamps);\r\n     */ this.timestamps = [];\n    function updateTimeStamp() {\n        self.timestamps.push(new Date().getTime());\n        if (typeof config.onTimeStamp === \"function\") {\n            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);\n        }\n    }\n    function getMimeType(secondObject) {\n        if (mediaRecorder && mediaRecorder.mimeType) {\n            return mediaRecorder.mimeType;\n        }\n        return secondObject.mimeType || \"video/webm\";\n    }\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        callback = callback || function() {};\n        self.manuallyStopped = true; // used inside the mediaRecorder.onerror\n        if (!mediaRecorder) {\n            return;\n        }\n        this.recordingCallback = callback;\n        if (mediaRecorder.state === \"recording\") {\n            mediaRecorder.stop();\n        }\n        if (typeof config.timeSlice === \"number\") {\n            setTimeout(function() {\n                self.blob = new Blob(arrayOfBlobs, {\n                    type: getMimeType(config)\n                });\n                self.recordingCallback(self.blob);\n            }, 100);\n        }\n    };\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n        if (mediaRecorder.state === \"recording\") {\n            mediaRecorder.pause();\n        }\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n        if (mediaRecorder.state === \"paused\") {\n            mediaRecorder.resume();\n        }\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        if (mediaRecorder && mediaRecorder.state === \"recording\") {\n            self.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n    function clearRecordedDataCB() {\n        arrayOfBlobs = [];\n        mediaRecorder = null;\n        self.timestamps = [];\n    }\n    // Reference to \"MediaRecorder\" object\n    var mediaRecorder;\n    /**\r\n     * Access to native MediaRecorder API\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @instance\r\n     * @example\r\n     * var internal = recorder.getInternalRecorder();\r\n     * internal.ondataavailable = function() {}; // override\r\n     * internal.stream, internal.onpause, internal.onstop, etc.\r\n     * @returns {Object} Returns internal recording object.\r\n     */ this.getInternalRecorder = function() {\n        return mediaRecorder;\n    };\n    function isMediaStreamActive() {\n        if (\"active\" in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if (\"ended\" in mediaStream) {\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\r\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * recorder.stop(function() {\r\n     *     var blob = recorder.blob;\r\n     * });\r\n     */ this.blob = null;\n    /**\r\n     * Get MediaRecorder readonly state.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var state = recorder.getState();\r\n     * @returns {String} Returns recording state.\r\n     */ this.getState = function() {\n        if (!mediaRecorder) {\n            return \"inactive\";\n        }\n        return mediaRecorder.state || \"inactive\";\n    };\n    // list of all recording states\n    var allStates = [];\n    /**\r\n     * Get MediaRecorder all recording states.\r\n     * @method\r\n     * @memberof MediaStreamRecorder\r\n     * @example\r\n     * var state = recorder.getAllStates();\r\n     * @returns {Array} Returns all recording states\r\n     */ this.getAllStates = function() {\n        return allStates;\n    };\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === \"undefined\") {\n        config.checkForInactiveTracks = false; // disable to minimize CPU usage\n    }\n    var self = this;\n    // this method checks if media stream is stopped\n    // or if any track is ended.\n    (function looper() {\n        if (!mediaRecorder || config.checkForInactiveTracks === false) {\n            return;\n        }\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log(\"MediaStream seems stopped.\");\n            }\n            self.stop();\n            return;\n        }\n        setTimeout(looper, 1000); // check every second\n    })();\n    // for debugging\n    this.name = \"MediaStreamRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;\n}\n// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js\n// https://github.com/mattdiamond/Recorderjs#license-mit\n// ______________________\n// StereoAudioRecorder.js\n/**\r\n * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring \"stereo\" audio-recording in chrome.\r\n * @summary JavaScript standalone object for stereo audio recording.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef StereoAudioRecorder\r\n * @class\r\n * @example\r\n * var recorder = new StereoAudioRecorder(MediaStream, {\r\n *     sampleRate: 44100,\r\n *     bufferSize: 4096\r\n * });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}\r\n */ function StereoAudioRecorder(mediaStream, config) {\n    if (!getTracks(mediaStream, \"audio\").length) {\n        throw \"Your stream has no audio tracks.\";\n    }\n    config = config || {};\n    var self = this;\n    // variables\n    var leftchannel = [];\n    var rightchannel = [];\n    var recording = false;\n    var recordingLength = 0;\n    var jsAudioNode;\n    var numberOfAudioChannels = 2;\n    /**\r\n     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182\r\n     * @property {number} desiredSampRate - Desired Bits per sample * 1000\r\n     * @memberof StereoAudioRecorder\r\n     * @instance\r\n     * @example\r\n     * var recorder = StereoAudioRecorder(mediaStream, {\r\n     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000\r\n     * });\r\n     */ var desiredSampRate = config.desiredSampRate;\n    // backward compatibility\n    if (config.leftChannel === true) {\n        numberOfAudioChannels = 1;\n    }\n    if (config.numberOfAudioChannels === 1) {\n        numberOfAudioChannels = 1;\n    }\n    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {\n        numberOfAudioChannels = 2;\n    }\n    if (!config.disableLogs) {\n        console.log(\"StereoAudioRecorder is set to record number of channels: \" + numberOfAudioChannels);\n    }\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === \"undefined\") {\n        config.checkForInactiveTracks = true;\n    }\n    function isMediaStreamActive() {\n        if (config.checkForInactiveTracks === false) {\n            // always return \"true\"\n            return true;\n        }\n        if (\"active\" in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if (\"ended\" in mediaStream) {\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        if (isMediaStreamActive() === false) {\n            throw \"Please make sure MediaStream is active.\";\n        }\n        resetVariables();\n        isAudioProcessStarted = isPaused = false;\n        recording = true;\n        if (typeof config.timeSlice !== \"undefined\") {\n            looper();\n        }\n    };\n    function mergeLeftRightBuffers(config, callback) {\n        function mergeAudioBuffers(config, cb) {\n            var numberOfAudioChannels = config.numberOfAudioChannels;\n            // todo: \"slice(0)\" --- is it causes loop? Should be removed?\n            var leftBuffers = config.leftBuffers.slice(0);\n            var rightBuffers = config.rightBuffers.slice(0);\n            var sampleRate = config.sampleRate;\n            var internalInterleavedLength = config.internalInterleavedLength;\n            var desiredSampRate = config.desiredSampRate;\n            if (numberOfAudioChannels === 2) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);\n                }\n            }\n            if (numberOfAudioChannels === 1) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                }\n            }\n            // set sample rate as desired sample rate\n            if (desiredSampRate) {\n                sampleRate = desiredSampRate;\n            }\n            // for changing the sampling rate, reference:\n            // http://stackoverflow.com/a/28977136/552182\n            function interpolateArray(data, newSampleRate, oldSampleRate) {\n                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));\n                var newData = [];\n                var springFactor = Number((data.length - 1) / (fitCount - 1));\n                newData[0] = data[0];\n                for(var i = 1; i < fitCount - 1; i++){\n                    var tmp = i * springFactor;\n                    var before = Number(Math.floor(tmp)).toFixed();\n                    var after = Number(Math.ceil(tmp)).toFixed();\n                    var atPoint = tmp - before;\n                    newData[i] = linearInterpolate(data[before], data[after], atPoint);\n                }\n                newData[fitCount - 1] = data[data.length - 1];\n                return newData;\n            }\n            function linearInterpolate(before, after, atPoint) {\n                return before + (after - before) * atPoint;\n            }\n            function mergeBuffers(channelBuffer, rLength) {\n                var result = new Float64Array(rLength);\n                var offset = 0;\n                var lng = channelBuffer.length;\n                for(var i = 0; i < lng; i++){\n                    var buffer = channelBuffer[i];\n                    result.set(buffer, offset);\n                    offset += buffer.length;\n                }\n                return result;\n            }\n            function interleave(leftChannel, rightChannel) {\n                var length = leftChannel.length + rightChannel.length;\n                var result = new Float64Array(length);\n                var inputIndex = 0;\n                for(var index = 0; index < length;){\n                    result[index++] = leftChannel[inputIndex];\n                    result[index++] = rightChannel[inputIndex];\n                    inputIndex++;\n                }\n                return result;\n            }\n            function writeUTFBytes(view, offset, string) {\n                var lng = string.length;\n                for(var i = 0; i < lng; i++){\n                    view.setUint8(offset + i, string.charCodeAt(i));\n                }\n            }\n            // interleave both channels together\n            var interleaved;\n            if (numberOfAudioChannels === 2) {\n                interleaved = interleave(leftBuffers, rightBuffers);\n            }\n            if (numberOfAudioChannels === 1) {\n                interleaved = leftBuffers;\n            }\n            var interleavedLength = interleaved.length;\n            // create wav file\n            var resultingBufferLength = 44 + interleavedLength * 2;\n            var buffer = new ArrayBuffer(resultingBufferLength);\n            var view = new DataView(buffer);\n            // RIFF chunk descriptor/identifier \n            writeUTFBytes(view, 0, \"RIFF\");\n            // RIFF chunk length\n            // changed \"44\" to \"36\" via #401\n            view.setUint32(4, 36 + interleavedLength * 2, true);\n            // RIFF type \n            writeUTFBytes(view, 8, \"WAVE\");\n            // format chunk identifier \n            // FMT sub-chunk\n            writeUTFBytes(view, 12, \"fmt \");\n            // format chunk length \n            view.setUint32(16, 16, true);\n            // sample format (raw)\n            view.setUint16(20, 1, true);\n            // stereo (2 channels)\n            view.setUint16(22, numberOfAudioChannels, true);\n            // sample rate \n            view.setUint32(24, sampleRate, true);\n            // byte rate (sample rate * block align)\n            view.setUint32(28, sampleRate * numberOfAudioChannels * 2, true);\n            // block align (channel count * bytes per sample) \n            view.setUint16(32, numberOfAudioChannels * 2, true);\n            // bits per sample \n            view.setUint16(34, 16, true);\n            // data sub-chunk\n            // data chunk identifier \n            writeUTFBytes(view, 36, \"data\");\n            // data chunk length \n            view.setUint32(40, interleavedLength * 2, true);\n            // write the PCM samples\n            var lng = interleavedLength;\n            var index = 44;\n            var volume = 1;\n            for(var i = 0; i < lng; i++){\n                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n                index += 2;\n            }\n            if (cb) {\n                return cb({\n                    buffer: buffer,\n                    view: view\n                });\n            }\n            postMessage({\n                buffer: buffer,\n                view: view\n            });\n        }\n        if (config.noWorker) {\n            mergeAudioBuffers(config, function(data) {\n                callback(data.buffer, data.view);\n            });\n            return;\n        }\n        var webWorker = processInWebWorker(mergeAudioBuffers);\n        webWorker.onmessage = function(event) {\n            callback(event.data.buffer, event.data.view);\n            // release memory\n            URL.revokeObjectURL(webWorker.workerURL);\n            // kill webworker (or Chrome will kill your page after ~25 calls)\n            webWorker.terminate();\n        };\n        webWorker.postMessage(config);\n    }\n    function processInWebWorker(_function) {\n        var workerURL = URL.createObjectURL(new Blob([\n            _function.toString(),\n            \";this.onmessage =  function (eee) {\" + _function.name + \"(eee.data);}\"\n        ], {\n            type: \"application/javascript\"\n        }));\n        var worker = new Worker(workerURL);\n        worker.workerURL = workerURL;\n        return worker;\n    }\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        callback = callback || function() {};\n        // stop recording\n        recording = false;\n        mergeLeftRightBuffers({\n            desiredSampRate: desiredSampRate,\n            sampleRate: sampleRate,\n            numberOfAudioChannels: numberOfAudioChannels,\n            internalInterleavedLength: recordingLength,\n            leftBuffers: leftchannel,\n            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,\n            noWorker: config.noWorker\n        }, function(buffer, view) {\n            /**\r\n             * @property {Blob} blob - The recorded blob object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */ self.blob = new Blob([\n                view\n            ], {\n                type: \"audio/wav\"\n            });\n            /**\r\n             * @property {ArrayBuffer} buffer - The recorded buffer object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var buffer = recorder.buffer;\r\n             * });\r\n             */ self.buffer = new ArrayBuffer(view.buffer.byteLength);\n            /**\r\n             * @property {DataView} view - The recorded data-view object.\r\n             * @memberof StereoAudioRecorder\r\n             * @example\r\n             * recorder.stop(function(){\r\n             *     var view = recorder.view;\r\n             * });\r\n             */ self.view = view;\n            self.sampleRate = desiredSampRate || sampleRate;\n            self.bufferSize = bufferSize;\n            // recorded audio length\n            self.length = recordingLength;\n            isAudioProcessStarted = false;\n            if (callback) {\n                callback(self.blob);\n            }\n        });\n    };\n    if (typeof RecordRTC.Storage === \"undefined\") {\n        RecordRTC.Storage = {\n            AudioContextConstructor: null,\n            AudioContext: window.AudioContext || window.webkitAudioContext\n        };\n    }\n    if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === \"closed\") {\n        RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();\n    }\n    var context = RecordRTC.Storage.AudioContextConstructor;\n    // creates an audio node from the microphone incoming stream\n    var audioInput = context.createMediaStreamSource(mediaStream);\n    var legalBufferValues = [\n        0,\n        256,\n        512,\n        1024,\n        2048,\n        4096,\n        8192,\n        16384\n    ];\n    /**\r\n     * From the spec: This value controls how frequently the audioprocess event is\r\n     * dispatched and how many sample-frames need to be processed each call.\r\n     * Lower values for buffer size will result in a lower (better) latency.\r\n     * Higher values will be necessary to avoid audio breakup and glitches\r\n     * The size of the buffer (in sample-frames) which needs to\r\n     * be processed each time onprocessaudio is called.\r\n     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\r\n     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     bufferSize: 4096\r\n     * });\r\n     */ // \"0\" means, let chrome decide the most accurate buffer-size for current platform.\n    var bufferSize = typeof config.bufferSize === \"undefined\" ? 4096 : config.bufferSize;\n    if (legalBufferValues.indexOf(bufferSize) === -1) {\n        if (!config.disableLogs) {\n            console.log(\"Legal values for buffer-size are \" + JSON.stringify(legalBufferValues, null, \"\t\"));\n        }\n    }\n    if (context.createJavaScriptNode) {\n        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else if (context.createScriptProcessor) {\n        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else {\n        throw \"WebAudio API has no support on this browser.\";\n    }\n    // connect the stream to the script processor\n    audioInput.connect(jsAudioNode);\n    if (!config.bufferSize) {\n        bufferSize = jsAudioNode.bufferSize; // device buffer-size\n    }\n    /**\r\n     * The sample rate (in sample-frames per second) at which the\r\n     * AudioContext handles audio. It is assumed that all AudioNodes\r\n     * in the context run at this rate. In making this assumption,\r\n     * sample-rate converters or \"varispeed\" processors are not supported\r\n     * in real-time processing.\r\n     * The sampleRate parameter describes the sample-rate of the\r\n     * linear PCM audio data in the buffer in sample-frames per second.\r\n     * An implementation must support sample-rates in at least\r\n     * the range 22050 to 96000.\r\n     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder = new StereoAudioRecorder(mediaStream, {\r\n     *     sampleRate: 44100\r\n     * });\r\n     */ var sampleRate = typeof config.sampleRate !== \"undefined\" ? config.sampleRate : context.sampleRate || 44100;\n    if (sampleRate < 22050 || sampleRate > 96000) {\n        // Ref: http://stackoverflow.com/a/26303918/552182\n        if (!config.disableLogs) {\n            console.log(\"sample-rate must be under range 22050 and 96000.\");\n        }\n    }\n    if (!config.disableLogs) {\n        if (config.desiredSampRate) {\n            console.log(\"Desired sample-rate: \" + config.desiredSampRate);\n        }\n    }\n    var isPaused = false;\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        isPaused = true;\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        if (isMediaStreamActive() === false) {\n            throw \"Please make sure MediaStream is active.\";\n        }\n        if (!recording) {\n            if (!config.disableLogs) {\n                console.log(\"Seems recording has been restarted.\");\n            }\n            this.record();\n            return;\n        }\n        isPaused = false;\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof StereoAudioRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        config.checkForInactiveTracks = false;\n        if (recording) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n    function resetVariables() {\n        leftchannel = [];\n        rightchannel = [];\n        recordingLength = 0;\n        isAudioProcessStarted = false;\n        recording = false;\n        isPaused = false;\n        context = null;\n        self.leftchannel = leftchannel;\n        self.rightchannel = rightchannel;\n        self.numberOfAudioChannels = numberOfAudioChannels;\n        self.desiredSampRate = desiredSampRate;\n        self.sampleRate = sampleRate;\n        self.recordingLength = recordingLength;\n        intervalsBasedBuffers = {\n            left: [],\n            right: [],\n            recordingLength: 0\n        };\n    }\n    function clearRecordedDataCB() {\n        if (jsAudioNode) {\n            jsAudioNode.onaudioprocess = null;\n            jsAudioNode.disconnect();\n            jsAudioNode = null;\n        }\n        if (audioInput) {\n            audioInput.disconnect();\n            audioInput = null;\n        }\n        resetVariables();\n    }\n    // for debugging\n    this.name = \"StereoAudioRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n    var isAudioProcessStarted = false;\n    function onAudioProcessDataAvailable(e) {\n        if (isPaused) {\n            return;\n        }\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log(\"MediaStream seems stopped.\");\n            }\n            jsAudioNode.disconnect();\n            recording = false;\n        }\n        if (!recording) {\n            if (audioInput) {\n                audioInput.disconnect();\n                audioInput = null;\n            }\n            return;\n        }\n        /**\r\n         * This method is called on \"onaudioprocess\" event's first invocation.\r\n         * @method {function} onAudioProcessStarted\r\n         * @memberof StereoAudioRecorder\r\n         * @example\r\n         * recorder.onAudioProcessStarted: function() { };\r\n         */ if (!isAudioProcessStarted) {\n            isAudioProcessStarted = true;\n            if (config.onAudioProcessStarted) {\n                config.onAudioProcessStarted();\n            }\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        }\n        var left = e.inputBuffer.getChannelData(0);\n        // we clone the samples\n        var chLeft = new Float32Array(left);\n        leftchannel.push(chLeft);\n        if (numberOfAudioChannels === 2) {\n            var right = e.inputBuffer.getChannelData(1);\n            var chRight = new Float32Array(right);\n            rightchannel.push(chRight);\n        }\n        recordingLength += bufferSize;\n        // export raw PCM\n        self.recordingLength = recordingLength;\n        if (typeof config.timeSlice !== \"undefined\") {\n            intervalsBasedBuffers.recordingLength += bufferSize;\n            intervalsBasedBuffers.left.push(chLeft);\n            if (numberOfAudioChannels === 2) {\n                intervalsBasedBuffers.right.push(chRight);\n            }\n        }\n    }\n    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;\n    // to prevent self audio to be connected with speakers\n    if (context.createMediaStreamDestination) {\n        jsAudioNode.connect(context.createMediaStreamDestination());\n    } else {\n        jsAudioNode.connect(context.destination);\n    }\n    // export raw PCM\n    this.leftchannel = leftchannel;\n    this.rightchannel = rightchannel;\n    this.numberOfAudioChannels = numberOfAudioChannels;\n    this.desiredSampRate = desiredSampRate;\n    this.sampleRate = sampleRate;\n    self.recordingLength = recordingLength;\n    // helper for intervals based blobs\n    var intervalsBasedBuffers = {\n        left: [],\n        right: [],\n        recordingLength: 0\n    };\n    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)\n    function looper() {\n        if (!recording || typeof config.ondataavailable !== \"function\" || typeof config.timeSlice === \"undefined\") {\n            return;\n        }\n        if (intervalsBasedBuffers.left.length) {\n            mergeLeftRightBuffers({\n                desiredSampRate: desiredSampRate,\n                sampleRate: sampleRate,\n                numberOfAudioChannels: numberOfAudioChannels,\n                internalInterleavedLength: intervalsBasedBuffers.recordingLength,\n                leftBuffers: intervalsBasedBuffers.left,\n                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right\n            }, function(buffer, view) {\n                var blob = new Blob([\n                    view\n                ], {\n                    type: \"audio/wav\"\n                });\n                config.ondataavailable(blob);\n                setTimeout(looper, config.timeSlice);\n            });\n            intervalsBasedBuffers = {\n                left: [],\n                right: [],\n                recordingLength: 0\n            };\n        } else {\n            setTimeout(looper, config.timeSlice);\n        }\n    }\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;\n}\n// _________________\n// CanvasRecorder.js\n/**\r\n * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.\r\n * @summary HTML2Canvas recording into video WebM.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef CanvasRecorder\r\n * @class\r\n * @example\r\n * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.\r\n * @param {object} config - {disableLogs:true, initCallback: function}\r\n */ function CanvasRecorder(htmlElement, config) {\n    if (typeof html2canvas === \"undefined\") {\n        throw \"Please link: https://www.webrtc-experiment.com/screenshot.js\";\n    }\n    config = config || {};\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n    // via DetectRTC.js\n    var isCanvasSupportsStreamCapturing = false;\n    [\n        \"captureStream\",\n        \"mozCaptureStream\",\n        \"webkitCaptureStream\"\n    ].forEach(function(item) {\n        if (item in document.createElement(\"canvas\")) {\n            isCanvasSupportsStreamCapturing = true;\n        }\n    });\n    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;\n    var chromeVersion = 50;\n    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n    if (_isChrome && matchArray && matchArray[2]) {\n        chromeVersion = parseInt(matchArray[2], 10);\n    }\n    if (_isChrome && chromeVersion < 52) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n    if (config.useWhammyRecorder) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n    var globalCanvas, mediaStreamRecorder;\n    if (isCanvasSupportsStreamCapturing) {\n        if (!config.disableLogs) {\n            console.log(\"Your browser supports both MediRecorder API and canvas.captureStream!\");\n        }\n        if (htmlElement instanceof HTMLCanvasElement) {\n            globalCanvas = htmlElement;\n        } else if (htmlElement instanceof CanvasRenderingContext2D) {\n            globalCanvas = htmlElement.canvas;\n        } else {\n            throw \"Please pass either HTMLCanvasElement or CanvasRenderingContext2D.\";\n        }\n    } else if (!!navigator.mozGetUserMedia) {\n        if (!config.disableLogs) {\n            console.error(\"Canvas recording is NOT supported in Firefox.\");\n        }\n    }\n    var isRecording;\n    /**\r\n     * This method records Canvas.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        isRecording = true;\n        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {\n            // CanvasCaptureMediaStream\n            var canvasMediaStream;\n            if (\"captureStream\" in globalCanvas) {\n                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS\n            } else if (\"mozCaptureStream\" in globalCanvas) {\n                canvasMediaStream = globalCanvas.mozCaptureStream(25);\n            } else if (\"webkitCaptureStream\" in globalCanvas) {\n                canvasMediaStream = globalCanvas.webkitCaptureStream(25);\n            }\n            try {\n                var mdStream = new MediaStream();\n                mdStream.addTrack(getTracks(canvasMediaStream, \"video\")[0]);\n                canvasMediaStream = mdStream;\n            } catch (e) {}\n            if (!canvasMediaStream) {\n                throw \"captureStream API are NOT available.\";\n            }\n            // Note: Jan 18, 2016 status is that, \n            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.\n            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {\n                mimeType: config.mimeType || \"video/webm\"\n            });\n            mediaStreamRecorder.record();\n        } else {\n            whammy.frames = [];\n            lastTime = new Date().getTime();\n            drawCanvasFrame();\n        }\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n    this.getWebPImages = function(callback) {\n        if (htmlElement.nodeName.toLowerCase() !== \"canvas\") {\n            callback();\n            return;\n        }\n        var framesLength = whammy.frames.length;\n        whammy.frames.forEach(function(frame, idx) {\n            var framesRemaining = framesLength - idx;\n            if (!config.disableLogs) {\n                console.log(framesRemaining + \"/\" + framesLength + \" frames remaining\");\n            }\n            if (config.onEncodingCallback) {\n                config.onEncodingCallback(framesRemaining, framesLength);\n            }\n            var webp = frame.image.toDataURL(\"image/webp\", 1);\n            whammy.frames[idx].image = webp;\n        });\n        if (!config.disableLogs) {\n            console.log(\"Generating WebM\");\n        }\n        callback();\n    };\n    /**\r\n     * This method stops recording Canvas.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        isRecording = false;\n        var that = this;\n        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {\n            mediaStreamRecorder.stop(callback);\n            return;\n        }\n        this.getWebPImages(function() {\n            /**\r\n             * @property {Blob} blob - Recorded frames in video/webm blob.\r\n             * @memberof CanvasRecorder\r\n             * @example\r\n             * recorder.stop(function() {\r\n             *     var blob = recorder.blob;\r\n             * });\r\n             */ whammy.compile(function(blob) {\n                if (!config.disableLogs) {\n                    console.log(\"Recording finished!\");\n                }\n                that.blob = blob;\n                if (that.blob.forEach) {\n                    that.blob = new Blob([], {\n                        type: \"video/webm\"\n                    });\n                }\n                if (callback) {\n                    callback(that.blob);\n                }\n                whammy.frames = [];\n            });\n        });\n    };\n    var isPausedRecording = false;\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        isPausedRecording = true;\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.pause();\n            return;\n        }\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        isPausedRecording = false;\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.resume();\n            return;\n        }\n        if (!isRecording) {\n            this.record();\n        }\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof CanvasRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        if (isRecording) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isRecording = false;\n        isPausedRecording = false;\n    }\n    // for debugging\n    this.name = \"CanvasRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n    function cloneCanvas() {\n        //create a new canvas\n        var newCanvas = document.createElement(\"canvas\");\n        var context = newCanvas.getContext(\"2d\");\n        //set dimensions\n        newCanvas.width = htmlElement.width;\n        newCanvas.height = htmlElement.height;\n        //apply the old canvas to the new one\n        context.drawImage(htmlElement, 0, 0);\n        //return the new canvas\n        return newCanvas;\n    }\n    function drawCanvasFrame() {\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawCanvasFrame, 500);\n        }\n        if (htmlElement.nodeName.toLowerCase() === \"canvas\") {\n            var duration = new Date().getTime() - lastTime;\n            // via #206, by Jack i.e. @Seymourr\n            lastTime = new Date().getTime();\n            whammy.frames.push({\n                image: cloneCanvas(),\n                duration: duration\n            });\n            if (isRecording) {\n                setTimeout(drawCanvasFrame, config.frameInterval);\n            }\n            return;\n        }\n        html2canvas(htmlElement, {\n            grabMouse: typeof config.showMousePointer === \"undefined\" || config.showMousePointer,\n            onrendered: function(canvas) {\n                var duration = new Date().getTime() - lastTime;\n                if (!duration) {\n                    return setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n                // via #206, by Jack i.e. @Seymourr\n                lastTime = new Date().getTime();\n                whammy.frames.push({\n                    image: canvas.toDataURL(\"image/webp\", 1),\n                    duration: duration\n                });\n                if (isRecording) {\n                    setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n            }\n        });\n    }\n    var lastTime = new Date().getTime();\n    var whammy = new Whammy.Video(100);\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.CanvasRecorder = CanvasRecorder;\n}\n// _________________\n// WhammyRecorder.js\n/**\r\n * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.\r\n * @summary Video recording feature in Chrome.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef WhammyRecorder\r\n * @class\r\n * @example\r\n * var recorder = new WhammyRecorder(mediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}\r\n */ function WhammyRecorder(mediaStream, config) {\n    config = config || {};\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n    if (!config.disableLogs) {\n        console.log(\"Using frames-interval:\", config.frameInterval);\n    }\n    /**\r\n     * This method records video.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        if (!config.width) {\n            config.width = 320;\n        }\n        if (!config.height) {\n            config.height = 240;\n        }\n        if (!config.video) {\n            config.video = {\n                width: config.width,\n                height: config.height\n            };\n        }\n        if (!config.canvas) {\n            config.canvas = {\n                width: config.width,\n                height: config.height\n            };\n        }\n        canvas.width = config.canvas.width || 320;\n        canvas.height = config.canvas.height || 240;\n        context = canvas.getContext(\"2d\");\n        // setting defaults\n        if (config.video && config.video instanceof HTMLVideoElement) {\n            video = config.video.cloneNode();\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        } else {\n            video = document.createElement(\"video\");\n            setSrcObject(mediaStream, video);\n            video.onloadedmetadata = function() {\n                if (config.initCallback) {\n                    config.initCallback();\n                }\n            };\n            video.width = config.video.width;\n            video.height = config.video.height;\n        }\n        video.muted = true;\n        video.play();\n        lastTime = new Date().getTime();\n        whammy = new Whammy.Video();\n        if (!config.disableLogs) {\n            console.log(\"canvas resolutions\", canvas.width, \"*\", canvas.height);\n            console.log(\"video width/height\", video.width || canvas.width, \"*\", video.height || canvas.height);\n        }\n        drawFrames(config.frameInterval);\n    };\n    /**\r\n     * Draw and push frames to Whammy\r\n     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy\r\n     */ function drawFrames(frameInterval) {\n        frameInterval = typeof frameInterval !== \"undefined\" ? frameInterval : 10;\n        var duration = new Date().getTime() - lastTime;\n        if (!duration) {\n            return setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawFrames, 100);\n        }\n        // via #206, by Jack i.e. @Seymourr\n        lastTime = new Date().getTime();\n        if (video.paused) {\n            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n            // Tweak for Android Chrome\n            video.play();\n        }\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        whammy.frames.push({\n            duration: duration,\n            image: canvas.toDataURL(\"image/webp\")\n        });\n        if (!isStopDrawing) {\n            setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n    }\n    function asyncLoop(o) {\n        var i = -1, length = o.length;\n        (function loop() {\n            i++;\n            if (i === length) {\n                o.callback();\n                return;\n            }\n            // \"setTimeout\" added by Jim McLeod\n            setTimeout(function() {\n                o.functionToLoop(loop, i);\n            }, 1);\n        })();\n    }\n    /**\r\n     * remove black frames from the beginning to the specified frame\r\n     * @param {Array} _frames - array of frames to be checked\r\n     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)\r\n     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all\r\n     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all\r\n     * @returns {Array} - array of frames\r\n     */ // pull#293 by @volodalexey\n    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {\n        var localCanvas = document.createElement(\"canvas\");\n        localCanvas.width = canvas.width;\n        localCanvas.height = canvas.height;\n        var context2d = localCanvas.getContext(\"2d\");\n        var resultFrames = [];\n        var checkUntilNotBlack = _framesToCheck === -1;\n        var endCheckFrame = _framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length ? _framesToCheck : _frames.length;\n        var sampleColor = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        var maxColorDifference = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2));\n        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;\n        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;\n        var doNotCheckNext = false;\n        asyncLoop({\n            length: endCheckFrame,\n            functionToLoop: function(loop, f) {\n                var matchPixCount, endPixCheck, maxPixCount;\n                var finishImage = function() {\n                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {\n                    // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);\n                    } else {\n                        // console.log('frame is passed : ' + f);\n                        if (checkUntilNotBlack) {\n                            doNotCheckNext = true;\n                        }\n                        resultFrames.push(_frames[f]);\n                    }\n                    loop();\n                };\n                if (!doNotCheckNext) {\n                    var image = new Image();\n                    image.onload = function() {\n                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);\n                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);\n                        matchPixCount = 0;\n                        endPixCheck = imageData.data.length;\n                        maxPixCount = imageData.data.length / 4;\n                        for(var pix = 0; pix < endPixCheck; pix += 4){\n                            var currentColor = {\n                                r: imageData.data[pix],\n                                g: imageData.data[pix + 1],\n                                b: imageData.data[pix + 2]\n                            };\n                            var colorDifference = Math.sqrt(Math.pow(currentColor.r - sampleColor.r, 2) + Math.pow(currentColor.g - sampleColor.g, 2) + Math.pow(currentColor.b - sampleColor.b, 2));\n                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)\n                            if (colorDifference <= maxColorDifference * pixTolerance) {\n                                matchPixCount++;\n                            }\n                        }\n                        finishImage();\n                    };\n                    image.src = _frames[f].image;\n                } else {\n                    finishImage();\n                }\n            },\n            callback: function() {\n                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));\n                if (resultFrames.length <= 0) {\n                    // at least one last frame should be available for next manipulation\n                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...\n                    resultFrames.push(_frames[_frames.length - 1]);\n                }\n                callback(resultFrames);\n            }\n        });\n    }\n    var isStopDrawing = false;\n    /**\r\n     * This method stops recording video.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        callback = callback || function() {};\n        isStopDrawing = true;\n        var _this = this;\n        // analyse of all frames takes some time!\n        setTimeout(function() {\n            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames\n            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames\n            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color\n            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {\n                whammy.frames = frames;\n                // to display advertisement images!\n                if (config.advertisement && config.advertisement.length) {\n                    whammy.frames = config.advertisement.concat(whammy.frames);\n                }\n                /**\r\n                 * @property {Blob} blob - Recorded frames in video/webm blob.\r\n                 * @memberof WhammyRecorder\r\n                 * @example\r\n                 * recorder.stop(function() {\r\n                 *     var blob = recorder.blob;\r\n                 * });\r\n                 */ whammy.compile(function(blob) {\n                    _this.blob = blob;\n                    if (_this.blob.forEach) {\n                        _this.blob = new Blob([], {\n                            type: \"video/webm\"\n                        });\n                    }\n                    if (callback) {\n                        callback(_this.blob);\n                    }\n                });\n            });\n        }, 10);\n    };\n    var isPausedRecording = false;\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        isPausedRecording = true;\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        isPausedRecording = false;\n        if (isStopDrawing) {\n            this.record();\n        }\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof WhammyRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        if (!isStopDrawing) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isStopDrawing = true;\n        isPausedRecording = false;\n    }\n    // for debugging\n    this.name = \"WhammyRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n    var canvas = document.createElement(\"canvas\");\n    var context = canvas.getContext(\"2d\");\n    var video;\n    var lastTime;\n    var whammy;\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.WhammyRecorder = WhammyRecorder;\n}\n// https://github.com/antimatter15/whammy/blob/master/LICENSE\n// _________\n// Whammy.js\n// todo: Firefox now supports webp for webm containers!\n// their MediaRecorder implementation works well!\n// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?\n/**\r\n * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}\r\n * @summary A real time javascript webm encoder based on a canvas hack.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef Whammy\r\n * @class\r\n * @example\r\n * var recorder = new Whammy().Video(15);\r\n * recorder.add(context || canvas || dataURL);\r\n * var output = recorder.compile();\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ var Whammy = function() {\n    // a more abstract-ish API\n    function WhammyVideo(duration) {\n        this.frames = [];\n        this.duration = duration || 1;\n        this.quality = 0.8;\n    }\n    /**\r\n     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.\r\n     * @method\r\n     * @memberof Whammy\r\n     * @example\r\n     * recorder = new Whammy().Video(0.8, 100);\r\n     * recorder.add(canvas || context || 'image/webp');\r\n     * @param {string} frame - Canvas || Context || image/webp\r\n     * @param {number} duration - Stick a duration (in milliseconds)\r\n     */ WhammyVideo.prototype.add = function(frame, duration) {\n        if (\"canvas\" in frame) {\n            frame = frame.canvas;\n        }\n        if (\"toDataURL\" in frame) {\n            frame = frame.toDataURL(\"image/webp\", this.quality);\n        }\n        if (!/^data:image\\/webp;base64,/ig.test(frame)) {\n            throw \"Input must be formatted properly as a base64 encoded DataURI of type image/webp\";\n        }\n        this.frames.push({\n            image: frame,\n            duration: duration || this.duration\n        });\n    };\n    function processInWebWorker(_function) {\n        var blob = URL.createObjectURL(new Blob([\n            _function.toString(),\n            \"this.onmessage =  function (eee) {\" + _function.name + \"(eee.data);}\"\n        ], {\n            type: \"application/javascript\"\n        }));\n        var worker = new Worker(blob);\n        URL.revokeObjectURL(blob);\n        return worker;\n    }\n    function whammyInWebWorker(frames) {\n        function ArrayToWebM(frames) {\n            var info = checkFrames(frames);\n            if (!info) {\n                return [];\n            }\n            var clusterMaxDuration = 30000;\n            var EBML1 = [\n                {\n                    \"id\": 0x1a45dfa3,\n                    \"data\": [\n                        {\n                            \"data\": 1,\n                            \"id\": 0x4286 // EBMLVersion\n                        },\n                        {\n                            \"data\": 1,\n                            \"id\": 0x42f7 // EBMLReadVersion\n                        },\n                        {\n                            \"data\": 4,\n                            \"id\": 0x42f2 // EBMLMaxIDLength\n                        },\n                        {\n                            \"data\": 8,\n                            \"id\": 0x42f3 // EBMLMaxSizeLength\n                        },\n                        {\n                            \"data\": \"webm\",\n                            \"id\": 0x4282 // DocType\n                        },\n                        {\n                            \"data\": 2,\n                            \"id\": 0x4287 // DocTypeVersion\n                        },\n                        {\n                            \"data\": 2,\n                            \"id\": 0x4285 // DocTypeReadVersion\n                        }\n                    ]\n                },\n                {\n                    \"id\": 0x18538067,\n                    \"data\": [\n                        {\n                            \"id\": 0x1549a966,\n                            \"data\": [\n                                {\n                                    \"data\": 1e6,\n                                    \"id\": 0x2ad7b1 // TimecodeScale\n                                },\n                                {\n                                    \"data\": \"whammy\",\n                                    \"id\": 0x4d80 // MuxingApp\n                                },\n                                {\n                                    \"data\": \"whammy\",\n                                    \"id\": 0x5741 // WritingApp\n                                },\n                                {\n                                    \"data\": doubleToString(info.duration),\n                                    \"id\": 0x4489 // Duration\n                                }\n                            ]\n                        },\n                        {\n                            \"id\": 0x1654ae6b,\n                            \"data\": [\n                                {\n                                    \"id\": 0xae,\n                                    \"data\": [\n                                        {\n                                            \"data\": 1,\n                                            \"id\": 0xd7 // TrackNumber\n                                        },\n                                        {\n                                            \"data\": 1,\n                                            \"id\": 0x73c5 // TrackUID\n                                        },\n                                        {\n                                            \"data\": 0,\n                                            \"id\": 0x9c // FlagLacing\n                                        },\n                                        {\n                                            \"data\": \"und\",\n                                            \"id\": 0x22b59c // Language\n                                        },\n                                        {\n                                            \"data\": \"V_VP8\",\n                                            \"id\": 0x86 // CodecID\n                                        },\n                                        {\n                                            \"data\": \"VP8\",\n                                            \"id\": 0x258688 // CodecName\n                                        },\n                                        {\n                                            \"data\": 1,\n                                            \"id\": 0x83 // TrackType\n                                        },\n                                        {\n                                            \"id\": 0xe0,\n                                            \"data\": [\n                                                {\n                                                    \"data\": info.width,\n                                                    \"id\": 0xb0 // PixelWidth\n                                                },\n                                                {\n                                                    \"data\": info.height,\n                                                    \"id\": 0xba // PixelHeight\n                                                }\n                                            ]\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ];\n            //Generate clusters (max duration)\n            var frameNumber = 0;\n            var clusterTimecode = 0;\n            while(frameNumber < frames.length){\n                var clusterFrames = [];\n                var clusterDuration = 0;\n                do {\n                    clusterFrames.push(frames[frameNumber]);\n                    clusterDuration += frames[frameNumber].duration;\n                    frameNumber++;\n                }while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);\n                var clusterCounter = 0;\n                var cluster = {\n                    \"id\": 0x1f43b675,\n                    \"data\": getClusterData(clusterTimecode, clusterCounter, clusterFrames)\n                }; //Add cluster to segment\n                EBML1[1].data.push(cluster);\n                clusterTimecode += clusterDuration;\n            }\n            return generateEBML(EBML1);\n        }\n        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {\n            return [\n                {\n                    \"data\": clusterTimecode,\n                    \"id\": 0xe7 // Timecode\n                }\n            ].concat(clusterFrames.map(function(webp) {\n                var block = makeSimpleBlock({\n                    discardable: 0,\n                    frame: webp.data.slice(4),\n                    invisible: 0,\n                    keyframe: 1,\n                    lacing: 0,\n                    trackNum: 1,\n                    timecode: Math.round(clusterCounter)\n                });\n                clusterCounter += webp.duration;\n                return {\n                    data: block,\n                    id: 0xa3\n                };\n            }));\n        }\n        // sums the lengths of all the frames and gets the duration\n        function checkFrames(frames) {\n            if (!frames[0]) {\n                postMessage({\n                    error: \"Something went wrong. Maybe WebP format is not supported in the current browser.\"\n                });\n                return;\n            }\n            var width = frames[0].width, height = frames[0].height, duration = frames[0].duration;\n            for(var i = 1; i < frames.length; i++){\n                duration += frames[i].duration;\n            }\n            return {\n                duration: duration,\n                width: width,\n                height: height\n            };\n        }\n        function numToBuffer(num) {\n            var parts = [];\n            while(num > 0){\n                parts.push(num & 0xff);\n                num = num >> 8;\n            }\n            return new Uint8Array(parts.reverse());\n        }\n        function strToBuffer(str) {\n            return new Uint8Array(str.split(\"\").map(function(e) {\n                return e.charCodeAt(0);\n            }));\n        }\n        function bitsToBuffer(bits) {\n            var data = [];\n            var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join(\"0\") : \"\";\n            bits = pad + bits;\n            for(var i = 0; i < bits.length; i += 8){\n                data.push(parseInt(bits.substr(i, 8), 2));\n            }\n            return new Uint8Array(data);\n        }\n        function generateEBML(json) {\n            var ebml = [];\n            for(var i = 0; i < json.length; i++){\n                var data = json[i].data;\n                if (typeof data === \"object\") {\n                    data = generateEBML(data);\n                }\n                if (typeof data === \"number\") {\n                    data = bitsToBuffer(data.toString(2));\n                }\n                if (typeof data === \"string\") {\n                    data = strToBuffer(data);\n                }\n                var len = data.size || data.byteLength || data.length;\n                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\n                var sizeToString = len.toString(2);\n                var padded = new Array(zeroes * 7 + 7 + 1 - sizeToString.length).join(\"0\") + sizeToString;\n                var size = new Array(zeroes).join(\"0\") + \"1\" + padded;\n                ebml.push(numToBuffer(json[i].id));\n                ebml.push(bitsToBuffer(size));\n                ebml.push(data);\n            }\n            return new Blob(ebml, {\n                type: \"video/webm\"\n            });\n        }\n        function toBinStrOld(bits) {\n            var data = \"\";\n            var pad = bits.length % 8 ? new Array(1 + 8 - bits.length % 8).join(\"0\") : \"\";\n            bits = pad + bits;\n            for(var i = 0; i < bits.length; i += 8){\n                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\n            }\n            return data;\n        }\n        function makeSimpleBlock(data) {\n            var flags = 0;\n            if (data.keyframe) {\n                flags |= 128;\n            }\n            if (data.invisible) {\n                flags |= 8;\n            }\n            if (data.lacing) {\n                flags |= data.lacing << 1;\n            }\n            if (data.discardable) {\n                flags |= 1;\n            }\n            if (data.trackNum > 127) {\n                throw \"TrackNumber > 127 not supported\";\n            }\n            var out = [\n                data.trackNum | 0x80,\n                data.timecode >> 8,\n                data.timecode & 0xff,\n                flags\n            ].map(function(e) {\n                return String.fromCharCode(e);\n            }).join(\"\") + data.frame;\n            return out;\n        }\n        function parseWebP(riff) {\n            var VP8 = riff.RIFF[0].WEBP[0];\n            var frameStart = VP8.indexOf(\"\\x9d\\x01*\"); // A VP8 keyframe starts with the 0x9d012a header\n            for(var i = 0, c = []; i < 4; i++){\n                c[i] = VP8.charCodeAt(frameStart + 3 + i);\n            }\n            var width, height, tmp;\n            //the code below is literally copied verbatim from the bitstream spec\n            tmp = c[1] << 8 | c[0];\n            width = tmp & 0x3FFF;\n            tmp = c[3] << 8 | c[2];\n            height = tmp & 0x3FFF;\n            return {\n                width: width,\n                height: height,\n                data: VP8,\n                riff: riff\n            };\n        }\n        function getStrLength(string, offset) {\n            return parseInt(string.substr(offset + 4, 4).split(\"\").map(function(i) {\n                var unpadded = i.charCodeAt(0).toString(2);\n                return new Array(8 - unpadded.length + 1).join(\"0\") + unpadded;\n            }).join(\"\"), 2);\n        }\n        function parseRIFF(string) {\n            var offset = 0;\n            var chunks = {};\n            while(offset < string.length){\n                var id = string.substr(offset, 4);\n                var len = getStrLength(string, offset);\n                var data = string.substr(offset + 4 + 4, len);\n                offset += 4 + 4 + len;\n                chunks[id] = chunks[id] || [];\n                if (id === \"RIFF\" || id === \"LIST\") {\n                    chunks[id].push(parseRIFF(data));\n                } else {\n                    chunks[id].push(data);\n                }\n            }\n            return chunks;\n        }\n        function doubleToString(num) {\n            return [].slice.call(new Uint8Array(new Float64Array([\n                num\n            ]).buffer), 0).map(function(e) {\n                return String.fromCharCode(e);\n            }).reverse().join(\"\");\n        }\n        var webm = new ArrayToWebM(frames.map(function(frame) {\n            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\n            webp.duration = frame.duration;\n            return webp;\n        }));\n        postMessage(webm);\n    }\n    /**\r\n     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof Whammy\r\n     * @example\r\n     * recorder = new Whammy().Video(0.8, 100);\r\n     * recorder.compile(function(blob) {\r\n     *    // blob.size - blob.type\r\n     * });\r\n     */ WhammyVideo.prototype.compile = function(callback) {\n        var webWorker = processInWebWorker(whammyInWebWorker);\n        webWorker.onmessage = function(event) {\n            if (event.data.error) {\n                console.error(event.data.error);\n                return;\n            }\n            callback(event.data);\n        };\n        webWorker.postMessage(this.frames);\n    };\n    return {\n        /**\r\n         * A more abstract-ish API.\r\n         * @method\r\n         * @memberof Whammy\r\n         * @example\r\n         * recorder = new Whammy().Video(0.8, 100);\r\n         * @param {?number} speed - 0.8\r\n         * @param {?number} quality - 100\r\n         */ Video: WhammyVideo\n    };\n}();\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.Whammy = Whammy;\n}\n// ______________ (indexed-db)\n// DiskStorage.js\n/**\r\n * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.\r\n * @summary Writing blobs into IndexedDB.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @example\r\n * DiskStorage.Store({\r\n *     audioBlob: yourAudioBlob,\r\n *     videoBlob: yourVideoBlob,\r\n *     gifBlob  : yourGifBlob\r\n * });\r\n * DiskStorage.Fetch(function(dataURL, type) {\r\n *     if(type === 'audioBlob') { }\r\n *     if(type === 'videoBlob') { }\r\n *     if(type === 'gifBlob')   { }\r\n * });\r\n * // DiskStorage.dataStoreName = 'recordRTC';\r\n * // DiskStorage.onError = function(error) { };\r\n * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\r\n * @property {function} Fetch - This method fetches stored blobs from IndexedDB.\r\n * @property {function} Store - This method stores blobs in IndexedDB.\r\n * @property {function} onError - This function is invoked for any known/unknown error.\r\n * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n */ var DiskStorage = {\n    /**\r\n     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.init();\r\n     */ init: function() {\n        var self = this;\n        if (typeof indexedDB === \"undefined\" || typeof indexedDB.open === \"undefined\") {\n            console.error(\"IndexedDB API are not available in this browser.\");\n            return;\n        }\n        var dbVersion = 1;\n        var dbName = this.dbName || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, \"\"), db;\n        var request = indexedDB.open(dbName, dbVersion);\n        function createObjectStore(dataBase) {\n            dataBase.createObjectStore(self.dataStoreName);\n        }\n        function putInDB() {\n            var transaction = db.transaction([\n                self.dataStoreName\n            ], \"readwrite\");\n            if (self.videoBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.videoBlob, \"videoBlob\");\n            }\n            if (self.gifBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.gifBlob, \"gifBlob\");\n            }\n            if (self.audioBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.audioBlob, \"audioBlob\");\n            }\n            function getFromStore(portionName) {\n                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {\n                    if (self.callback) {\n                        self.callback(event.target.result, portionName);\n                    }\n                };\n            }\n            getFromStore(\"audioBlob\");\n            getFromStore(\"videoBlob\");\n            getFromStore(\"gifBlob\");\n        }\n        request.onerror = self.onError;\n        request.onsuccess = function() {\n            db = request.result;\n            db.onerror = self.onError;\n            if (db.setVersion) {\n                if (db.version !== dbVersion) {\n                    var setVersion = db.setVersion(dbVersion);\n                    setVersion.onsuccess = function() {\n                        createObjectStore(db);\n                        putInDB();\n                    };\n                } else {\n                    putInDB();\n                }\n            } else {\n                putInDB();\n            }\n        };\n        request.onupgradeneeded = function(event) {\n            createObjectStore(event.target.result);\n        };\n    },\n    /**\r\n     * This method fetches stored blobs from IndexedDB.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.Fetch(function(dataURL, type) {\r\n     *     if(type === 'audioBlob') { }\r\n     *     if(type === 'videoBlob') { }\r\n     *     if(type === 'gifBlob')   { }\r\n     * });\r\n     */ Fetch: function(callback) {\n        this.callback = callback;\n        this.init();\n        return this;\n    },\n    /**\r\n     * This method stores blobs in IndexedDB.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.Store({\r\n     *     audioBlob: yourAudioBlob,\r\n     *     videoBlob: yourVideoBlob,\r\n     *     gifBlob  : yourGifBlob\r\n     * });\r\n     */ Store: function(config) {\n        this.audioBlob = config.audioBlob;\n        this.videoBlob = config.videoBlob;\n        this.gifBlob = config.gifBlob;\n        this.init();\n        return this;\n    },\n    /**\r\n     * This function is invoked for any known/unknown error.\r\n     * @method\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.onError = function(error){\r\n     *     alerot( JSON.stringify(error) );\r\n     * };\r\n     */ onError: function(error) {\n        console.error(JSON.stringify(error, null, \"\t\"));\n    },\n    /**\r\n     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\r\n     * @memberof DiskStorage\r\n     * @internal\r\n     * @example\r\n     * DiskStorage.dataStoreName = 'recordRTC';\r\n     */ dataStoreName: \"recordRTC\",\n    dbName: null\n};\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.DiskStorage = DiskStorage;\n}\n// ______________\n// GifRecorder.js\n/**\r\n * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef GifRecorder\r\n * @class\r\n * @example\r\n * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     img.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.\r\n * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}\r\n */ function GifRecorder(mediaStream, config) {\n    if (typeof GIFEncoder === \"undefined\") {\n        var script = document.createElement(\"script\");\n        script.src = \"https://www.webrtc-experiment.com/gif-recorder.js\";\n        (document.body || document.documentElement).appendChild(script);\n    }\n    config = config || {};\n    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        if (typeof GIFEncoder === \"undefined\") {\n            setTimeout(self.record, 1000);\n            return;\n        }\n        if (!isLoadedMetaData) {\n            setTimeout(self.record, 1000);\n            return;\n        }\n        if (!isHTMLObject) {\n            if (!config.width) {\n                config.width = video.offsetWidth || 320;\n            }\n            if (!config.height) {\n                config.height = video.offsetHeight || 240;\n            }\n            if (!config.video) {\n                config.video = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n            if (!config.canvas) {\n                config.canvas = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n            canvas.width = config.canvas.width || 320;\n            canvas.height = config.canvas.height || 240;\n            video.width = config.video.width || 320;\n            video.height = config.video.height || 240;\n        }\n        // external library to record as GIF images\n        gifEncoder = new GIFEncoder();\n        // void setRepeat(int iter) \n        // Sets the number of times the set of GIF frames should be played. \n        // Default is 1; 0 means play indefinitely.\n        gifEncoder.setRepeat(0);\n        // void setFrameRate(Number fps) \n        // Sets frame rate in frames per second. \n        // Equivalent to setDelay(1000/fps).\n        // Using \"setDelay\" instead of \"setFrameRate\"\n        gifEncoder.setDelay(config.frameRate || 200);\n        // void setQuality(int quality) \n        // Sets quality of color quantization (conversion of images to the \n        // maximum 256 colors allowed by the GIF specification). \n        // Lower values (minimum = 1) produce better colors, \n        // but slow processing significantly. 10 is the default, \n        // and produces good color mapping at reasonable speeds. \n        // Values greater than 20 do not yield significant improvements in speed.\n        gifEncoder.setQuality(config.quality || 10);\n        // Boolean start() \n        // This writes the GIF Header and returns false if it fails.\n        gifEncoder.start();\n        if (typeof config.onGifRecordingStarted === \"function\") {\n            config.onGifRecordingStarted();\n        }\n        startTime = Date.now();\n        function drawVideoFrame(time) {\n            if (self.clearedRecordedData === true) {\n                return;\n            }\n            if (isPausedRecording) {\n                return setTimeout(function() {\n                    drawVideoFrame(time);\n                }, 100);\n            }\n            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n            if (typeof lastFrameTime === undefined) {\n                lastFrameTime = time;\n            }\n            // ~10 fps\n            if (time - lastFrameTime < 90) {\n                return;\n            }\n            if (!isHTMLObject && video.paused) {\n                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n                // Tweak for Android Chrome\n                video.play();\n            }\n            if (!isHTMLObject) {\n                context.drawImage(video, 0, 0, canvas.width, canvas.height);\n            }\n            if (config.onGifPreview) {\n                config.onGifPreview(canvas.toDataURL(\"image/png\"));\n            }\n            gifEncoder.addFrame(context);\n            lastFrameTime = time;\n        }\n        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     img.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        callback = callback || function() {};\n        if (lastAnimationFrame) {\n            cancelAnimationFrame(lastAnimationFrame);\n        }\n        endTime = Date.now();\n        /**\r\n         * @property {Blob} blob - The recorded blob object.\r\n         * @memberof GifRecorder\r\n         * @example\r\n         * recorder.stop(function(){\r\n         *     var blob = recorder.blob;\r\n         * });\r\n         */ this.blob = new Blob([\n            new Uint8Array(gifEncoder.stream().bin)\n        ], {\n            type: \"image/gif\"\n        });\n        callback(this.blob);\n        // bug: find a way to clear old recorded blobs\n        gifEncoder.stream().bin = [];\n    };\n    var isPausedRecording = false;\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        isPausedRecording = true;\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        isPausedRecording = false;\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof GifRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        self.clearedRecordedData = true;\n        clearRecordedDataCB();\n    };\n    function clearRecordedDataCB() {\n        if (gifEncoder) {\n            gifEncoder.stream().bin = [];\n        }\n    }\n    // for debugging\n    this.name = \"GifRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n    var canvas = document.createElement(\"canvas\");\n    var context = canvas.getContext(\"2d\");\n    if (isHTMLObject) {\n        if (mediaStream instanceof CanvasRenderingContext2D) {\n            context = mediaStream;\n            canvas = context.canvas;\n        } else if (mediaStream instanceof HTMLCanvasElement) {\n            context = mediaStream.getContext(\"2d\");\n            canvas = mediaStream;\n        }\n    }\n    var isLoadedMetaData = true;\n    if (!isHTMLObject) {\n        var video = document.createElement(\"video\");\n        video.muted = true;\n        video.autoplay = true;\n        video.playsInline = true;\n        isLoadedMetaData = false;\n        video.onloadedmetadata = function() {\n            isLoadedMetaData = true;\n        };\n        setSrcObject(mediaStream, video);\n        video.play();\n    }\n    var lastAnimationFrame = null;\n    var startTime, endTime, lastFrameTime;\n    var gifEncoder;\n    var self = this;\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.GifRecorder = GifRecorder;\n}\n// Last time updated: 2019-06-21 4:09:42 AM UTC\n// ________________________\n// MultiStreamsMixer v1.2.2\n// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\nfunction MultiStreamsMixer(arrayOfMediaStreams, elementClass) {\n    var browserFakeUserAgent = \"Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45\";\n    (function(that) {\n        if (typeof RecordRTC !== \"undefined\") {\n            return;\n        }\n        if (!that) {\n            return;\n        }\n        if (false) {}\n        if (typeof global === \"undefined\") {\n            return;\n        }\n        global.navigator = {\n            userAgent: browserFakeUserAgent,\n            getUserMedia: function() {}\n        };\n        if (!global.console) {\n            global.console = {};\n        }\n        if (typeof global.console.log === \"undefined\" || typeof global.console.error === \"undefined\") {\n            global.console.error = global.console.log = global.console.log || function() {\n                console.log(arguments);\n            };\n        }\n        if (typeof document === \"undefined\") {\n            /*global document:true */ that.document = {\n                documentElement: {\n                    appendChild: function() {\n                        return \"\";\n                    }\n                }\n            };\n            document.createElement = document.captureStream = document.mozCaptureStream = function() {\n                var obj = {\n                    getContext: function() {\n                        return obj;\n                    },\n                    play: function() {},\n                    pause: function() {},\n                    drawImage: function() {},\n                    toDataURL: function() {\n                        return \"\";\n                    },\n                    style: {}\n                };\n                return obj;\n            };\n            that.HTMLVideoElement = function() {};\n        }\n        if (typeof location === \"undefined\") {\n            /*global location:true */ that.location = {\n                protocol: \"file:\",\n                href: \"\",\n                hash: \"\"\n            };\n        }\n        if (typeof screen === \"undefined\") {\n            /*global screen:true */ that.screen = {\n                width: 0,\n                height: 0\n            };\n        }\n        if (typeof URL === \"undefined\") {\n            /*global screen:true */ that.URL = {\n                createObjectURL: function() {\n                    return \"\";\n                },\n                revokeObjectURL: function() {\n                    return \"\";\n                }\n            };\n        }\n        /*global window:true */ that.window = global;\n    })(typeof global !== \"undefined\" ? global : null);\n    // requires: chrome://flags/#enable-experimental-web-platform-features\n    elementClass = elementClass || \"multi-streams-mixer\";\n    var videos = [];\n    var isStopDrawingFrames = false;\n    var canvas = document.createElement(\"canvas\");\n    var context = canvas.getContext(\"2d\");\n    canvas.style.opacity = 0;\n    canvas.style.position = \"absolute\";\n    canvas.style.zIndex = -1;\n    canvas.style.top = \"-1000em\";\n    canvas.style.left = \"-1000em\";\n    canvas.className = elementClass;\n    (document.body || document.documentElement).appendChild(canvas);\n    this.disableLogs = false;\n    this.frameInterval = 10;\n    this.width = 360;\n    this.height = 240;\n    // use gain node to prevent echo\n    this.useGainNode = true;\n    var self = this;\n    // _____________________________\n    // Cross-Browser-Declarations.js\n    // WebAudio API representer\n    var AudioContext = window.AudioContext;\n    if (typeof AudioContext === \"undefined\") {\n        if (typeof webkitAudioContext !== \"undefined\") {\n            /*global AudioContext:true */ AudioContext = webkitAudioContext;\n        }\n        if (typeof mozAudioContext !== \"undefined\") {\n            /*global AudioContext:true */ AudioContext = mozAudioContext;\n        }\n    }\n    /*jshint -W079 */ var URL = window.URL;\n    if (typeof URL === \"undefined\" && typeof webkitURL !== \"undefined\") {\n        /*global URL:true */ URL = webkitURL;\n    }\n    if (typeof navigator !== \"undefined\" && typeof navigator.getUserMedia === \"undefined\") {\n        if (typeof navigator.webkitGetUserMedia !== \"undefined\") {\n            navigator.getUserMedia = navigator.webkitGetUserMedia;\n        }\n        if (typeof navigator.mozGetUserMedia !== \"undefined\") {\n            navigator.getUserMedia = navigator.mozGetUserMedia;\n        }\n    }\n    var MediaStream = window.MediaStream;\n    if (typeof MediaStream === \"undefined\" && typeof webkitMediaStream !== \"undefined\") {\n        MediaStream = webkitMediaStream;\n    }\n    /*global MediaStream:true */ if (typeof MediaStream !== \"undefined\") {\n        // override \"stop\" method for all browsers\n        if (typeof MediaStream.prototype.stop === \"undefined\") {\n            MediaStream.prototype.stop = function() {\n                this.getTracks().forEach(function(track) {\n                    track.stop();\n                });\n            };\n        }\n    }\n    var Storage = {};\n    if (typeof AudioContext !== \"undefined\") {\n        Storage.AudioContext = AudioContext;\n    } else if (typeof webkitAudioContext !== \"undefined\") {\n        Storage.AudioContext = webkitAudioContext;\n    }\n    function setSrcObject(stream, element) {\n        if (\"srcObject\" in element) {\n            element.srcObject = stream;\n        } else if (\"mozSrcObject\" in element) {\n            element.mozSrcObject = stream;\n        } else {\n            element.srcObject = stream;\n        }\n    }\n    this.startDrawingFrames = function() {\n        drawVideosToCanvas();\n    };\n    function drawVideosToCanvas() {\n        if (isStopDrawingFrames) {\n            return;\n        }\n        var videosLength = videos.length;\n        var fullcanvas = false;\n        var remaining = [];\n        videos.forEach(function(video) {\n            if (!video.stream) {\n                video.stream = {};\n            }\n            if (video.stream.fullcanvas) {\n                fullcanvas = video;\n            } else {\n                // todo: video.stream.active or video.stream.live to fix blank frames issues?\n                remaining.push(video);\n            }\n        });\n        if (fullcanvas) {\n            canvas.width = fullcanvas.stream.width;\n            canvas.height = fullcanvas.stream.height;\n        } else if (remaining.length) {\n            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;\n            var height = 1;\n            if (videosLength === 3 || videosLength === 4) {\n                height = 2;\n            }\n            if (videosLength === 5 || videosLength === 6) {\n                height = 3;\n            }\n            if (videosLength === 7 || videosLength === 8) {\n                height = 4;\n            }\n            if (videosLength === 9 || videosLength === 10) {\n                height = 5;\n            }\n            canvas.height = remaining[0].height * height;\n        } else {\n            canvas.width = self.width || 360;\n            canvas.height = self.height || 240;\n        }\n        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {\n            drawImage(fullcanvas);\n        }\n        remaining.forEach(function(video, idx) {\n            drawImage(video, idx);\n        });\n        setTimeout(drawVideosToCanvas, self.frameInterval);\n    }\n    function drawImage(video, idx) {\n        if (isStopDrawingFrames) {\n            return;\n        }\n        var x = 0;\n        var y = 0;\n        var width = video.width;\n        var height = video.height;\n        if (idx === 1) {\n            x = video.width;\n        }\n        if (idx === 2) {\n            y = video.height;\n        }\n        if (idx === 3) {\n            x = video.width;\n            y = video.height;\n        }\n        if (idx === 4) {\n            y = video.height * 2;\n        }\n        if (idx === 5) {\n            x = video.width;\n            y = video.height * 2;\n        }\n        if (idx === 6) {\n            y = video.height * 3;\n        }\n        if (idx === 7) {\n            x = video.width;\n            y = video.height * 3;\n        }\n        if (typeof video.stream.left !== \"undefined\") {\n            x = video.stream.left;\n        }\n        if (typeof video.stream.top !== \"undefined\") {\n            y = video.stream.top;\n        }\n        if (typeof video.stream.width !== \"undefined\") {\n            width = video.stream.width;\n        }\n        if (typeof video.stream.height !== \"undefined\") {\n            height = video.stream.height;\n        }\n        context.drawImage(video, x, y, width, height);\n        if (typeof video.stream.onRender === \"function\") {\n            video.stream.onRender(context, x, y, width, height, idx);\n        }\n    }\n    function getMixedStream() {\n        isStopDrawingFrames = false;\n        var mixedVideoStream = getMixedVideoStream();\n        var mixedAudioStream = getMixedAudioStream();\n        if (mixedAudioStream) {\n            mixedAudioStream.getTracks().filter(function(t) {\n                return t.kind === \"audio\";\n            }).forEach(function(track) {\n                mixedVideoStream.addTrack(track);\n            });\n        }\n        var fullcanvas;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (stream.fullcanvas) {\n                fullcanvas = true;\n            }\n        });\n        // mixedVideoStream.prototype.appendStreams = appendStreams;\n        // mixedVideoStream.prototype.resetVideoStreams = resetVideoStreams;\n        // mixedVideoStream.prototype.clearRecordedData = clearRecordedData;\n        return mixedVideoStream;\n    }\n    function getMixedVideoStream() {\n        resetVideoStreams();\n        var capturedStream;\n        if (\"captureStream\" in canvas) {\n            capturedStream = canvas.captureStream();\n        } else if (\"mozCaptureStream\" in canvas) {\n            capturedStream = canvas.mozCaptureStream();\n        } else if (!self.disableLogs) {\n            console.error(\"Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features\");\n        }\n        var videoStream = new MediaStream();\n        capturedStream.getTracks().filter(function(t) {\n            return t.kind === \"video\";\n        }).forEach(function(track) {\n            videoStream.addTrack(track);\n        });\n        canvas.stream = videoStream;\n        return videoStream;\n    }\n    function getMixedAudioStream() {\n        // via: @pehrsons\n        if (!Storage.AudioContextConstructor) {\n            Storage.AudioContextConstructor = new Storage.AudioContext();\n        }\n        self.audioContext = Storage.AudioContextConstructor;\n        self.audioSources = [];\n        if (self.useGainNode === true) {\n            self.gainNode = self.audioContext.createGain();\n            self.gainNode.connect(self.audioContext.destination);\n            self.gainNode.gain.value = 0; // don't hear self\n        }\n        var audioTracksLength = 0;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                return t.kind === \"audio\";\n            }).length) {\n                return;\n            }\n            audioTracksLength++;\n            var audioSource = self.audioContext.createMediaStreamSource(stream);\n            if (self.useGainNode === true) {\n                audioSource.connect(self.gainNode);\n            }\n            self.audioSources.push(audioSource);\n        });\n        if (!audioTracksLength) {\n            // because \"self.audioContext\" is not initialized\n            // that's why we've to ignore rest of the code\n            return;\n        }\n        self.audioDestination = self.audioContext.createMediaStreamDestination();\n        self.audioSources.forEach(function(audioSource) {\n            audioSource.connect(self.audioDestination);\n        });\n        return self.audioDestination.stream;\n    }\n    function getVideo(stream) {\n        var video = document.createElement(\"video\");\n        setSrcObject(stream, video);\n        video.className = elementClass;\n        video.muted = true;\n        video.volume = 0;\n        video.width = stream.width || self.width || 360;\n        video.height = stream.height || self.height || 240;\n        video.play();\n        return video;\n    }\n    this.appendStreams = function(streams) {\n        if (!streams) {\n            throw \"First parameter is required.\";\n        }\n        if (!(streams instanceof Array)) {\n            streams = [\n                streams\n            ];\n        }\n        streams.forEach(function(stream) {\n            var newStream = new MediaStream();\n            if (stream.getTracks().filter(function(t) {\n                return t.kind === \"video\";\n            }).length) {\n                var video = getVideo(stream);\n                video.stream = stream;\n                videos.push(video);\n                newStream.addTrack(stream.getTracks().filter(function(t) {\n                    return t.kind === \"video\";\n                })[0]);\n            }\n            if (stream.getTracks().filter(function(t) {\n                return t.kind === \"audio\";\n            }).length) {\n                var audioSource = self.audioContext.createMediaStreamSource(stream);\n                self.audioDestination = self.audioContext.createMediaStreamDestination();\n                audioSource.connect(self.audioDestination);\n                newStream.addTrack(self.audioDestination.stream.getTracks().filter(function(t) {\n                    return t.kind === \"audio\";\n                })[0]);\n            }\n            arrayOfMediaStreams.push(newStream);\n        });\n    };\n    this.releaseStreams = function() {\n        videos = [];\n        isStopDrawingFrames = true;\n        if (self.gainNode) {\n            self.gainNode.disconnect();\n            self.gainNode = null;\n        }\n        if (self.audioSources.length) {\n            self.audioSources.forEach(function(source) {\n                source.disconnect();\n            });\n            self.audioSources = [];\n        }\n        if (self.audioDestination) {\n            self.audioDestination.disconnect();\n            self.audioDestination = null;\n        }\n        if (self.audioContext) {\n            self.audioContext.close();\n        }\n        self.audioContext = null;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        if (canvas.stream) {\n            canvas.stream.stop();\n            canvas.stream = null;\n        }\n    };\n    this.resetVideoStreams = function(streams) {\n        if (streams && !(streams instanceof Array)) {\n            streams = [\n                streams\n            ];\n        }\n        resetVideoStreams(streams);\n    };\n    function resetVideoStreams(streams) {\n        videos = [];\n        streams = streams || arrayOfMediaStreams;\n        // via: @adrian-ber\n        streams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                return t.kind === \"video\";\n            }).length) {\n                return;\n            }\n            var video = getVideo(stream);\n            video.stream = stream;\n            videos.push(video);\n        });\n    }\n    // for debugging\n    this.name = \"MultiStreamsMixer\";\n    this.toString = function() {\n        return this.name;\n    };\n    this.getMixedStream = getMixedStream;\n}\nif (typeof RecordRTC === \"undefined\") {\n    if (true /* && !!module.exports*/ ) {\n        module.exports = MultiStreamsMixer;\n    }\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return MultiStreamsMixer;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}\n// ______________________\n// MultiStreamRecorder.js\n/*\r\n * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.\r\n */ /**\r\n * MultiStreamRecorder can record multiple videos in single container.\r\n * @summary Multi-videos recorder.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef MultiStreamRecorder\r\n * @class\r\n * @example\r\n * var options = {\r\n *     mimeType: 'video/webm'\r\n * }\r\n * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n *\r\n *     // or\r\n *     var blob = recorder.blob;\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStreams} mediaStreams - Array of MediaStreams.\r\n * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: \"video/webm\"}\r\n */ function MultiStreamRecorder(arrayOfMediaStreams, options) {\n    arrayOfMediaStreams = arrayOfMediaStreams || [];\n    var self = this;\n    var mixer;\n    var mediaRecorder;\n    options = options || {\n        elementClass: \"multi-streams-mixer\",\n        mimeType: \"video/webm\",\n        video: {\n            width: 360,\n            height: 240\n        }\n    };\n    if (!options.frameInterval) {\n        options.frameInterval = 10;\n    }\n    if (!options.video) {\n        options.video = {};\n    }\n    if (!options.video.width) {\n        options.video.width = 360;\n    }\n    if (!options.video.height) {\n        options.video.height = 240;\n    }\n    /**\r\n     * This method records all MediaStreams.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        // github/muaz-khan/MultiStreamsMixer\n        mixer = new MultiStreamsMixer(arrayOfMediaStreams, options.elementClass || \"multi-streams-mixer\");\n        if (getAllVideoTracks().length) {\n            mixer.frameInterval = options.frameInterval || 10;\n            mixer.width = options.video.width || 360;\n            mixer.height = options.video.height || 240;\n            mixer.startDrawingFrames();\n        }\n        if (options.previewStream && typeof options.previewStream === \"function\") {\n            options.previewStream(mixer.getMixedStream());\n        }\n        // record using MediaRecorder API\n        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);\n        mediaRecorder.record();\n    };\n    function getAllVideoTracks() {\n        var tracks = [];\n        arrayOfMediaStreams.forEach(function(stream) {\n            getTracks(stream, \"video\").forEach(function(track) {\n                tracks.push(track);\n            });\n        });\n        return tracks;\n    }\n    /**\r\n     * This method stops recording MediaStream.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        if (!mediaRecorder) {\n            return;\n        }\n        mediaRecorder.stop(function(blob) {\n            self.blob = blob;\n            callback(blob);\n            self.clearRecordedData();\n        });\n    };\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        if (mediaRecorder) {\n            mediaRecorder.pause();\n        }\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        if (mediaRecorder) {\n            mediaRecorder.resume();\n        }\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder = null;\n        }\n        if (mixer) {\n            mixer.releaseStreams();\n            mixer = null;\n        }\n    };\n    /**\r\n     * Add extra media-streams to existing recordings.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\r\n     * @example\r\n     * recorder.addStreams([newAudioStream, newVideoStream]);\r\n     */ this.addStreams = function(streams) {\n        if (!streams) {\n            throw \"First parameter is required.\";\n        }\n        if (!(streams instanceof Array)) {\n            streams = [\n                streams\n            ];\n        }\n        arrayOfMediaStreams.concat(streams);\n        if (!mediaRecorder || !mixer) {\n            return;\n        }\n        mixer.appendStreams(streams);\n        if (options.previewStream && typeof options.previewStream === \"function\") {\n            options.previewStream(mixer.getMixedStream());\n        }\n    };\n    /**\r\n     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\r\n     * @example\r\n     * recorder.resetVideoStreams([newVideo1, newVideo2]);\r\n     */ this.resetVideoStreams = function(streams) {\n        if (!mixer) {\n            return;\n        }\n        if (streams && !(streams instanceof Array)) {\n            streams = [\n                streams\n            ];\n        }\n        mixer.resetVideoStreams(streams);\n    };\n    /**\r\n     * Returns MultiStreamsMixer\r\n     * @method\r\n     * @memberof MultiStreamRecorder\r\n     * @example\r\n     * let mixer = recorder.getMixer();\r\n     * mixer.appendStreams([newStream]);\r\n     */ this.getMixer = function() {\n        return mixer;\n    };\n    // for debugging\n    this.name = \"MultiStreamRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;\n}\n// _____________________\n// RecordRTC.promises.js\n/**\r\n * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}\r\n * @summary Promises for {@link RecordRTC}\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef RecordRTCPromisesHandler\r\n * @class\r\n * @example\r\n * var recorder = new RecordRTCPromisesHandler(mediaStream, options);\r\n * recorder.startRecording()\r\n *         .then(successCB)\r\n *         .catch(errorCB);\r\n * // Note: You can access all RecordRTC API using \"recorder.recordRTC\" e.g. \r\n * recorder.recordRTC.onStateChanged = function(state) {};\r\n * recorder.recordRTC.setRecordingDuration(5000);\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\r\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\r\n * @throws Will throw an error if \"new\" keyword is not used to initiate \"RecordRTCPromisesHandler\". Also throws error if first argument \"MediaStream\" is missing.\r\n * @requires {@link RecordRTC}\r\n */ function RecordRTCPromisesHandler(mediaStream, options) {\n    if (!this) {\n        throw 'Use \"new RecordRTCPromisesHandler()\"';\n    }\n    if (typeof mediaStream === \"undefined\") {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n    var self = this;\n    /**\r\n     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let internal = recorder.recordRTC.getInternalRecorder();\r\n     * alert(internal instanceof MediaStreamRecorder);\r\n     * recorder.recordRTC.onStateChanged = function(state) {};\r\n     */ self.recordRTC = new RecordRTC(mediaStream, options);\n    /**\r\n     * This method records MediaStream.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.startRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */ this.startRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.startRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method stops the recording.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     var blob = recorder.getBlob();\r\n     * }).catch(errorCB);\r\n     */ this.stopRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.stopRecording(function(url) {\n                    self.blob = self.recordRTC.getBlob();\n                    if (!self.blob || !self.blob.size) {\n                        reject(\"Empty blob.\", self.blob);\n                        return;\n                    }\n                    resolve(url);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.pauseRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */ this.pauseRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.pauseRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method resumes the recording.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.resumeRecording()\r\n     *         .then(successCB)\r\n     *         .catch(errorCB);\r\n     */ this.resumeRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.resumeRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method returns data-url for the recorded blob.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     recorder.getDataURL().then(function(dataURL) {\r\n     *         window.open(dataURL);\r\n     *     }).catch(errorCB);;\r\n     * }).catch(errorCB);\r\n     */ this.getDataURL = function(callback) {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.getDataURL(function(dataURL) {\n                    resolve(dataURL);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method returns the recorded blob.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.stopRecording().then(function() {\r\n     *     recorder.getBlob().then(function(blob) {})\r\n     * }).catch(errorCB);\r\n     */ this.getBlob = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getBlob());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method returns the internal recording object.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let internalRecorder = await recorder.getInternalRecorder();\r\n     * if(internalRecorder instanceof MultiStreamRecorder) {\r\n     *     internalRecorder.addStreams([newAudioStream]);\r\n     *     internalRecorder.resetVideoStreams([screenStream]);\r\n     * }\r\n     * @returns {Object} \r\n     */ this.getInternalRecorder = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getInternalRecorder());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * This method resets the recorder. So that you can reuse single recorder instance many times.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * await recorder.reset();\r\n     * recorder.startRecording(); // record again\r\n     */ this.reset = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.reset());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * Destroy RecordRTC instance. Clear all recorders and objects.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * recorder.destroy().then(successCB).catch(errorCB);\r\n     */ this.destroy = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.destroy());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * Get recorder's readonly state.\r\n     * @method\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * let state = await recorder.getState();\r\n     * // or\r\n     * recorder.getState().then(state => { console.log(state); })\r\n     * @returns {String} Returns recording state.\r\n     */ this.getState = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getState());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\r\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @example\r\n     * await recorder.stopRecording();\r\n     * let blob = recorder.getBlob(); // or \"recorder.recordRTC.blob\"\r\n     * invokeSaveAsDialog(blob);\r\n     */ this.blob = null;\n    /**\r\n     * RecordRTC version number\r\n     * @property {String} version - Release version number.\r\n     * @memberof RecordRTCPromisesHandler\r\n     * @static\r\n     * @readonly\r\n     * @example\r\n     * alert(recorder.version);\r\n     */ this.version = \"5.6.2\";\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;\n}\n// ______________________\n// WebAssemblyRecorder.js\n/**\r\n * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.\r\n * @summary Video recording feature in Chrome, Firefox and maybe Edge.\r\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\r\n * @author {@link https://MuazKhan.com|Muaz Khan}\r\n * @typedef WebAssemblyRecorder\r\n * @class\r\n * @example\r\n * var recorder = new WebAssemblyRecorder(mediaStream);\r\n * recorder.record();\r\n * recorder.stop(function(blob) {\r\n *     video.src = URL.createObjectURL(blob);\r\n * });\r\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\r\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\r\n * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}\r\n */ function WebAssemblyRecorder(stream, config) {\n    // based on: github.com/GoogleChromeLabs/webm-wasm\n    if (typeof ReadableStream === \"undefined\" || typeof WritableStream === \"undefined\") {\n        // because it fixes readable/writable streams issues\n        console.error(\"Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js\");\n    }\n    config = config || {};\n    config.width = config.width || 640;\n    config.height = config.height || 480;\n    config.frameRate = config.frameRate || 30;\n    config.bitrate = config.bitrate || 1200;\n    config.realtime = config.realtime || true;\n    function createBufferURL(buffer, type) {\n        return URL.createObjectURL(new Blob([\n            buffer\n        ], {\n            type: type || \"\"\n        }));\n    }\n    var finished;\n    function cameraStream() {\n        return new ReadableStream({\n            start: function(controller) {\n                var cvs = document.createElement(\"canvas\");\n                var video = document.createElement(\"video\");\n                var first = true;\n                video.srcObject = stream;\n                video.muted = true;\n                video.height = config.height;\n                video.width = config.width;\n                video.volume = 0;\n                video.onplaying = function() {\n                    cvs.width = config.width;\n                    cvs.height = config.height;\n                    var ctx = cvs.getContext(\"2d\");\n                    var frameTimeout = 1000 / config.frameRate;\n                    var cameraTimer = setInterval(function f() {\n                        if (finished) {\n                            clearInterval(cameraTimer);\n                            controller.close();\n                        }\n                        if (first) {\n                            first = false;\n                            if (config.onVideoProcessStarted) {\n                                config.onVideoProcessStarted();\n                            }\n                        }\n                        ctx.drawImage(video, 0, 0);\n                        if (controller._controlledReadableStream.state !== \"closed\") {\n                            try {\n                                controller.enqueue(ctx.getImageData(0, 0, config.width, config.height));\n                            } catch (e) {}\n                        }\n                    }, frameTimeout);\n                };\n                video.play();\n            }\n        });\n    }\n    var worker;\n    function startRecording(stream, buffer) {\n        if (!config.workerPath && !buffer) {\n            finished = false;\n            // is it safe to use @latest ?\n            fetch(\"https://unpkg.com/webm-wasm@latest/dist/webm-worker.js\").then(function(r) {\n                r.arrayBuffer().then(function(buffer) {\n                    startRecording(stream, buffer);\n                });\n            });\n            return;\n        }\n        if (!config.workerPath && buffer instanceof ArrayBuffer) {\n            var blob = new Blob([\n                buffer\n            ], {\n                type: \"text/javascript\"\n            });\n            config.workerPath = URL.createObjectURL(blob);\n        }\n        if (!config.workerPath) {\n            console.error(\"workerPath parameter is missing.\");\n        }\n        worker = new Worker(config.workerPath);\n        worker.postMessage(config.webAssemblyPath || \"https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm\");\n        worker.addEventListener(\"message\", function(event) {\n            if (event.data === \"READY\") {\n                worker.postMessage({\n                    width: config.width,\n                    height: config.height,\n                    bitrate: config.bitrate || 1200,\n                    timebaseDen: config.frameRate || 30,\n                    realtime: config.realtime\n                });\n                cameraStream().pipeTo(new WritableStream({\n                    write: function(image) {\n                        if (finished) {\n                            console.error(\"Got image, but recorder is finished!\");\n                            return;\n                        }\n                        worker.postMessage(image.data.buffer, [\n                            image.data.buffer\n                        ]);\n                    }\n                }));\n            } else if (!!event.data) {\n                if (!isPaused) {\n                    arrayOfBuffers.push(event.data);\n                }\n            }\n        });\n    }\n    /**\r\n     * This method records video.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.record();\r\n     */ this.record = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n        startRecording(stream);\n        if (typeof config.initCallback === \"function\") {\n            config.initCallback();\n        }\n    };\n    var isPaused;\n    /**\r\n     * This method pauses the recording process.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.pause();\r\n     */ this.pause = function() {\n        isPaused = true;\n    };\n    /**\r\n     * This method resumes the recording process.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.resume();\r\n     */ this.resume = function() {\n        isPaused = false;\n    };\n    function terminate(callback) {\n        if (!worker) {\n            if (callback) {\n                callback();\n            }\n            return;\n        }\n        // Wait for null event data to indicate that the encoding is complete\n        worker.addEventListener(\"message\", function(event) {\n            if (event.data === null) {\n                worker.terminate();\n                worker = null;\n                if (callback) {\n                    callback();\n                }\n            }\n        });\n        worker.postMessage(null);\n    }\n    var arrayOfBuffers = [];\n    /**\r\n     * This method stops recording video.\r\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.stop(function(blob) {\r\n     *     video.src = URL.createObjectURL(blob);\r\n     * });\r\n     */ this.stop = function(callback) {\n        finished = true;\n        var recorder = this;\n        terminate(function() {\n            recorder.blob = new Blob(arrayOfBuffers, {\n                type: \"video/webm\"\n            });\n            callback(recorder.blob);\n        });\n    };\n    // for debugging\n    this.name = \"WebAssemblyRecorder\";\n    this.toString = function() {\n        return this.name;\n    };\n    /**\r\n     * This method resets currently recorded data.\r\n     * @method\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.clearRecordedData();\r\n     */ this.clearRecordedData = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n    // todo: if recording-ON then STOP it first\n    };\n    /**\r\n     * @property {Blob} blob - The recorded blob object.\r\n     * @memberof WebAssemblyRecorder\r\n     * @example\r\n     * recorder.stop(function(){\r\n     *     var blob = recorder.blob;\r\n     * });\r\n     */ this.blob = null;\n}\nif (typeof RecordRTC !== \"undefined\") {\n    RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVjb3JkcnRjL1JlY29yZFJUQy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLCtDQUErQztBQUUvQyxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBRW5CLHVEQUF1RDtBQUV2RCxxREFBcUQ7QUFDckQsbUNBQW1DO0FBQ25DLG9EQUFvRDtBQUNwRCxxREFBcUQ7QUFFckQsZUFBZTtBQUNmLGVBQWU7QUFFZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFRCxTQUFTQSxVQUFVQyxXQUFXLEVBQUVDLE1BQU07SUFDbEMsSUFBSSxDQUFDRCxhQUFhO1FBQ2QsTUFBTTtJQUNWO0lBRUFDLFNBQVNBLFVBQVU7UUFDZkMsTUFBTTtJQUNWO0lBRUFELFNBQVMsSUFBSUUsdUJBQXVCSCxhQUFhQztJQUVqRCx5Q0FBeUM7SUFDekMsSUFBSUcsT0FBTyxJQUFJO0lBRWYsU0FBU0MsZUFBZUMsT0FBTztRQUMzQixJQUFJLENBQUNMLE9BQU9NLFdBQVcsRUFBRTtZQUNyQkMsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QkwsS0FBS00sT0FBTztRQUNuRDtRQUVBLElBQUksQ0FBQyxDQUFDSixTQUFTO1lBQ1gseURBQXlEO1lBQ3pELDJGQUEyRjtZQUMzRkwsU0FBUyxJQUFJRSx1QkFBdUJILGFBQWFNO1FBQ3JEO1FBRUEsSUFBSSxDQUFDTCxPQUFPTSxXQUFXLEVBQUU7WUFDckJDLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJSLE9BQU9DLElBQUksR0FBRztRQUNyRDtRQUVBLElBQUlTLGVBQWU7WUFDZkEsY0FBY0MsaUJBQWlCO1lBQy9CRCxjQUFjRSxNQUFNO1lBRXBCQyxTQUFTO1lBRVQsSUFBSVYsS0FBS1csaUJBQWlCLEVBQUU7Z0JBQ3hCQztZQUNKO1lBQ0EsT0FBT1o7UUFDWDtRQUVBYSxhQUFhO1lBQ1QsSUFBSWIsS0FBS1csaUJBQWlCLEVBQUU7Z0JBQ3hCQztZQUNKO1FBQ0o7UUFFQSxPQUFPWjtJQUNYO0lBRUEsU0FBU2EsYUFBYUMsWUFBWTtR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UztnQkFFVCxJQUFJcEQsVUFBVTtvQkFDVkE7Z0JBQ0o7WUFDSjtRQUNKO1FBRUFvRCxPQUFPcEIsV0FBVyxDQUFDO0lBQ3ZCO0lBRUEsSUFBSTZtQixpQkFBaUIsRUFBRTtJQUV2Qjs7Ozs7Ozs7O0tBU0MsR0FDRCxJQUFJLENBQUN2b0IsSUFBSSxHQUFHLFNBQVNOLFFBQVE7UUFDekJ3bkIsV0FBVztRQUVYLElBQUluZ0IsV0FBVyxJQUFJO1FBRW5CcVAsVUFBVTtZQUNOclAsU0FBU3ZHLElBQUksR0FBRyxJQUFJb0MsS0FBSzJsQixnQkFBZ0I7Z0JBQ3JDbnFCLE1BQU07WUFDVjtZQUVBc0IsU0FBU3FILFNBQVN2RyxJQUFJO1FBQzFCO0lBQ0o7SUFFQSxnQkFBZ0I7SUFDaEIsSUFBSSxDQUFDaEIsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDcUQsUUFBUSxHQUFHO1FBQ1osT0FBTyxJQUFJLENBQUNyRCxJQUFJO0lBQ3BCO0lBRUE7Ozs7OztLQU1DLEdBQ0QsSUFBSSxDQUFDVixpQkFBaUIsR0FBRztRQUNyQnlwQixpQkFBaUIsRUFBRTtRQUNuQmxWLFdBQVc7UUFDWCxJQUFJLENBQUM3UyxJQUFJLEdBQUc7SUFFWiwyQ0FBMkM7SUFDL0M7SUFFQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSSxDQUFDQSxJQUFJLEdBQUc7QUFDaEI7QUFFQSxJQUFJLE9BQU92QyxjQUFjLGFBQWE7SUFDbENBLFVBQVVvSSxtQkFBbUIsR0FBR0E7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtMTMtcmVwbGl0Ly4vbm9kZV9tb2R1bGVzL3JlY29yZHJ0Yy9SZWNvcmRSVEMuanM/OGFlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBMYXN0IHRpbWUgdXBkYXRlZDogMjAyMS0wMy0wOSAzOjIwOjIyIEFNIFVUQ1xyXG5cclxuLy8gX19fX19fX19fX19fX19fX1xyXG4vLyBSZWNvcmRSVEMgdjUuNi4yXHJcblxyXG4vLyBPcGVuLVNvdXJjZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBNdWF6IEtoYW4gICAgIC0gd3d3Lk11YXpLaGFuLmNvbVxyXG4vLyBNSVQgTGljZW5zZSAgIC0gd3d3LldlYlJUQy1FeHBlcmltZW50LmNvbS9saWNlbmNlXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4vLyBfX19fX19fX19fX19cclxuLy8gUmVjb3JkUlRDLmpzXHJcblxyXG4vKipcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDfFJlY29yZFJUQ30gaXMgYSBXZWJSVEMgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhdWRpby92aWRlbyBhcyB3ZWxsIGFzIHNjcmVlbiBhY3Rpdml0eSByZWNvcmRpbmcuIEl0IHN1cHBvcnRzIENocm9tZSwgRmlyZWZveCwgT3BlcmEsIEFuZHJvaWQsIGFuZCBNaWNyb3NvZnQgRWRnZS4gUGxhdGZvcm1zOiBMaW51eCwgTWFjIGFuZCBXaW5kb3dzLiBcclxuICogQHN1bW1hcnkgUmVjb3JkIGF1ZGlvLCB2aWRlbyBvciBzY3JlZW4gaW5zaWRlIHRoZSBicm93c2VyLlxyXG4gKiBAbGljZW5zZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVR9XHJcbiAqIEBhdXRob3Ige0BsaW5rIGh0dHBzOi8vTXVhektoYW4uY29tfE11YXogS2hhbn1cclxuICogQHR5cGVkZWYgUmVjb3JkUlRDXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcmVjb3JkZXIgPSBSZWNvcmRSVEMobWVkaWFTdHJlYW0gb3IgW2FycmF5T2ZNZWRpYVN0cmVhbV0sIHtcclxuICogICAgIHR5cGU6ICd2aWRlbycsIC8vIGF1ZGlvIG9yIHZpZGVvIG9yIGdpZiBvciBjYW52YXNcclxuICogICAgIHJlY29yZGVyVHlwZTogTWVkaWFTdHJlYW1SZWNvcmRlciB8fCBDYW52YXNSZWNvcmRlciB8fCBTdGVyZW9BdWRpb1JlY29yZGVyIHx8IEV0Y1xyXG4gKiB9KTtcclxuICogcmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICogQHNlZSBGb3IgZnVydGhlciBpbmZvcm1hdGlvbjpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbSAtIFNpbmdsZSBtZWRpYS1zdHJlYW0gb2JqZWN0LCBhcnJheSBvZiBtZWRpYS1zdHJlYW1zLCBodG1sLWNhbnZhcy1lbGVtZW50LCBldGMuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSB7dHlwZTpcInZpZGVvXCIsIHJlY29yZGVyVHlwZTogTWVkaWFTdHJlYW1SZWNvcmRlciwgZGlzYWJsZUxvZ3M6IHRydWUsIG51bWJlck9mQXVkaW9DaGFubmVsczogMSwgYnVmZmVyU2l6ZTogMCwgc2FtcGxlUmF0ZTogMCwgZGVzaXJlZFNhbXBSYXRlOiAxNjAwMCwgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsIGV0Yy59XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUmVjb3JkUlRDKG1lZGlhU3RyZWFtLCBjb25maWcpIHtcclxuICAgIGlmICghbWVkaWFTdHJlYW0pIHtcclxuICAgICAgICB0aHJvdyAnRmlyc3QgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLic7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHtcclxuICAgICAgICB0eXBlOiAndmlkZW8nXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbmZpZyA9IG5ldyBSZWNvcmRSVENDb25maWd1cmF0aW9uKG1lZGlhU3RyZWFtLCBjb25maWcpO1xyXG5cclxuICAgIC8vIGEgcmVmZXJlbmNlIHRvIHVzZXIncyByZWNvcmRSVEMgb2JqZWN0XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRSZWNvcmRpbmcoY29uZmlnMikge1xyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNvcmRSVEMgdmVyc2lvbjogJywgc2VsZi52ZXJzaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghIWNvbmZpZzIpIHtcclxuICAgICAgICAgICAgLy8gYWxsb3cgdXNlcnMgdG8gc2V0IG9wdGlvbnMgdXNpbmcgc3RhcnRSZWNvcmRpbmcgbWV0aG9kXHJcbiAgICAgICAgICAgIC8vIGNvbmZpZzIgaXMgc2ltaWxhciB0byBtYWluIFwiY29uZmlnXCIgb2JqZWN0IChzZWNvbmQgcGFyYW1ldGVyIG92ZXIgUmVjb3JkUlRDIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAgICBjb25maWcgPSBuZXcgUmVjb3JkUlRDQ29uZmlndXJhdGlvbihtZWRpYVN0cmVhbSwgY29uZmlnMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnRlZCByZWNvcmRpbmcgJyArIGNvbmZpZy50eXBlICsgJyBzdHJlYW0uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWVkaWFSZWNvcmRlcikge1xyXG4gICAgICAgICAgICBtZWRpYVJlY29yZGVyLmNsZWFyUmVjb3JkZWREYXRhKCk7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIucmVjb3JkKCk7XHJcblxyXG4gICAgICAgICAgICBzZXRTdGF0ZSgncmVjb3JkaW5nJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5yZWNvcmRpbmdEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlUmVjb3JkaW5nRHVyYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluaXRSZWNvcmRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYucmVjb3JkaW5nRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVJlY29yZGluZ0R1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdFJlY29yZGVyKGluaXRDYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChpbml0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY29uZmlnLmluaXRDYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdENhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICBpbml0Q2FsbGJhY2sgPSBjb25maWcuaW5pdENhbGxiYWNrID0gbnVsbDsgLy8gcmVjb3JkZXIuaW5pdFJlY29yZGVyIHNob3VsZCBiZSBjYWxsLWJhY2tlZCBvbmNlLlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIFJlY29yZGVyID0gbmV3IEdldFJlY29yZGVyVHlwZShtZWRpYVN0cmVhbSwgY29uZmlnKTtcclxuXHJcbiAgICAgICAgbWVkaWFSZWNvcmRlciA9IG5ldyBSZWNvcmRlcihtZWRpYVN0cmVhbSwgY29uZmlnKTtcclxuICAgICAgICBtZWRpYVJlY29yZGVyLnJlY29yZCgpO1xyXG5cclxuICAgICAgICBzZXRTdGF0ZSgncmVjb3JkaW5nJyk7XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXplZCByZWNvcmRlclR5cGU6JywgbWVkaWFSZWNvcmRlci5jb25zdHJ1Y3Rvci5uYW1lLCAnZm9yIG91dHB1dC10eXBlOicsIGNvbmZpZy50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RvcFJlY29yZGluZyhjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdMb2coKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVzdW1lUmVjb3JkaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc3RvcFJlY29yZGluZyhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gJ3JlY29yZGluZycgJiYgIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlY29yZGluZyBzdGF0ZSBzaG91bGQgYmU6IFwicmVjb3JkaW5nXCIsIGhvd2V2ZXIgY3VycmVudCBzdGF0ZSBpczogJywgc2VsZi5zdGF0ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU3RvcHBlZCByZWNvcmRpbmcgJyArIGNvbmZpZy50eXBlICsgJyBzdHJlYW0uJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnR5cGUgIT09ICdnaWYnKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuc3RvcChfY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICBfY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFN0YXRlKCdzdG9wcGVkJyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhfX2Jsb2IpIHtcclxuICAgICAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsICcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZWRpYVJlY29yZGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZWRpYVJlY29yZGVyW2tleV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZltrZXldID0gbWVkaWFSZWNvcmRlcltrZXldO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9iID0gbWVkaWFSZWNvcmRlci5ibG9iO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFibG9iKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX19ibG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFSZWNvcmRlci5ibG9iID0gYmxvYiA9IF9fYmxvYjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1JlY29yZGluZyBmYWlsZWQuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGJsb2IgJiYgIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmxvYi50eXBlLCAnLT4nLCBieXRlc1RvU2l6ZShibG9iLnNpemUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXJsO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjay5jYWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzZWxmLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1cmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5hdXRvV3JpdGVUb0Rpc2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2V0RGF0YVVSTChmdW5jdGlvbihkYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJbY29uZmlnLnR5cGUgKyAnQmxvYiddID0gZGF0YVVSTDtcclxuICAgICAgICAgICAgICAgIERpc2tTdG9yYWdlLlN0b3JlKHBhcmFtZXRlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXVzZVJlY29yZGluZygpIHtcclxuICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgd2FybmluZ0xvZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gJ3JlY29yZGluZycpIHtcclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHBhdXNlIHRoZSByZWNvcmRpbmcuIFJlY29yZGluZyBzdGF0ZTogJywgc2VsZi5zdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0U3RhdGUoJ3BhdXNlZCcpO1xyXG5cclxuICAgICAgICBtZWRpYVJlY29yZGVyLnBhdXNlKCk7XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXVzZWQgcmVjb3JkaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXN1bWVSZWNvcmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdMb2coKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYuc3RhdGUgIT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byByZXN1bWUgdGhlIHJlY29yZGluZy4gUmVjb3JkaW5nIHN0YXRlOiAnLCBzZWxmLnN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRTdGF0ZSgncmVjb3JkaW5nJyk7XHJcblxyXG4gICAgICAgIC8vIG5vdCBhbGwgbGlicyBoYXZlIHRoaXMgbWV0aG9kIHlldFxyXG4gICAgICAgIG1lZGlhUmVjb3JkZXIucmVzdW1lKCk7XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXN1bWVkIHJlY29yZGluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEZpbGUoX2Jsb2IpIHtcclxuICAgICAgICBwb3N0TWVzc2FnZShuZXcgRmlsZVJlYWRlclN5bmMoKS5yZWFkQXNEYXRhVVJMKF9ibG9iKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YVVSTChjYWxsYmFjaywgX21lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdQYXNzIGEgY2FsbGJhY2sgZnVuY3Rpb24gb3ZlciBnZXREYXRhVVJMLic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYmxvYiA9IF9tZWRpYVJlY29yZGVyID8gX21lZGlhUmVjb3JkZXIuYmxvYiA6IChtZWRpYVJlY29yZGVyIHx8IHt9KS5ibG9iO1xyXG5cclxuICAgICAgICBpZiAoIWJsb2IpIHtcclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQmxvYiBlbmNvZGVyIGRpZCBub3QgZmluaXNoIGl0cyBqb2IgeWV0LicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZ2V0RGF0YVVSTChjYWxsYmFjaywgX21lZGlhUmVjb3JkZXIpO1xyXG4gICAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmICFuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWJXb3JrZXIgPSBwcm9jZXNzSW5XZWJXb3JrZXIocmVhZEZpbGUpO1xyXG5cclxuICAgICAgICAgICAgd2ViV29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHdlYldvcmtlci5wb3N0TWVzc2FnZShibG9iKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XHJcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzSW5XZWJXb3JrZXIoX2Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW19mdW5jdGlvbi50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICd0aGlzLm9ubWVzc2FnZSA9ICBmdW5jdGlvbiAoZWVlKSB7JyArIF9mdW5jdGlvbi5uYW1lICsgJyhlZWUuZGF0YSk7fSdcclxuICAgICAgICAgICAgICAgIF0sIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iKTtcclxuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZWNvcmRpbmdEdXJhdGlvbihjb3VudGVyKSB7XHJcbiAgICAgICAgY291bnRlciA9IGNvdW50ZXIgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVSZWNvcmRpbmdEdXJhdGlvbihjb3VudGVyKTtcclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnc3RvcHBlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvdW50ZXIgPj0gc2VsZi5yZWNvcmRpbmdEdXJhdGlvbikge1xyXG4gICAgICAgICAgICBzdG9wUmVjb3JkaW5nKHNlbGYub25SZWNvcmRpbmdTdG9wcGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY291bnRlciArPSAxMDAwOyAvLyAxLXNlY29uZFxyXG5cclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBoYW5kbGVSZWNvcmRpbmdEdXJhdGlvbihjb3VudGVyKTtcclxuICAgICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGlmICghc2VsZikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLnN0YXRlID0gc3RhdGU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vblN0YXRlQ2hhbmdlZC5jYWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHNlbGYub25TdGF0ZUNoYW5nZWQuY2FsbChzZWxmLCBzdGF0ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5vblN0YXRlQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBXQVJOSU5HID0gJ0l0IHNlZW1zIHRoYXQgcmVjb3JkZXIgaXMgZGVzdHJveWVkIG9yIFwic3RhcnRSZWNvcmRpbmdcIiBpcyBub3QgaW52b2tlZCBmb3IgJyArIGNvbmZpZy50eXBlICsgJyByZWNvcmRlci4nO1xyXG5cclxuICAgIGZ1bmN0aW9uIHdhcm5pbmdMb2coKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlTG9ncyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oV0FSTklORyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1lZGlhUmVjb3JkZXI7XHJcblxyXG4gICAgdmFyIHJldHVybk9iamVjdCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzdGFydHMgdGhlIHJlY29yZGluZy5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogdmFyIHJlY29yZGVyID0gUmVjb3JkUlRDKG1lZGlhU3RyZWFtLCB7XHJcbiAgICAgICAgICogICAgIHR5cGU6ICd2aWRlbydcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKiByZWNvcmRlci5zdGFydFJlY29yZGluZygpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXJ0UmVjb3JkaW5nOiBzdGFydFJlY29yZGluZyxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc3RvcHMgdGhlIHJlY29yZGluZy4gSXQgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gZ2V0IFwiYmxvYlwiIG9yIFwiVVJJXCIgaW5zaWRlIHRoZSBjYWxsYmFjayB0byBtYWtlIHN1cmUgYWxsIHJlY29yZGVycyBmaW5pc2hlZCB0aGVpciBqb2IuXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBnZXQgdGhlIHJlY29yZGVkIGJsb2IuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICAgIC8vIHVzZSBlaXRoZXIgXCJ0aGlzXCIgb3IgXCJyZWNvcmRlclwiIG9iamVjdDsgYm90aCBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgICogICAgIHZpZGVvLnNyYyA9IHRoaXMudG9VUkwoKTtcclxuICAgICAgICAgKiAgICAgdmFyIGJsb2IgPSB0aGlzLmdldEJsb2IoKTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdG9wUmVjb3JkaW5nOiBzdG9wUmVjb3JkaW5nLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwYXVzZXMgdGhlIHJlY29yZGluZy4gWW91IGNhbiByZXN1bWUgcmVjb3JkaW5nIHVzaW5nIFwicmVzdW1lUmVjb3JkaW5nXCIgbWV0aG9kLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHRvZG8gRmlyZWZveCBpcyB1bmFibGUgdG8gcGF1c2UgdGhlIHJlY29yZGluZy4gRml4IGl0LlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIucGF1c2VSZWNvcmRpbmcoKTsgIC8vIHBhdXNlIHRoZSByZWNvcmRpbmdcclxuICAgICAgICAgKiByZWNvcmRlci5yZXN1bWVSZWNvcmRpbmcoKTsgLy8gcmVzdW1lIGFnYWluXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGF1c2VSZWNvcmRpbmc6IHBhdXNlUmVjb3JkaW5nLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXN1bWVzIHRoZSByZWNvcmRpbmcuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnBhdXNlUmVjb3JkaW5nKCk7ICAvLyBmaXJzdCBvZiBhbGwsIHBhdXNlIHRoZSByZWNvcmRpbmdcclxuICAgICAgICAgKiByZWNvcmRlci5yZXN1bWVSZWNvcmRpbmcoKTsgLy8gbm93IHJlc3VtZSBpdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc3VtZVJlY29yZGluZzogcmVzdW1lUmVjb3JkaW5nLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyB0aGUgcmVjb3JkaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHRvZG8gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGRlcHJlY2F0ZWQuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5pbml0UmVjb3JkZXIoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0UmVjb3JkZXI6IGluaXRSZWNvcmRlcixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXNrIFJlY29yZFJUQyB0byBhdXRvLXN0b3AgdGhlIHJlY29yZGluZyBhZnRlciA1IG1pbnV0ZXMuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHZhciBmaXZlTWludXRlcyA9IDUgKiAxMDAwICogNjA7XHJcbiAgICAgICAgICogcmVjb3JkZXIuc2V0UmVjb3JkaW5nRHVyYXRpb24oZml2ZU1pbnV0ZXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAqICAgIHZhciBibG9iID0gdGhpcy5nZXRCbG9iKCk7XHJcbiAgICAgICAgICogICAgdmlkZW8uc3JjID0gdGhpcy50b1VSTCgpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIC8vIG9yIG90aGVyd2lzZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnNldFJlY29yZGluZ0R1cmF0aW9uKGZpdmVNaW51dGVzKS5vblJlY29yZGluZ1N0b3BwZWQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICAgdmFyIGJsb2IgPSB0aGlzLmdldEJsb2IoKTtcclxuICAgICAgICAgKiAgICB2aWRlby5zcmMgPSB0aGlzLnRvVVJMKCk7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0UmVjb3JkaW5nRHVyYXRpb246IGZ1bmN0aW9uKHJlY29yZGluZ0R1cmF0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlY29yZGluZ0R1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3JlY29yZGluZ0R1cmF0aW9uIGlzIHJlcXVpcmVkLic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVjb3JkaW5nRHVyYXRpb24gIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAncmVjb3JkaW5nRHVyYXRpb24gbXVzdCBiZSBhIG51bWJlci4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLnJlY29yZGluZ0R1cmF0aW9uID0gcmVjb3JkaW5nRHVyYXRpb247XHJcbiAgICAgICAgICAgIHNlbGYub25SZWNvcmRpbmdTdG9wcGVkID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvblJlY29yZGluZ1N0b3BwZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vblJlY29yZGluZ1N0b3BwZWQgPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjbGVhci9yZXNldCBhbGwgdGhlIHJlY29yZGVkIGRhdGEuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAdG9kbyBGaWd1cmUgb3V0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXCJyZXNldFwiIGFuZCBcImNsZWFyUmVjb3JkZWREYXRhXCIgbWV0aG9kcy5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLmNsZWFyUmVjb3JkZWREYXRhKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xlYXJSZWNvcmRlZERhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdMb2coKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWVkaWFSZWNvcmRlci5jbGVhclJlY29yZGVkRGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmVkIG9sZCByZWNvcmRlZCBkYXRhLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSByZWNvcmRlZCBibG9iLiBVc2UgdGhpcyBtZXRob2QgaW5zaWRlIHRoZSBcInN0b3BSZWNvcmRpbmdcIiBjYWxsYmFjay5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgdmFyIGJsb2IgPSB0aGlzLmdldEJsb2IoKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgZmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgJ2ZpbGVuYW1lLndlYm0nLCB7XHJcbiAgICAgICAgICogICAgICAgICB0eXBlOiAndmlkZW8vd2VibSdcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICAgICAgICogICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpOyAvLyB1cGxvYWQgXCJGaWxlXCIgb2JqZWN0IHJhdGhlciB0aGFuIGEgXCJCbG9iXCJcclxuICAgICAgICAgKiAgICAgdXBsb2FkVG9TZXJ2ZXIoZm9ybURhdGEpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtCbG9ifSBSZXR1cm5zIHJlY29yZGVkIGRhdGEgYXMgXCJCbG9iXCIgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEJsb2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdMb2coKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhUmVjb3JkZXIuYmxvYjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgZGF0YS1VUkkgaW5zdGVhZCBvZiBCbG9iLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZ2V0IHRoZSBEYXRhLVVSSS5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgcmVjb3JkZXIuZ2V0RGF0YVVSTChmdW5jdGlvbihkYXRhVVJJKSB7XHJcbiAgICAgICAgICogICAgICAgICB2aWRlby5zcmMgPSBkYXRhVVJJO1xyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXREYXRhVVJMOiBnZXREYXRhVVJMLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdmlydHVhbC90ZW1wb3JhcnkgVVJMLiBVc2FnZSBvZiB0aGlzIFVSTCBpcyBsaW1pdGVkIHRvIGN1cnJlbnQgdGFiLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5zdG9wUmVjb3JkaW5nKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAqICAgICB2aWRlby5zcmMgPSB0aGlzLnRvVVJMKCk7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyBhIHZpcnR1YWwvdGVtcG9yYXJ5IFVSTCBmb3IgdGhlIHJlY29yZGVkIFwiQmxvYlwiLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvVVJMOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuaW5nTG9nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG1lZGlhUmVjb3JkZXIuYmxvYik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IGludGVybmFsIHJlY29yZGluZyBvYmplY3QgKGkuZS4gaW50ZXJuYWwgbW9kdWxlKSBlLmcuIE11dGxpU3RyZWFtUmVjb3JkZXIsIE1lZGlhU3RyZWFtUmVjb3JkZXIsIFN0ZXJlb0F1ZGlvUmVjb3JkZXIgb3IgV2hhbW15UmVjb3JkZXIgZXRjLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiB2YXIgaW50ZXJuYWxSZWNvcmRlciA9IHJlY29yZGVyLmdldEludGVybmFsUmVjb3JkZXIoKTtcclxuICAgICAgICAgKiBpZihpbnRlcm5hbFJlY29yZGVyIGluc3RhbmNlb2YgTXVsdGlTdHJlYW1SZWNvcmRlcikge1xyXG4gICAgICAgICAqICAgICBpbnRlcm5hbFJlY29yZGVyLmFkZFN0cmVhbXMoW25ld0F1ZGlvU3RyZWFtXSk7XHJcbiAgICAgICAgICogICAgIGludGVybmFsUmVjb3JkZXIucmVzZXRWaWRlb1N0cmVhbXMoW3NjcmVlblN0cmVhbV0pO1xyXG4gICAgICAgICAqIH1cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGludGVybmFsIHJlY29yZGluZyBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0SW50ZXJuYWxSZWNvcmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZWRpYVJlY29yZGVyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZSBzYXZlLWFzIGRpYWxvZyB0byBzYXZlIHRoZSByZWNvcmRlZCBibG9iIGludG8geW91ciBkaXNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZSAtIFNldCB5b3VyIG93biBmaWxlIG5hbWUuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICAgIHRoaXMuc2F2ZSgnZmlsZS1uYW1lJyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gb3IgbWFudWFsbHk6XHJcbiAgICAgICAgICogICAgIGludm9rZVNhdmVBc0RpYWxvZyh0aGlzLmdldEJsb2IoKSwgJ2ZpbGVuYW1lLndlYm0nKTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlOiBmdW5jdGlvbihmaWxlTmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdMb2coKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW52b2tlU2F2ZUFzRGlhbG9nKG1lZGlhUmVjb3JkZXIuYmxvYiwgZmlsZU5hbWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGdldHMgYSBibG9iIGZyb20gaW5kZXhlZC1EQiBzdG9yYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZ2V0IHRoZSByZWNvcmRlZCBibG9iLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5nZXRGcm9tRGlzayhmdW5jdGlvbihkYXRhVVJMKSB7XHJcbiAgICAgICAgICogICAgIHZpZGVvLnNyYyA9IGRhdGFVUkw7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RnJvbURpc2s6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghbWVkaWFSZWNvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgd2FybmluZ0xvZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBSZWNvcmRSVEMuZ2V0RnJvbURpc2soY29uZmlnLnR5cGUsIGNhbGxiYWNrKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhcHBlbmRzIGFuIGFycmF5IG9mIHdlYnAgaW1hZ2VzIHRvIHRoZSByZWNvcmRlZCB2aWRlby1ibG9iLiBJdCB0YWtlcyBhbiBcImFycmF5XCIgb2JqZWN0LlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXk+fVxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5T2ZXZWJQSW1hZ2VzIC0gQXJyYXkgb2Ygd2VicCBpbWFnZXMuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAdG9kbyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgZGVwcmVjYXRlZC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHZhciBhcnJheU9mV2ViUEltYWdlcyA9IFtdO1xyXG4gICAgICAgICAqIGFycmF5T2ZXZWJQSW1hZ2VzLnB1c2goe1xyXG4gICAgICAgICAqICAgICBkdXJhdGlvbjogaW5kZXgsXHJcbiAgICAgICAgICogICAgIGltYWdlOiAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCwuLi4nXHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICogcmVjb3JkZXIuc2V0QWR2ZXJ0aXNlbWVudEFycmF5KGFycmF5T2ZXZWJQSW1hZ2VzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRBZHZlcnRpc2VtZW50QXJyYXk6IGZ1bmN0aW9uKGFycmF5T2ZXZWJQSW1hZ2VzKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5hZHZlcnRpc2VtZW50ID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlPZldlYlBJbWFnZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuYWR2ZXJ0aXNlbWVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaSxcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogYXJyYXlPZldlYlBJbWFnZXNbaV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXQgaXMgZXF1aXZhbGVudCB0byA8Y29kZSBjbGFzcz1cInN0clwiPlwicmVjb3JkZXIuZ2V0QmxvYigpXCI8L2NvZGU+IG1ldGhvZC4gVXNhZ2Ugb2YgXCJnZXRCbG9iXCIgaXMgcmVjb21tZW5kZWQsIHRob3VnaC5cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Jsb2J9IGJsb2IgLSBSZWNvcmRlZCBCbG9iIGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICogICAgIHZhciBibG9iID0gdGhpcy5ibG9iO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGJlbG93IG9uZSBpcyByZWNvbW1lbmRlZFxyXG4gICAgICAgICAqICAgICB2YXIgYmxvYiA9IHRoaXMuZ2V0QmxvYigpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJsb2I6IG51bGwsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd29ya3Mgb25seSB3aXRoIHtyZWNvcmRlclR5cGU6U3RlcmVvQXVkaW9SZWNvcmRlcn0uIFVzZSB0aGlzIHByb3BlcnR5IG9uIFwic3RvcFJlY29yZGluZ1wiIHRvIHZlcmlmeSB0aGUgZW5jb2RlcidzIHNhbXBsZS1yYXRlcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyU2l6ZSAtIEJ1ZmZlci1zaXplIHVzZWQgdG8gZW5jb2RlIHRoZSBXQVYgY29udGFpbmVyXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgYWxlcnQoJ1JlY29yZGVyIHVzZWQgdGhpcyBidWZmZXItc2l6ZTogJyArIHRoaXMuYnVmZmVyU2l6ZSk7XHJcbiAgICAgICAgICogfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYnVmZmVyU2l6ZTogMCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyB3b3JrcyBvbmx5IHdpdGgge3JlY29yZGVyVHlwZTpTdGVyZW9BdWRpb1JlY29yZGVyfS4gVXNlIHRoaXMgcHJvcGVydHkgb24gXCJzdG9wUmVjb3JkaW5nXCIgdG8gdmVyaWZ5IHRoZSBlbmNvZGVyJ3Mgc2FtcGxlLXJhdGVzLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzYW1wbGVSYXRlIC0gU2FtcGxlLXJhdGVzIHVzZWQgdG8gZW5jb2RlIHRoZSBXQVYgY29udGFpbmVyXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgYWxlcnQoJ1JlY29yZGVyIHVzZWQgdGhlc2Ugc2FtcGxlLXJhdGVzOiAnICsgdGhpcy5zYW1wbGVSYXRlKTtcclxuICAgICAgICAgKiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzYW1wbGVSYXRlOiAwLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB7cmVjb3JkZXJUeXBlOlN0ZXJlb0F1ZGlvUmVjb3JkZXJ9IHJldHVybnMgQXJyYXlCdWZmZXIgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIEF1ZGlvIEFycmF5QnVmZmVyLCBzdXBwb3J0ZWQgb25seSBpbiBDaHJvbWUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgKiAgICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgICogICAgIGFsZXJ0KGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJ1ZmZlcjogbnVsbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSByZWNvcmRlci4gU28gdGhhdCB5b3UgY2FuIHJldXNlIHNpbmdsZSByZWNvcmRlciBpbnN0YW5jZSBtYW55IHRpbWVzLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5yZXNldCgpO1xyXG4gICAgICAgICAqIHJlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3JlY29yZGluZycgJiYgIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdG9wIGFuIGFjdGl2ZSByZWNvcmRlci4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1lZGlhUmVjb3JkZXIgJiYgdHlwZW9mIG1lZGlhUmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZWRpYVJlY29yZGVyID0gbnVsbDtcclxuICAgICAgICAgICAgc2V0U3RhdGUoJ2luYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIHNlbGYuYmxvYiA9IG51bGw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW5ldmVyIHJlY29yZGVyJ3Mgc3RhdGUgY2hhbmdlcy4gVXNlIHRoaXMgYXMgYW4gXCJldmVudFwiLlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzdGF0ZSAtIEEgcmVjb3JkZXIncyBzdGF0ZSBjYW4gYmU6IHJlY29yZGluZywgcGF1c2VkLCBzdG9wcGVkIG9yIGluYWN0aXZlLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5vblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgICAgICogICAgIGNvbnNvbGUubG9nKCdSZWNvcmRlciBzdGF0ZTogJywgc3RhdGUpO1xyXG4gICAgICAgICAqIH07XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25TdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjb3JkZXIgc3RhdGUgY2hhbmdlZDonLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHJlY29yZGVyIGNhbiBoYXZlIGluYWN0aXZlLCByZWNvcmRpbmcsIHBhdXNlZCBvciBzdG9wcGVkIHN0YXRlcy5cclxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdGUgLSBBIHJlY29yZGVyJ3Mgc3RhdGUgY2FuIGJlOiByZWNvcmRpbmcsIHBhdXNlZCwgc3RvcHBlZCBvciBpbmFjdGl2ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogLy8gdGhpcyBsb29wZXIgZnVuY3Rpb24gd2lsbCBrZWVwIHlvdSB1cGRhdGVkIGFib3V0IHRoZSByZWNvcmRlcidzIHN0YXRlcy5cclxuICAgICAgICAgKiAoZnVuY3Rpb24gbG9vcGVyKCkge1xyXG4gICAgICAgICAqICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoMScpLmlubmVySFRNTCA9ICdSZWNvcmRlclxcJ3Mgc3RhdGUgaXM6ICcgKyByZWNvcmRlci5zdGF0ZTtcclxuICAgICAgICAgKiAgICAgaWYocmVjb3JkZXIuc3RhdGUgPT09ICdzdG9wcGVkJykgcmV0dXJuOyAvLyBpZ25vcmUrc3RvcFxyXG4gICAgICAgICAqICAgICBzZXRUaW1lb3V0KGxvb3BlciwgMTAwMCk7IC8vIHVwZGF0ZSBhZnRlciBldmVyeSAzLXNlY29uZHNcclxuICAgICAgICAgKiB9KSgpO1xyXG4gICAgICAgICAqIHJlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGU6ICdpbmFjdGl2ZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCByZWNvcmRlcidzIHJlYWRvbmx5IHN0YXRlLlxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiB2YXIgc3RhdGUgPSByZWNvcmRlci5nZXRTdGF0ZSgpO1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgcmVjb3JkaW5nIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3RhdGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzdHJveSBSZWNvcmRSVEMgaW5zdGFuY2UuIENsZWFyIGFsbCByZWNvcmRlcnMgYW5kIG9iamVjdHMuXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGRpc2FibGVMb2dzQ2FjaGUgPSBjb25maWcuZGlzYWJsZUxvZ3M7XHJcblxyXG4gICAgICAgICAgICBjb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlTG9nczogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZWxmLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHNldFN0YXRlKCdkZXN0cm95ZWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuT2JqZWN0ID0gc2VsZiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoU3RvcmFnZS5BdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5BdWRpb0NvbnRleHRDb25zdHJ1Y3Rvci5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgU3RvcmFnZS5BdWRpb0NvbnRleHRDb25zdHJ1Y3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbmZpZy5kaXNhYmxlTG9ncyA9IGRpc2FibGVMb2dzQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZFJUQyBpcyBkZXN0cm95ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWNvcmRSVEMgdmVyc2lvbiBudW1iZXJcclxuICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvbiAtIFJlbGVhc2UgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1xyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIGFsZXJ0KHJlY29yZGVyLnZlcnNpb24pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZlcnNpb246ICc1LjYuMidcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCF0aGlzKSB7XHJcbiAgICAgICAgc2VsZiA9IHJldHVybk9iamVjdDtcclxuICAgICAgICByZXR1cm4gcmV0dXJuT2JqZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHNvbWVvbmUgd2FudHMgdG8gdXNlIFJlY29yZFJUQyB3aXRoIHRoZSBcIm5ld1wiIGtleXdvcmQuXHJcbiAgICBmb3IgKHZhciBwcm9wIGluIHJldHVybk9iamVjdCkge1xyXG4gICAgICAgIHRoaXNbcHJvcF0gPSByZXR1cm5PYmplY3RbcHJvcF07XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgcmV0dXJuIHJldHVybk9iamVjdDtcclxufVxyXG5cclxuUmVjb3JkUlRDLnZlcnNpb24gPSAnNS42LjInO1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnIC8qICYmICEhbW9kdWxlLmV4cG9ydHMqLyApIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjb3JkUlRDO1xyXG59XHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoJ1JlY29yZFJUQycsIFtdLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUmVjb3JkUlRDO1xyXG4gICAgfSk7XHJcbn1cblxyXG5SZWNvcmRSVEMuZ2V0RnJvbURpc2sgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgIHRocm93ICdjYWxsYmFjayBpcyBtYW5kYXRvcnkuJztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyByZWNvcmRlZCAnICsgKHR5cGUgPT09ICdhbGwnID8gJ2Jsb2JzJyA6IHR5cGUgKyAnIGJsb2IgJykgKyAnIGZyb20gZGlzayEnKTtcclxuICAgIERpc2tTdG9yYWdlLkZldGNoKGZ1bmN0aW9uKGRhdGFVUkwsIF90eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgIT09ICdhbGwnICYmIF90eXBlID09PSB0eXBlICsgJ0Jsb2InICYmIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFVUkwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhbGwnICYmIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFVUkwsIF90eXBlLnJlcGxhY2UoJ0Jsb2InLCAnJykpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHN0b3JlIHJlY29yZGVkIGJsb2JzIGludG8gSW5kZXhlZERCIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0ge2F1ZGlvOiBCbG9iLCB2aWRlbzogQmxvYiwgZ2lmOiBCbG9ifVxyXG4gKiBAbWV0aG9kXHJcbiAqIEBtZW1iZXJvZiBSZWNvcmRSVENcclxuICogQGV4YW1wbGVcclxuICogUmVjb3JkUlRDLndyaXRlVG9EaXNrKHtcclxuICogICAgIGF1ZGlvOiBhdWRpb0Jsb2IsXHJcbiAqICAgICB2aWRlbzogdmlkZW9CbG9iLFxyXG4gKiAgICAgZ2lmICA6IGdpZkJsb2JcclxuICogfSk7XHJcbiAqL1xyXG5SZWNvcmRSVEMud3JpdGVUb0Rpc2sgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBjb25zb2xlLmxvZygnV3JpdGluZyByZWNvcmRlZCBibG9iKHMpIHRvIGRpc2shJyk7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmIG9wdGlvbnMudmlkZW8gJiYgb3B0aW9ucy5naWYpIHtcclxuICAgICAgICBvcHRpb25zLmF1ZGlvLmdldERhdGFVUkwoZnVuY3Rpb24oYXVkaW9EYXRhVVJMKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudmlkZW8uZ2V0RGF0YVVSTChmdW5jdGlvbih2aWRlb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2lmLmdldERhdGFVUkwoZnVuY3Rpb24oZ2lmRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIERpc2tTdG9yYWdlLlN0b3JlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9CbG9iOiBhdWRpb0RhdGFVUkwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvQmxvYjogdmlkZW9EYXRhVVJMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnaWZCbG9iOiBnaWZEYXRhVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXVkaW8gJiYgb3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgIG9wdGlvbnMuYXVkaW8uZ2V0RGF0YVVSTChmdW5jdGlvbihhdWRpb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy52aWRlby5nZXREYXRhVVJMKGZ1bmN0aW9uKHZpZGVvRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgRGlza1N0b3JhZ2UuU3RvcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQmxvYjogYXVkaW9EYXRhVVJMLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvQmxvYjogdmlkZW9EYXRhVVJMXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXVkaW8gJiYgb3B0aW9ucy5naWYpIHtcclxuICAgICAgICBvcHRpb25zLmF1ZGlvLmdldERhdGFVUkwoZnVuY3Rpb24oYXVkaW9EYXRhVVJMKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZ2lmLmdldERhdGFVUkwoZnVuY3Rpb24oZ2lmRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgRGlza1N0b3JhZ2UuU3RvcmUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvQmxvYjogYXVkaW9EYXRhVVJMLFxyXG4gICAgICAgICAgICAgICAgICAgIGdpZkJsb2I6IGdpZkRhdGFVUkxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52aWRlbyAmJiBvcHRpb25zLmdpZikge1xyXG4gICAgICAgIG9wdGlvbnMudmlkZW8uZ2V0RGF0YVVSTChmdW5jdGlvbih2aWRlb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5naWYuZ2V0RGF0YVVSTChmdW5jdGlvbihnaWZEYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBEaXNrU3RvcmFnZS5TdG9yZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9CbG9iOiB2aWRlb0RhdGFVUkwsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2lmQmxvYjogZ2lmRGF0YVVSTFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmF1ZGlvKSB7XHJcbiAgICAgICAgb3B0aW9ucy5hdWRpby5nZXREYXRhVVJMKGZ1bmN0aW9uKGF1ZGlvRGF0YVVSTCkge1xyXG4gICAgICAgICAgICBEaXNrU3RvcmFnZS5TdG9yZSh7XHJcbiAgICAgICAgICAgICAgICBhdWRpb0Jsb2I6IGF1ZGlvRGF0YVVSTFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgIG9wdGlvbnMudmlkZW8uZ2V0RGF0YVVSTChmdW5jdGlvbih2aWRlb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgRGlza1N0b3JhZ2UuU3RvcmUoe1xyXG4gICAgICAgICAgICAgICAgdmlkZW9CbG9iOiB2aWRlb0RhdGFVUkxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ2lmKSB7XHJcbiAgICAgICAgb3B0aW9ucy5naWYuZ2V0RGF0YVVSTChmdW5jdGlvbihnaWZEYXRhVVJMKSB7XHJcbiAgICAgICAgICAgIERpc2tTdG9yYWdlLlN0b3JlKHtcclxuICAgICAgICAgICAgICAgIGdpZkJsb2I6IGdpZkRhdGFVUkxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuLy8gUmVjb3JkUlRDLUNvbmZpZ3VyYXRpb24uanNcclxuXHJcbi8qKlxyXG4gKiB7QGxpbmsgUmVjb3JkUlRDQ29uZmlndXJhdGlvbn0gaXMgYW4gaW5uZXIvcHJpdmF0ZSBoZWxwZXIgZm9yIHtAbGluayBSZWNvcmRSVEN9LlxyXG4gKiBAc3VtbWFyeSBJdCBjb25maWd1cmVzIHRoZSAybmQgcGFyYW1ldGVyIHBhc3NlZCBvdmVyIHtAbGluayBSZWNvcmRSVEN9IGFuZCByZXR1cm5zIGEgdmFsaWQgXCJjb25maWdcIiBvYmplY3QuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBSZWNvcmRSVENDb25maWd1cmF0aW9uXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgb3B0aW9ucyA9IFJlY29yZFJUQ0NvbmZpZ3VyYXRpb24obWVkaWFTdHJlYW0sIG9wdGlvbnMpO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG1lZGlhU3RyZWFtIC0gTWVkaWFTdHJlYW0gb2JqZWN0IGZldGNoZWQgdXNpbmcgZ2V0VXNlck1lZGlhIEFQSSBvciBnZW5lcmF0ZWQgdXNpbmcgY2FwdHVyZVN0cmVhbVVudGlsRW5kZWQgb3IgV2ViQXVkaW8gQVBJLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0ge3R5cGU6XCJ2aWRlb1wiLCBkaXNhYmxlTG9nczogdHJ1ZSwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzOiAxLCBidWZmZXJTaXplOiAwLCBzYW1wbGVSYXRlOiAwLCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgZ2V0TmF0aXZlQmxvYjp0cnVlLCBldGMufVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFJlY29yZFJUQ0NvbmZpZ3VyYXRpb24obWVkaWFTdHJlYW0sIGNvbmZpZykge1xyXG4gICAgaWYgKCFjb25maWcucmVjb3JkZXJUeXBlICYmICFjb25maWcudHlwZSkge1xyXG4gICAgICAgIGlmICghIWNvbmZpZy5hdWRpbyAmJiAhIWNvbmZpZy52aWRlbykge1xyXG4gICAgICAgICAgICBjb25maWcudHlwZSA9ICd2aWRlbyc7XHJcbiAgICAgICAgfSBlbHNlIGlmICghIWNvbmZpZy5hdWRpbyAmJiAhY29uZmlnLnZpZGVvKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy50eXBlID0gJ2F1ZGlvJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZy5yZWNvcmRlclR5cGUgJiYgIWNvbmZpZy50eXBlKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5yZWNvcmRlclR5cGUgPT09IFdoYW1teVJlY29yZGVyIHx8IGNvbmZpZy5yZWNvcmRlclR5cGUgPT09IENhbnZhc1JlY29yZGVyIHx8ICh0eXBlb2YgV2ViQXNzZW1ibHlSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLnJlY29yZGVyVHlwZSA9PT0gV2ViQXNzZW1ibHlSZWNvcmRlcikpIHtcclxuICAgICAgICAgICAgY29uZmlnLnR5cGUgPSAndmlkZW8nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnJlY29yZGVyVHlwZSA9PT0gR2lmUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgY29uZmlnLnR5cGUgPSAnZ2lmJztcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yZWNvcmRlclR5cGUgPT09IFN0ZXJlb0F1ZGlvUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgY29uZmlnLnR5cGUgPSAnYXVkaW8nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnJlY29yZGVyVHlwZSA9PT0gTWVkaWFTdHJlYW1SZWNvcmRlcikge1xyXG4gICAgICAgICAgICBpZiAoZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAnYXVkaW8nKS5sZW5ndGggJiYgZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAndmlkZW8nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy50eXBlID0gJ3ZpZGVvJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAnYXVkaW8nKS5sZW5ndGggJiYgZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAndmlkZW8nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy50eXBlID0gJ3ZpZGVvJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChnZXRUcmFja3MobWVkaWFTdHJlYW0sICdhdWRpbycpLmxlbmd0aCAmJiAhZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAndmlkZW8nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy50eXBlID0gJ2F1ZGlvJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZy50eXBlID0gJ1VuS25vd24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgTWVkaWFTdHJlYW1SZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lZGlhUmVjb3JkZXIgIT09ICd1bmRlZmluZWQnICYmICdyZXF1ZXN0RGF0YScgaW4gTWVkaWFSZWNvcmRlci5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAoIWNvbmZpZy5taW1lVHlwZSkge1xyXG4gICAgICAgICAgICBjb25maWcubWltZVR5cGUgPSAndmlkZW8vd2VibSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy50eXBlKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy50eXBlID0gY29uZmlnLm1pbWVUeXBlLnNwbGl0KCcvJylbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5iaXRzUGVyU2Vjb25kKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbmZpZy5iaXRzUGVyU2Vjb25kID0gMTI4MDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zaWRlciBkZWZhdWx0IHR5cGU9YXVkaW9cclxuICAgIGlmICghY29uZmlnLnR5cGUpIHtcclxuICAgICAgICBpZiAoY29uZmlnLm1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy50eXBlID0gY29uZmlnLm1pbWVUeXBlLnNwbGl0KCcvJylbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29uZmlnLnR5cGUpIHtcclxuICAgICAgICAgICAgY29uZmlnLnR5cGUgPSAnYXVkaW8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG59XG5cclxuLy8gX19fX19fX19fX19fX19fX19fXHJcbi8vIEdldFJlY29yZGVyVHlwZS5qc1xyXG5cclxuLyoqXHJcbiAqIHtAbGluayBHZXRSZWNvcmRlclR5cGV9IGlzIGFuIGlubmVyL3ByaXZhdGUgaGVscGVyIGZvciB7QGxpbmsgUmVjb3JkUlRDfS5cclxuICogQHN1bW1hcnkgSXQgcmV0dXJucyBiZXN0IHJlY29yZGVyLXR5cGUgYXZhaWxhYmxlIGZvciB5b3VyIGJyb3dzZXIuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBHZXRSZWNvcmRlclR5cGVcclxuICogQGNsYXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBSZWNvcmRlclR5cGUgPSBHZXRSZWNvcmRlclR5cGUob3B0aW9ucyk7XHJcbiAqIHZhciByZWNvcmRlciA9IG5ldyBSZWNvcmRlclR5cGUob3B0aW9ucyk7XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDfFJlY29yZFJUQyBTb3VyY2UgQ29kZX1cclxuICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gbWVkaWFTdHJlYW0gLSBNZWRpYVN0cmVhbSBvYmplY3QgZmV0Y2hlZCB1c2luZyBnZXRVc2VyTWVkaWEgQVBJIG9yIGdlbmVyYXRlZCB1c2luZyBjYXB0dXJlU3RyZWFtVW50aWxFbmRlZCBvciBXZWJBdWRpbyBBUEkuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSB7dHlwZTpcInZpZGVvXCIsIGRpc2FibGVMb2dzOiB0cnVlLCBudW1iZXJPZkF1ZGlvQ2hhbm5lbHM6IDEsIGJ1ZmZlclNpemU6IDAsIHNhbXBsZVJhdGU6IDAsIHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCBldGMufVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEdldFJlY29yZGVyVHlwZShtZWRpYVN0cmVhbSwgY29uZmlnKSB7XHJcbiAgICB2YXIgcmVjb3JkZXI7XHJcblxyXG4gICAgLy8gU3RlcmVvQXVkaW9SZWNvcmRlciBjYW4gd29yayB3aXRoIGFsbCB0aHJlZTogRWRnZSwgRmlyZWZveCBhbmQgQ2hyb21lXHJcbiAgICAvLyB0b2RvOiBkZXRlY3QgaWYgaXQgaXMgRWRnZSwgdGhlbiBhdXRvIHVzZTogU3RlcmVvQXVkaW9SZWNvcmRlclxyXG4gICAgaWYgKGlzQ2hyb21lIHx8IGlzRWRnZSB8fCBpc09wZXJhKSB7XHJcbiAgICAgICAgLy8gTWVkaWEgU3RyZWFtIFJlY29yZGluZyBBUEkgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGluIGNocm9tZSB5ZXQ7XHJcbiAgICAgICAgLy8gVGhhdCdzIHdoeSB1c2luZyBXZWJBdWRpbyBBUEkgdG8gcmVjb3JkIHN0ZXJlbyBhdWRpbyBpbiBXQVYgZm9ybWF0XHJcbiAgICAgICAgcmVjb3JkZXIgPSBTdGVyZW9BdWRpb1JlY29yZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3JlcXVlc3REYXRhJyBpbiBNZWRpYVJlY29yZGVyLnByb3RvdHlwZSAmJiAhaXNDaHJvbWUpIHtcclxuICAgICAgICByZWNvcmRlciA9IE1lZGlhU3RyZWFtUmVjb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmlkZW8gcmVjb3JkZXIgKGluIFdlYk0gZm9ybWF0KVxyXG4gICAgaWYgKGNvbmZpZy50eXBlID09PSAndmlkZW8nICYmIChpc0Nocm9tZSB8fCBpc09wZXJhKSkge1xyXG4gICAgICAgIHJlY29yZGVyID0gV2hhbW15UmVjb3JkZXI7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHlSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZWNvcmRlciA9IFdlYkFzc2VtYmx5UmVjb3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHZpZGVvIHJlY29yZGVyIChpbiBHaWYgZm9ybWF0KVxyXG4gICAgaWYgKGNvbmZpZy50eXBlID09PSAnZ2lmJykge1xyXG4gICAgICAgIHJlY29yZGVyID0gR2lmUmVjb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaHRtbDJjYW52YXMgcmVjb3JkaW5nIVxyXG4gICAgaWYgKGNvbmZpZy50eXBlID09PSAnY2FudmFzJykge1xyXG4gICAgICAgIHJlY29yZGVyID0gQ2FudmFzUmVjb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTWVkaWFSZWNvcmRlckNvbXBhdGlibGUoKSAmJiByZWNvcmRlciAhPT0gQ2FudmFzUmVjb3JkZXIgJiYgcmVjb3JkZXIgIT09IEdpZlJlY29yZGVyICYmIHR5cGVvZiBNZWRpYVJlY29yZGVyICE9PSAndW5kZWZpbmVkJyAmJiAncmVxdWVzdERhdGEnIGluIE1lZGlhUmVjb3JkZXIucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKGdldFRyYWNrcyhtZWRpYVN0cmVhbSwgJ3ZpZGVvJykubGVuZ3RoIHx8IGdldFRyYWNrcyhtZWRpYVN0cmVhbSwgJ2F1ZGlvJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGF1ZGlvLW9ubHkgcmVjb3JkaW5nXHJcbiAgICAgICAgICAgIGlmIChjb25maWcudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vd2VibScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkZXIgPSBNZWRpYVN0cmVhbVJlY29yZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSByZWNvcmRlciA9IFN0ZXJlb0F1ZGlvUmVjb3JkZXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2aWRlbyBvciBzY3JlZW4gdHJhY2tzXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIE1lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmIE1lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby93ZWJtJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRlciA9IE1lZGlhU3RyZWFtUmVjb3JkZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1lZGlhU3RyZWFtIGluc3RhbmNlb2YgQXJyYXkgJiYgbWVkaWFTdHJlYW0ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmVjb3JkZXIgPSBNdWx0aVN0cmVhbVJlY29yZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcucmVjb3JkZXJUeXBlKSB7XHJcbiAgICAgICAgcmVjb3JkZXIgPSBjb25maWcucmVjb3JkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzICYmICEhcmVjb3JkZXIgJiYgISFyZWNvcmRlci5uYW1lKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHJlY29yZGVyVHlwZTonLCByZWNvcmRlci5uYW1lIHx8IHJlY29yZGVyLmNvbnN0cnVjdG9yLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVjb3JkZXIgJiYgaXNTYWZhcmkpIHtcclxuICAgICAgICByZWNvcmRlciA9IE1lZGlhU3RyZWFtUmVjb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlY29yZGVyO1xyXG59XG5cclxuLy8gX19fX19fX19fX19fX1xyXG4vLyBNUmVjb3JkUlRDLmpzXHJcblxyXG4vKipcclxuICogTVJlY29yZFJUQyBydW5zIG9uIHRvcCBvZiB7QGxpbmsgUmVjb3JkUlRDfSB0byBicmluZyBtdWx0aXBsZSByZWNvcmRpbmdzIGluIGEgc2luZ2xlIHBsYWNlLCBieSBwcm92aWRpbmcgc2ltcGxlIEFQSS5cclxuICogQHN1bW1hcnkgTVJlY29yZFJUQyBzdGFuZHMgZm9yIFwiTXVsdGlwbGUtUmVjb3JkUlRDXCIuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBNUmVjb3JkUlRDXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcmVjb3JkZXIgPSBuZXcgTVJlY29yZFJUQygpO1xyXG4gKiByZWNvcmRlci5hZGRTdHJlYW0oTWVkaWFTdHJlYW0pO1xyXG4gKiByZWNvcmRlci5tZWRpYVR5cGUgPSB7XHJcbiAqICAgICBhdWRpbzogdHJ1ZSwgLy8gb3IgU3RlcmVvQXVkaW9SZWNvcmRlciBvciBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAqICAgICB2aWRlbzogdHJ1ZSwgLy8gb3IgV2hhbW15UmVjb3JkZXIgb3IgTWVkaWFTdHJlYW1SZWNvcmRlciBvciBXZWJBc3NlbWJseVJlY29yZGVyIG9yIENhbnZhc1JlY29yZGVyXHJcbiAqICAgICBnaWY6IHRydWUgICAgLy8gb3IgR2lmUmVjb3JkZXJcclxuICogfTtcclxuICogLy8gbWltZVR5cGUgaXMgb3B0aW9uYWwgYW5kIHNob3VsZCBiZSBzZXQgb25seSBpbiBhZHZhbmNlIGNhc2VzLlxyXG4gKiByZWNvcmRlci5taW1lVHlwZSA9IHtcclxuICogICAgIGF1ZGlvOiAnYXVkaW8vd2F2JyxcclxuICogICAgIHZpZGVvOiAndmlkZW8vd2VibScsXHJcbiAqICAgICBnaWY6ICAgJ2ltYWdlL2dpZidcclxuICogfTtcclxuICogcmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICogQHNlZSBGb3IgZnVydGhlciBpbmZvcm1hdGlvbjpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEMvdHJlZS9tYXN0ZXIvTVJlY29yZFJUQ3xNUmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbSAtIE1lZGlhU3RyZWFtIG9iamVjdCBmZXRjaGVkIHVzaW5nIGdldFVzZXJNZWRpYSBBUEkgb3IgZ2VuZXJhdGVkIHVzaW5nIGNhcHR1cmVTdHJlYW1VbnRpbEVuZGVkIG9yIFdlYkF1ZGlvIEFQSS5cclxuICogQHJlcXVpcmVzIHtAbGluayBSZWNvcmRSVEN9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTVJlY29yZFJUQyhtZWRpYVN0cmVhbSkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgYXR0YWNoZXMgTWVkaWFTdHJlYW0gb2JqZWN0IHRvIHtAbGluayBNUmVjb3JkUlRDfS5cclxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG1lZGlhU3RyZWFtIC0gQSBNZWRpYVN0cmVhbSBvYmplY3QsIGVpdGhlciBmZXRjaGVkIHVzaW5nIGdldFVzZXJNZWRpYSBBUEksIG9yIGdlbmVyYXRlZCB1c2luZyBjYXB0dXJlU3RyZWFtVW50aWxFbmRlZCBvciBXZWJBdWRpbyBBUEkuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTVJlY29yZFJUQ1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLmFkZFN0cmVhbShNZWRpYVN0cmVhbSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWRkU3RyZWFtID0gZnVuY3Rpb24oX21lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKF9tZWRpYVN0cmVhbSkge1xyXG4gICAgICAgICAgICBtZWRpYVN0cmVhbSA9IF9tZWRpYVN0cmVhbTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIHJlY29yZGluZyB0eXBlIGUuZy4gYXVkaW8sIG9yIHZpZGVvLCBvciBnaWYsIG9yIGNhbnZhcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtZWRpYVR5cGUgLSB7YXVkaW86IHRydWUsIHZpZGVvOiB0cnVlLCBnaWY6IHRydWV9XHJcbiAgICAgKiBAbWVtYmVyb2YgTVJlY29yZFJUQ1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZWNvcmRlciA9IG5ldyBNUmVjb3JkUlRDKCk7XHJcbiAgICAgKiByZWNvcmRlci5tZWRpYVR5cGUgPSB7XHJcbiAgICAgKiAgICAgYXVkaW86IHRydWUsIC8vIFRSVUUgb3IgU3RlcmVvQXVkaW9SZWNvcmRlciBvciBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiAgICAgdmlkZW86IHRydWUsIC8vIFRSVUUgb3IgV2hhbW15UmVjb3JkZXIgb3IgTWVkaWFTdHJlYW1SZWNvcmRlciBvciBXZWJBc3NlbWJseVJlY29yZGVyIG9yIENhbnZhc1JlY29yZGVyXHJcbiAgICAgKiAgICAgZ2lmICA6IHRydWUgIC8vIFRSVUUgb3IgR2lmUmVjb3JkZXJcclxuICAgICAqIH07XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWVkaWFUeXBlID0ge1xyXG4gICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgIHZpZGVvOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgc3RhcnRzIHJlY29yZGluZy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtZWRpYVR5cGUgPSB0aGlzLm1lZGlhVHlwZTtcclxuICAgICAgICB2YXIgcmVjb3JkZXJUeXBlO1xyXG4gICAgICAgIHZhciBtaW1lVHlwZSA9IHRoaXMubWltZVR5cGUgfHwge1xyXG4gICAgICAgICAgICBhdWRpbzogbnVsbCxcclxuICAgICAgICAgICAgdmlkZW86IG51bGwsXHJcbiAgICAgICAgICAgIGdpZjogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbWVkaWFUeXBlLmF1ZGlvICE9PSAnZnVuY3Rpb24nICYmIGlzTWVkaWFSZWNvcmRlckNvbXBhdGlibGUoKSAmJiAhZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAnYXVkaW8nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVkaWFUeXBlLmF1ZGlvID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG1lZGlhVHlwZS52aWRlbyAhPT0gJ2Z1bmN0aW9uJyAmJiBpc01lZGlhUmVjb3JkZXJDb21wYXRpYmxlKCkgJiYgIWdldFRyYWNrcyhtZWRpYVN0cmVhbSwgJ3ZpZGVvJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1lZGlhVHlwZS52aWRlbyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZWRpYVR5cGUuZ2lmICE9PSAnZnVuY3Rpb24nICYmIGlzTWVkaWFSZWNvcmRlckNvbXBhdGlibGUoKSAmJiAhZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAndmlkZW8nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVkaWFUeXBlLmdpZiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFtZWRpYVR5cGUuYXVkaW8gJiYgIW1lZGlhVHlwZS52aWRlbyAmJiAhbWVkaWFUeXBlLmdpZikge1xyXG4gICAgICAgICAgICB0aHJvdyAnTWVkaWFTdHJlYW0gbXVzdCBoYXZlIGVpdGhlciBhdWRpbyBvciB2aWRlbyB0cmFja3MuJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghIW1lZGlhVHlwZS5hdWRpbykge1xyXG4gICAgICAgICAgICByZWNvcmRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lZGlhVHlwZS5hdWRpbyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmVjb3JkZXJUeXBlID0gbWVkaWFUeXBlLmF1ZGlvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvUmVjb3JkZXIgPSBuZXcgUmVjb3JkUlRDKG1lZGlhU3RyZWFtLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyU2l6ZTogdGhpcy5idWZmZXJTaXplLFxyXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogdGhpcy5zYW1wbGVSYXRlLFxyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzOiB0aGlzLm51bWJlck9mQXVkaW9DaGFubmVscyB8fCAyLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZUxvZ3M6IHRoaXMuZGlzYWJsZUxvZ3MsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRlclR5cGU6IHJlY29yZGVyVHlwZSxcclxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZS5hdWRpbyxcclxuICAgICAgICAgICAgICAgIHRpbWVTbGljZTogdGhpcy50aW1lU2xpY2UsXHJcbiAgICAgICAgICAgICAgICBvblRpbWVTdGFtcDogdGhpcy5vblRpbWVTdGFtcFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghbWVkaWFUeXBlLnZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvUmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEhbWVkaWFUeXBlLnZpZGVvKSB7XHJcbiAgICAgICAgICAgIHJlY29yZGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVkaWFUeXBlLnZpZGVvID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRlclR5cGUgPSBtZWRpYVR5cGUudmlkZW87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdTdHJlYW0gPSBtZWRpYVN0cmVhbTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc01lZGlhUmVjb3JkZXJDb21wYXRpYmxlKCkgJiYgISFtZWRpYVR5cGUuYXVkaW8gJiYgdHlwZW9mIG1lZGlhVHlwZS5hdWRpbyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZGVvVHJhY2sgPSBnZXRUcmFja3MobWVkaWFTdHJlYW0sICd2aWRlbycpWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0ZpcmVmb3gpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdHJlYW0uYWRkVHJhY2sodmlkZW9UcmFjayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRlclR5cGUgJiYgcmVjb3JkZXJUeXBlID09PSBXaGFtbXlSZWNvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGRvZXMgTk9UIHN1cHBvcnRzIHdlYnAtZW5jb2RpbmcgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBGaXJlZm94IGRvIHN1cHBvcnRzIFdlYkFzc2VtYmx5UmVjb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZXJUeXBlID0gTWVkaWFTdHJlYW1SZWNvcmRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0cmVhbS5hZGRUcmFjayh2aWRlb1RyYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy52aWRlb1JlY29yZGVyID0gbmV3IFJlY29yZFJUQyhuZXdTdHJlYW0sIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXHJcbiAgICAgICAgICAgICAgICB2aWRlbzogdGhpcy52aWRlbyxcclxuICAgICAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBmcmFtZUludGVydmFsOiB0aGlzLmZyYW1lSW50ZXJ2YWwgfHwgMTAsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlTG9nczogdGhpcy5kaXNhYmxlTG9ncyxcclxuICAgICAgICAgICAgICAgIHJlY29yZGVyVHlwZTogcmVjb3JkZXJUeXBlLFxyXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLnZpZGVvLFxyXG4gICAgICAgICAgICAgICAgdGltZVNsaWNlOiB0aGlzLnRpbWVTbGljZSxcclxuICAgICAgICAgICAgICAgIG9uVGltZVN0YW1wOiB0aGlzLm9uVGltZVN0YW1wLFxyXG4gICAgICAgICAgICAgICAgd29ya2VyUGF0aDogdGhpcy53b3JrZXJQYXRoLFxyXG4gICAgICAgICAgICAgICAgd2ViQXNzZW1ibHlQYXRoOiB0aGlzLndlYkFzc2VtYmx5UGF0aCxcclxuICAgICAgICAgICAgICAgIGZyYW1lUmF0ZTogdGhpcy5mcmFtZVJhdGUsIC8vIHVzZWQgYnkgV2ViQXNzZW1ibHlSZWNvcmRlcjsgdmFsdWVzOiB1c3VhbGx5IDMwOyBhY2NlcHRzIGFueS5cclxuICAgICAgICAgICAgICAgIGJpdHJhdGU6IHRoaXMuYml0cmF0ZSAvLyB1c2VkIGJ5IFdlYkFzc2VtYmx5UmVjb3JkZXI7IHZhbHVlczogMCB0byAxMDAwK1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghbWVkaWFUeXBlLmF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvUmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEhbWVkaWFUeXBlLmF1ZGlvICYmICEhbWVkaWFUeXBlLnZpZGVvKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBpc1NpbmdsZVJlY29yZGVyID0gaXNNZWRpYVJlY29yZGVyQ29tcGF0aWJsZSgpID09PSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1lZGlhVHlwZS5hdWRpbyBpbnN0YW5jZW9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXIgJiYgISFtZWRpYVR5cGUudmlkZW8pIHtcclxuICAgICAgICAgICAgICAgIGlzU2luZ2xlUmVjb3JkZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZWRpYVR5cGUuYXVkaW8gIT09IHRydWUgJiYgbWVkaWFUeXBlLnZpZGVvICE9PSB0cnVlICYmIG1lZGlhVHlwZS5hdWRpbyAhPT0gbWVkaWFUeXBlLnZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICBpc1NpbmdsZVJlY29yZGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc1NpbmdsZVJlY29yZGVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmF1ZGlvUmVjb3JkZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi52aWRlb1JlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnZpZGVvUmVjb3JkZXIuaW5pdFJlY29yZGVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXVkaW9SZWNvcmRlci5pbml0UmVjb3JkZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggcmVjb3JkZXJzIGFyZSByZWFkeSB0byByZWNvcmQgdGhpbmdzIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi52aWRlb1JlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXVkaW9SZWNvcmRlci5zdGFydFJlY29yZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghIW1lZGlhVHlwZS5naWYpIHtcclxuICAgICAgICAgICAgcmVjb3JkZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZWRpYVR5cGUuZ2lmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRlclR5cGUgPSBtZWRpYVR5cGUuZ2lmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ2lmUmVjb3JkZXIgPSBuZXcgUmVjb3JkUlRDKG1lZGlhU3RyZWFtLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ2lmJyxcclxuICAgICAgICAgICAgICAgIGZyYW1lUmF0ZTogdGhpcy5mcmFtZVJhdGUgfHwgMjAwLFxyXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogdGhpcy5xdWFsaXR5IHx8IDEwLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZUxvZ3M6IHRoaXMuZGlzYWJsZUxvZ3MsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRlclR5cGU6IHJlY29yZGVyVHlwZSxcclxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZS5naWZcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2lmUmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgc3RvcHMgcmVjb3JkaW5nLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiBpcyBpbnZva2VkIHdoZW4gYWxsIGVuY29kZXJzIGZpbmlzaGVkIHRoZWlyIGpvYnMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTVJlY29yZFJUQ1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24ocmVjb3JkaW5nKXtcclxuICAgICAqICAgICB2YXIgYXVkaW9CbG9iID0gcmVjb3JkaW5nLmF1ZGlvO1xyXG4gICAgICogICAgIHZhciB2aWRlb0Jsb2IgPSByZWNvcmRpbmcudmlkZW87XHJcbiAgICAgKiAgICAgdmFyIGdpZkJsb2IgICA9IHJlY29yZGluZy5naWY7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb1JlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24oYmxvYlVSTCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYmxvYlVSTCwgJ2F1ZGlvJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmlkZW9SZWNvcmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZGVvUmVjb3JkZXIuc3RvcFJlY29yZGluZyhmdW5jdGlvbihibG9iVVJMKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhibG9iVVJMLCAndmlkZW8nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5naWZSZWNvcmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmdpZlJlY29yZGVyLnN0b3BSZWNvcmRpbmcoZnVuY3Rpb24oYmxvYlVSTCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYmxvYlVSTCwgJ2dpZicpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcGF1c2VzIHJlY29yZGluZy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucGF1c2VSZWNvcmRpbmcoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXVzZVJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb1JlY29yZGVyLnBhdXNlUmVjb3JkaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy52aWRlb1JlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWNvcmRlci5wYXVzZVJlY29yZGluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2lmUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5naWZSZWNvcmRlci5wYXVzZVJlY29yZGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXN1bWVzIHJlY29yZGluZy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVzdW1lUmVjb3JkaW5nKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzdW1lUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9SZWNvcmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvUmVjb3JkZXIucmVzdW1lUmVjb3JkaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy52aWRlb1JlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWNvcmRlci5yZXN1bWVSZWNvcmRpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmdpZlJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2lmUmVjb3JkZXIucmVzdW1lUmVjb3JkaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IGdldCBhbGwgcmVjb3JkZWQgYmxvYnMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEFsbCByZWNvcmRlZCBibG9icyBhcmUgcGFzc2VkIGJhY2sgdG8gdGhlIFwiY2FsbGJhY2tcIiBmdW5jdGlvbi5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuZ2V0QmxvYihmdW5jdGlvbihyZWNvcmRpbmcpe1xyXG4gICAgICogICAgIHZhciBhdWRpb0Jsb2IgPSByZWNvcmRpbmcuYXVkaW87XHJcbiAgICAgKiAgICAgdmFyIHZpZGVvQmxvYiA9IHJlY29yZGluZy52aWRlbztcclxuICAgICAqICAgICB2YXIgZ2lmQmxvYiAgID0gcmVjb3JkaW5nLmdpZjtcclxuICAgICAqIH0pO1xyXG4gICAgICogLy8gb3JcclxuICAgICAqIHZhciBhdWRpb0Jsb2IgPSByZWNvcmRlci5nZXRCbG9iKCkuYXVkaW87XHJcbiAgICAgKiB2YXIgdmlkZW9CbG9iID0gcmVjb3JkZXIuZ2V0QmxvYigpLnZpZGVvO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmdldEJsb2IgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9SZWNvcmRlcikge1xyXG4gICAgICAgICAgICBvdXRwdXQuYXVkaW8gPSB0aGlzLmF1ZGlvUmVjb3JkZXIuZ2V0QmxvYigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmlkZW9SZWNvcmRlcikge1xyXG4gICAgICAgICAgICBvdXRwdXQudmlkZW8gPSB0aGlzLnZpZGVvUmVjb3JkZXIuZ2V0QmxvYigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ2lmUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgb3V0cHV0LmdpZiA9IHRoaXMuZ2lmUmVjb3JkZXIuZ2V0QmxvYigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgYWxsIHJlY29yZGVyIGluc3RhbmNlcy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuZGVzdHJveSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5hdWRpb1JlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9SZWNvcmRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9SZWNvcmRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy52aWRlb1JlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWNvcmRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWNvcmRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5naWZSZWNvcmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmdpZlJlY29yZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5naWZSZWNvcmRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IGdldCBhbGwgcmVjb3JkZWQgYmxvYnMnIERhdGFVUkxzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBbGwgcmVjb3JkZWQgYmxvYnMnIERhdGFVUkxzIGFyZSBwYXNzZWQgYmFjayB0byB0aGUgXCJjYWxsYmFja1wiIGZ1bmN0aW9uLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1SZWNvcmRSVENcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5nZXREYXRhVVJMKGZ1bmN0aW9uKHJlY29yZGluZyl7XHJcbiAgICAgKiAgICAgdmFyIGF1ZGlvRGF0YVVSTCA9IHJlY29yZGluZy5hdWRpbztcclxuICAgICAqICAgICB2YXIgdmlkZW9EYXRhVVJMID0gcmVjb3JkaW5nLnZpZGVvO1xyXG4gICAgICogICAgIHZhciBnaWZEYXRhVVJMICAgPSByZWNvcmRpbmcuZ2lmO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0RGF0YVVSTCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5nZXRCbG9iKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAgICAgICAgaWYgKGJsb2IuYXVkaW8gJiYgYmxvYi52aWRlbykge1xyXG4gICAgICAgICAgICAgICAgZ2V0RGF0YVVSTChibG9iLmF1ZGlvLCBmdW5jdGlvbihfYXVkaW9EYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGF0YVVSTChibG9iLnZpZGVvLCBmdW5jdGlvbihfdmlkZW9EYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBfYXVkaW9EYXRhVVJMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IF92aWRlb0RhdGFVUkxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9iLmF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICBnZXREYXRhVVJMKGJsb2IuYXVkaW8sIGZ1bmN0aW9uKF9hdWRpb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBfYXVkaW9EYXRhVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9iLnZpZGVvKSB7XHJcbiAgICAgICAgICAgICAgICBnZXREYXRhVVJMKGJsb2IudmlkZW8sIGZ1bmN0aW9uKF92aWRlb0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvOiBfdmlkZW9EYXRhVVJMXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXREYXRhVVJMKGJsb2IsIGNhbGxiYWNrMDApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2ViV29ya2VyID0gcHJvY2Vzc0luV2ViV29ya2VyKGZ1bmN0aW9uIHJlYWRGaWxlKF9ibG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UobmV3IEZpbGVSZWFkZXJTeW5jKCkucmVhZEFzRGF0YVVSTChfYmxvYikpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2ViV29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2swMChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgd2ViV29ya2VyLnBvc3RNZXNzYWdlKGJsb2IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrMDAoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzSW5XZWJXb3JrZXIoX2Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9iID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbX2Z1bmN0aW9uLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAndGhpcy5vbm1lc3NhZ2UgPSAgZnVuY3Rpb24gKGVlZSkgeycgKyBfZnVuY3Rpb24ubmFtZSArICcoZWVlLmRhdGEpO30nXHJcbiAgICAgICAgICAgIF0sIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iKTtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBVUkwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSBVUkw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdlYmtpdFVSTCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHdlYmtpdFVSTDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdOZWl0aGVyIFVSTCBub3Igd2Via2l0VVJMIGRldGVjdGVkLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJsLnJldm9rZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdvcmtlcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gYXNrIHtAbGluayBNUmVjb3JkUlRDfSB0byB3cml0ZSBhbGwgcmVjb3JkZWQgYmxvYnMgaW50byBJbmRleGVkREIgc3RvcmFnZS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIud3JpdGVUb0Rpc2soKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy53cml0ZVRvRGlzayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFJlY29yZFJUQy53cml0ZVRvRGlzayh7XHJcbiAgICAgICAgICAgIGF1ZGlvOiB0aGlzLmF1ZGlvUmVjb3JkZXIsXHJcbiAgICAgICAgICAgIHZpZGVvOiB0aGlzLnZpZGVvUmVjb3JkZXIsXHJcbiAgICAgICAgICAgIGdpZjogdGhpcy5naWZSZWNvcmRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGludm9rZSBhIHNhdmUtYXMgZGlhbG9nIGZvciBhbGwgcmVjb3JkZWQgYmxvYnMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJncyAtIHthdWRpbzogJ2F1ZGlvLW5hbWUnLCB2aWRlbzogJ3ZpZGVvLW5hbWUnLCBnaWY6ICdnaWYtbmFtZSd9XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTVJlY29yZFJUQ1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnNhdmUoe1xyXG4gICAgICogICAgIGF1ZGlvOiAnYXVkaW8tZmlsZS1uYW1lJyxcclxuICAgICAqICAgICB2aWRlbzogJ3ZpZGVvLWZpbGUtbmFtZScsXHJcbiAgICAgKiAgICAgZ2lmICA6ICdnaWYtZmlsZS1uYW1lJ1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICBhcmdzID0gYXJncyB8fCB7XHJcbiAgICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICAgICAgZ2lmOiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCEhYXJncy5hdWRpbyAmJiB0aGlzLmF1ZGlvUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hdWRpb1JlY29yZGVyLnNhdmUodHlwZW9mIGFyZ3MuYXVkaW8gPT09ICdzdHJpbmcnID8gYXJncy5hdWRpbyA6ICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghIWFyZ3MudmlkZW8gJiYgdGhpcy52aWRlb1JlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWNvcmRlci5zYXZlKHR5cGVvZiBhcmdzLnZpZGVvID09PSAnc3RyaW5nJyA/IGFyZ3MudmlkZW8gOiAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIWFyZ3MuZ2lmICYmIHRoaXMuZ2lmUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5naWZSZWNvcmRlci5zYXZlKHR5cGVvZiBhcmdzLmdpZiA9PT0gJ3N0cmluZycgPyBhcmdzLmdpZiA6ICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZ2V0IGFsbCByZWNvcmRlZCBibG9icyBmcm9tIEluZGV4ZWREQiBzdG9yYWdlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtICdhbGwnIG9yICdhdWRpbycgb3IgJ3ZpZGVvJyBvciAnZ2lmJ1xyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCBhbGwgc3RvcmVkIGJsb2JzLlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBtZW1iZXJvZiBNUmVjb3JkUlRDXHJcbiAqIEBleGFtcGxlXHJcbiAqIE1SZWNvcmRSVEMuZ2V0RnJvbURpc2soJ2FsbCcsIGZ1bmN0aW9uKGRhdGFVUkwsIHR5cGUpe1xyXG4gKiAgICAgaWYodHlwZSA9PT0gJ2F1ZGlvJykgeyB9XHJcbiAqICAgICBpZih0eXBlID09PSAndmlkZW8nKSB7IH1cclxuICogICAgIGlmKHR5cGUgPT09ICdnaWYnKSAgIHsgfVxyXG4gKiB9KTtcclxuICovXHJcbk1SZWNvcmRSVEMuZ2V0RnJvbURpc2sgPSBSZWNvcmRSVEMuZ2V0RnJvbURpc2s7XHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gc3RvcmUgcmVjb3JkZWQgYmxvYnMgaW50byBJbmRleGVkREIgc3RvcmFnZS5cclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB7YXVkaW86IEJsb2IsIHZpZGVvOiBCbG9iLCBnaWY6IEJsb2J9XHJcbiAqIEBtZXRob2RcclxuICogQG1lbWJlcm9mIE1SZWNvcmRSVENcclxuICogQGV4YW1wbGVcclxuICogTVJlY29yZFJUQy53cml0ZVRvRGlzayh7XHJcbiAqICAgICBhdWRpbzogYXVkaW9CbG9iLFxyXG4gKiAgICAgdmlkZW86IHZpZGVvQmxvYixcclxuICogICAgIGdpZiAgOiBnaWZCbG9iXHJcbiAqIH0pO1xyXG4gKi9cclxuTVJlY29yZFJUQy53cml0ZVRvRGlzayA9IFJlY29yZFJUQy53cml0ZVRvRGlzaztcclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLk1SZWNvcmRSVEMgPSBNUmVjb3JkUlRDO1xyXG59XG5cclxudmFyIGJyb3dzZXJGYWtlVXNlckFnZW50ID0gJ0Zha2UvNS4wIChGYWtlT1MpIEFwcGxlV2ViS2l0LzEyMyAoS0hUTUwsIGxpa2UgR2Vja28pIEZha2UvMTIuMy40NTY3Ljg5IEZha2UvMTIzLjQ1JztcclxuXHJcbihmdW5jdGlvbih0aGF0KSB7XHJcbiAgICBpZiAoIXRoYXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWwubmF2aWdhdG9yID0ge1xyXG4gICAgICAgIHVzZXJBZ2VudDogYnJvd3NlckZha2VVc2VyQWdlbnQsXHJcbiAgICAgICAgZ2V0VXNlck1lZGlhOiBmdW5jdGlvbigpIHt9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghZ2xvYmFsLmNvbnNvbGUpIHtcclxuICAgICAgICBnbG9iYWwuY29uc29sZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmNvbnNvbGUubG9nID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZ2xvYmFsLmNvbnNvbGUuZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZ2xvYmFsLmNvbnNvbGUuZXJyb3IgPSBnbG9iYWwuY29uc29sZS5sb2cgPSBnbG9iYWwuY29uc29sZS5sb2cgfHwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIGRvY3VtZW50OnRydWUgKi9cclxuICAgICAgICB0aGF0LmRvY3VtZW50ID0ge1xyXG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gZG9jdW1lbnQuY2FwdHVyZVN0cmVhbSA9IGRvY3VtZW50Lm1vekNhcHR1cmVTdHJlYW0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGxheTogZnVuY3Rpb24oKSB7fSxcclxuICAgICAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgZHJhd0ltYWdlOiBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhhdC5IVE1MVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIGxvY2F0aW9uOnRydWUgKi9cclxuICAgICAgICB0aGF0LmxvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICBwcm90b2NvbDogJ2ZpbGU6JyxcclxuICAgICAgICAgICAgaHJlZjogJycsXHJcbiAgICAgICAgICAgIGhhc2g6ICcnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHNjcmVlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCBzY3JlZW46dHJ1ZSAqL1xyXG4gICAgICAgIHRoYXQuc2NyZWVuID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIFVSTCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCBzY3JlZW46dHJ1ZSAqL1xyXG4gICAgICAgIHRoYXQuVVJMID0ge1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RVUkw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXZva2VPYmplY3RVUkw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKmdsb2JhbCB3aW5kb3c6dHJ1ZSAqL1xyXG4gICAgdGhhdC53aW5kb3cgPSBnbG9iYWw7XHJcbn0pKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogbnVsbCk7XG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuLy8gQ3Jvc3MtQnJvd3Nlci1EZWNsYXJhdGlvbnMuanNcclxuXHJcbi8vIGFuaW1hdGlvbi1mcmFtZSB1c2VkIGluIFdlYk0gcmVjb3JkaW5nXHJcblxyXG4vKmpzaGludCAtVzA3OSAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIHdlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6dHJ1ZSAqL1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1velJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6dHJ1ZSAqL1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG1velJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZTp0cnVlICovXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gdmlhOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxyXG4gICAgICAgIHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4gICAgICAgIC8qZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZTp0cnVlICovXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcclxuICAgICAgICAgICAgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLypqc2hpbnQgLVcwNzkgKi9cclxudmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG5pZiAodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiB3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCBjYW5jZWxBbmltYXRpb25GcmFtZTp0cnVlICovXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vekNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIGNhbmNlbEFuaW1hdGlvbkZyYW1lOnRydWUgKi9cclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IG1vekNhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbXNDYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKmdsb2JhbCBjYW5jZWxBbmltYXRpb25GcmFtZTp0cnVlICovXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBtc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLypnbG9iYWwgY2FuY2VsQW5pbWF0aW9uRnJhbWU6dHJ1ZSAqL1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBXZWJBdWRpbyBBUEkgcmVwcmVzZW50ZXJcclxudmFyIEF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQ7XHJcblxyXG5pZiAodHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2Ygd2Via2l0QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIEF1ZGlvQ29udGV4dDp0cnVlICovXHJcbiAgICAgICAgQXVkaW9Db250ZXh0ID0gd2Via2l0QXVkaW9Db250ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbW96QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8qZ2xvYmFsIEF1ZGlvQ29udGV4dDp0cnVlICovXHJcbiAgICAgICAgQXVkaW9Db250ZXh0ID0gbW96QXVkaW9Db250ZXh0O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKmpzaGludCAtVzA3OSAqL1xyXG52YXIgVVJMID0gd2luZG93LlVSTDtcclxuXHJcbmlmICh0eXBlb2YgVVJMID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLypnbG9iYWwgVVJMOnRydWUgKi9cclxuICAgIFVSTCA9IHdlYmtpdFVSTDtcclxufVxyXG5cclxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID09PSAndW5kZWZpbmVkJykgeyAvLyBtYXliZSB3aW5kb3cubmF2aWdhdG9yP1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGlzRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpICE9PSAtMSAmJiAoISFuYXZpZ2F0b3IubXNTYXZlQmxvYiB8fCAhIW5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKTtcclxudmFyIGlzT3BlcmEgPSAhIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09QUi8nKSAhPT0gLTE7XHJcbnZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTEgJiYgKCduZXRzY2FwZScgaW4gd2luZG93KSAmJiAvIHJ2Oi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxudmFyIGlzQ2hyb21lID0gKCFpc09wZXJhICYmICFpc0VkZ2UgJiYgISFuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKSB8fCBpc0VsZWN0cm9uKCkgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZS8nKSAhPT0gLTE7XHJcblxyXG52YXIgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuaWYgKGlzU2FmYXJpICYmICFpc0Nocm9tZSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgIT09IC0xKSB7XHJcbiAgICBpc1NhZmFyaSA9IGZhbHNlO1xyXG4gICAgaXNDaHJvbWUgPSB0cnVlO1xyXG59XHJcblxyXG52YXIgTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW07XHJcblxyXG5pZiAodHlwZW9mIE1lZGlhU3RyZWFtID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2Via2l0TWVkaWFTdHJlYW0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBNZWRpYVN0cmVhbSA9IHdlYmtpdE1lZGlhU3RyZWFtO1xyXG59XHJcblxyXG4vKmdsb2JhbCBNZWRpYVN0cmVhbTp0cnVlICovXHJcbmlmICh0eXBlb2YgTWVkaWFTdHJlYW0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBvdmVycmlkZSBcInN0b3BcIiBtZXRob2QgZm9yIGFsbCBicm93c2Vyc1xyXG4gICAgaWYgKHR5cGVvZiBNZWRpYVN0cmVhbS5wcm90b3R5cGUuc3RvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBNZWRpYVN0cmVhbS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gYmVsb3cgZnVuY3Rpb24gdmlhOiBodHRwOi8vZ29vLmdsL0IzYWU4Y1xyXG4vKipcclxuICogUmV0dXJuIGh1bWFuLXJlYWRhYmxlIGZpbGUgc2l6ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzIC0gUGFzcyBieXRlcyBhbmQgZ2V0IGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gZm9ybWF0dGVkIHN0cmluZ1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBieXRlc1RvU2l6ZSgxMDI0KjEwMjQqNSkgPT09ICc1IEdCJ1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBieXRlc1RvU2l6ZShieXRlcykge1xyXG4gICAgdmFyIGsgPSAxMDAwO1xyXG4gICAgdmFyIHNpemVzID0gWydCeXRlcycsICdLQicsICdNQicsICdHQicsICdUQiddO1xyXG4gICAgaWYgKGJ5dGVzID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcwIEJ5dGVzJztcclxuICAgIH1cclxuICAgIHZhciBpID0gcGFyc2VJbnQoTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSksIDEwKTtcclxuICAgIHJldHVybiAoYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKSkudG9QcmVjaXNpb24oMykgKyAnICcgKyBzaXplc1tpXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7QmxvYn0gZmlsZSAtIEZpbGUgb3IgQmxvYiBvYmplY3QuIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWUgLSBPcHRpb25hbCBmaWxlIG5hbWUgZS5nLiBcIlJlY29yZGVkLVZpZGVvLndlYm1cIlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbnZva2VTYXZlQXNEaWFsb2coYmxvYiBvciBmaWxlLCBbb3B0aW9uYWxdIGZpbGVOYW1lKTtcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKi9cclxuZnVuY3Rpb24gaW52b2tlU2F2ZUFzRGlhbG9nKGZpbGUsIGZpbGVOYW1lKSB7XHJcbiAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICB0aHJvdyAnQmxvYiBvYmplY3QgaXMgcmVxdWlyZWQuJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWZpbGUudHlwZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZpbGUudHlwZSA9ICd2aWRlby93ZWJtJztcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaWxlRXh0ZW5zaW9uID0gKGZpbGUudHlwZSB8fCAndmlkZW8vd2VibScpLnNwbGl0KCcvJylbMV07XHJcbiAgICBpZiAoZmlsZUV4dGVuc2lvbi5pbmRleE9mKCc7JykgIT09IC0xKSB7XHJcbiAgICAgICAgLy8gZXh0ZW5kZWQgbWltZXR5cGUsIGUuZy4gJ3ZpZGVvL3dlYm07Y29kZWNzPXZwOCxvcHVzJ1xyXG4gICAgICAgIGZpbGVFeHRlbnNpb24gPSBmaWxlRXh0ZW5zaW9uLnNwbGl0KCc7JylbMF07XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsZU5hbWUgJiYgZmlsZU5hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xyXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IGZpbGVOYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgZmlsZU5hbWUgPSBzcGxpdHRlZFswXTtcclxuICAgICAgICBmaWxlRXh0ZW5zaW9uID0gc3BsaXR0ZWRbMV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpbGVGdWxsTmFtZSA9IChmaWxlTmFtZSB8fCAoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5OSkgKyA4ODg4ODg4ODgpKSArICcuJyArIGZpbGVFeHRlbnNpb247XHJcblxyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoZmlsZSwgZmlsZUZ1bGxOYW1lKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvci5tc1NhdmVCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubXNTYXZlQmxvYihmaWxlLCBmaWxlRnVsbE5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoeXBlcmxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBoeXBlcmxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XHJcbiAgICBoeXBlcmxpbmsuZG93bmxvYWQgPSBmaWxlRnVsbE5hbWU7XHJcblxyXG4gICAgaHlwZXJsaW5rLnN0eWxlID0gJ2Rpc3BsYXk6bm9uZTtvcGFjaXR5OjA7Y29sb3I6dHJhbnNwYXJlbnQ7JztcclxuICAgIChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuYXBwZW5kQ2hpbGQoaHlwZXJsaW5rKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGh5cGVybGluay5jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGh5cGVybGluay5jbGljaygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBoeXBlcmxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XHJcbiAgICAgICAgaHlwZXJsaW5rLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xyXG4gICAgICAgICAgICB2aWV3OiB3aW5kb3csXHJcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgVVJMLnJldm9rZU9iamVjdFVSTChoeXBlcmxpbmsuaHJlZik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vY2hldG9uL2lzLWVsZWN0cm9uL2Jsb2IvbWFzdGVyL2luZGV4LmpzXHJcbiAqKi9cclxuZnVuY3Rpb24gaXNFbGVjdHJvbigpIHtcclxuICAgIC8vIFJlbmRlcmVyIHByb2Nlc3NcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MgPT09ICdvYmplY3QnICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWluIHByb2Nlc3NcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT09ICdvYmplY3QnICYmICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVjdCB0aGUgdXNlciBhZ2VudCB3aGVuIHRoZSBgbm9kZUludGVncmF0aW9uYCBvcHRpb24gaXMgc2V0IHRvIHRydWVcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFbGVjdHJvbicpID49IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRyYWNrcyhzdHJlYW0sIGtpbmQpIHtcclxuICAgIGlmICghc3RyZWFtIHx8ICFzdHJlYW0uZ2V0VHJhY2tzKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHJlYW0uZ2V0VHJhY2tzKCkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICByZXR1cm4gdC5raW5kID09PSAoa2luZCB8fCAnYXVkaW8nKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRTcmNPYmplY3Qoc3RyZWFtLCBlbGVtZW50KSB7XHJcbiAgICBpZiAoJ3NyY09iamVjdCcgaW4gZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgfSBlbHNlIGlmICgnbW96U3JjT2JqZWN0JyBpbiBlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtCbG9ifSBmaWxlIC0gRmlsZSBvciBCbG9iIG9iamVjdC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbi5cclxuICogQGV4YW1wbGVcclxuICogZ2V0U2Vla2FibGVCbG9iKGJsb2Igb3IgZmlsZSwgY2FsbGJhY2spO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTZWVrYWJsZUJsb2IoaW5wdXRCbG9iLCBjYWxsYmFjaykge1xyXG4gICAgLy8gRUJNTC5qcyBjb3B5cmlnaHRzIGdvZXMgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS9sZWdva2ljaGkvdHMtZWJtbFxyXG4gICAgaWYgKHR5cGVvZiBFQk1MID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGxpbms6IGh0dHBzOi8vd3d3LndlYnJ0Yy1leHBlcmltZW50LmNvbS9FQk1MLmpzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlYWRlciA9IG5ldyBFQk1MLlJlYWRlcigpO1xyXG4gICAgdmFyIGRlY29kZXIgPSBuZXcgRUJNTC5EZWNvZGVyKCk7XHJcbiAgICB2YXIgdG9vbHMgPSBFQk1MLnRvb2xzO1xyXG5cclxuICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBlYm1sRWxtcyA9IGRlY29kZXIuZGVjb2RlKHRoaXMucmVzdWx0KTtcclxuICAgICAgICBlYm1sRWxtcy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmVhZGVyLnJlYWQoZWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVhZGVyLnN0b3AoKTtcclxuICAgICAgICB2YXIgcmVmaW5lZE1ldGFkYXRhQnVmID0gdG9vbHMubWFrZU1ldGFkYXRhU2Vla2FibGUocmVhZGVyLm1ldGFkYXRhcywgcmVhZGVyLmR1cmF0aW9uLCByZWFkZXIuY3Vlcyk7XHJcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnJlc3VsdC5zbGljZShyZWFkZXIubWV0YWRhdGFTaXplKTtcclxuICAgICAgICB2YXIgbmV3QmxvYiA9IG5ldyBCbG9iKFtyZWZpbmVkTWV0YWRhdGFCdWYsIGJvZHldLCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlby93ZWJtJ1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjYWxsYmFjayhuZXdCbG9iKTtcclxuICAgIH07XHJcbiAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGlucHV0QmxvYik7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLmludm9rZVNhdmVBc0RpYWxvZyA9IGludm9rZVNhdmVBc0RpYWxvZztcclxuICAgIFJlY29yZFJUQy5nZXRUcmFja3MgPSBnZXRUcmFja3M7XHJcbiAgICBSZWNvcmRSVEMuZ2V0U2Vla2FibGVCbG9iID0gZ2V0U2Vla2FibGVCbG9iO1xyXG4gICAgUmVjb3JkUlRDLmJ5dGVzVG9TaXplID0gYnl0ZXNUb1NpemU7XHJcbiAgICBSZWNvcmRSVEMuaXNFbGVjdHJvbiA9IGlzRWxlY3Ryb247XHJcbn1cclxuXHJcbi8vIF9fX19fX19fX18gKHVzZWQgdG8gaGFuZGxlIHN0dWZmIGxpa2UgaHR0cDovL2dvby5nbC94bUU1ZWcpIGlzc3VlICMxMjlcclxuLy8gU3RvcmFnZS5qc1xyXG5cclxuLyoqXHJcbiAqIFN0b3JhZ2UgaXMgYSBzdGFuZGFsb25lIG9iamVjdCB1c2VkIGJ5IHtAbGluayBSZWNvcmRSVEN9IHRvIHN0b3JlIHJldXNhYmxlIG9iamVjdHMgZS5nLiBcIm5ldyBBdWRpb0NvbnRleHRcIi5cclxuICogQGxpY2Vuc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUfVxyXG4gKiBAYXV0aG9yIHtAbGluayBodHRwczovL011YXpLaGFuLmNvbXxNdWF6IEtoYW59XHJcbiAqIEBleGFtcGxlXHJcbiAqIFN0b3JhZ2UuQXVkaW9Db250ZXh0ID09PSB3ZWJraXRBdWRpb0NvbnRleHRcclxuICogQHByb3BlcnR5IHt3ZWJraXRBdWRpb0NvbnRleHR9IEF1ZGlvQ29udGV4dCAtIEtlZXBzIGEgcmVmZXJlbmNlIHRvIEF1ZGlvQ29udGV4dCBvYmplY3QuXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDfFJlY29yZFJUQyBTb3VyY2UgQ29kZX1cclxuICovXHJcblxyXG52YXIgU3RvcmFnZSA9IHt9O1xyXG5cclxuaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBTdG9yYWdlLkF1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dDtcclxufSBlbHNlIGlmICh0eXBlb2Ygd2Via2l0QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgU3RvcmFnZS5BdWRpb0NvbnRleHQgPSB3ZWJraXRBdWRpb0NvbnRleHQ7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLlN0b3JhZ2UgPSBTdG9yYWdlO1xyXG59XG5cclxuZnVuY3Rpb24gaXNNZWRpYVJlY29yZGVyQ29tcGF0aWJsZSgpIHtcclxuICAgIGlmIChpc0ZpcmVmb3ggfHwgaXNTYWZhcmkgfHwgaXNFZGdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5WZXIgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcclxuICAgIHZhciBuQWd0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIHZhciBmdWxsVmVyc2lvbiA9ICcnICsgcGFyc2VGbG9hdChuYXZpZ2F0b3IuYXBwVmVyc2lvbik7XHJcbiAgICB2YXIgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobmF2aWdhdG9yLmFwcFZlcnNpb24sIDEwKTtcclxuICAgIHZhciBuYW1lT2Zmc2V0LCB2ZXJPZmZzZXQsIGl4O1xyXG5cclxuICAgIGlmIChpc0Nocm9tZSB8fCBpc09wZXJhKSB7XHJcbiAgICAgICAgdmVyT2Zmc2V0ID0gbkFndC5pbmRleE9mKCdDaHJvbWUnKTtcclxuICAgICAgICBmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRyaW0gdGhlIGZ1bGxWZXJzaW9uIHN0cmluZyBhdCBzZW1pY29sb24vc3BhY2UgaWYgcHJlc2VudFxyXG4gICAgaWYgKChpeCA9IGZ1bGxWZXJzaW9uLmluZGV4T2YoJzsnKSkgIT09IC0xKSB7XHJcbiAgICAgICAgZnVsbFZlcnNpb24gPSBmdWxsVmVyc2lvbi5zdWJzdHJpbmcoMCwgaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoaXggPSBmdWxsVmVyc2lvbi5pbmRleE9mKCcgJykpICE9PSAtMSkge1xyXG4gICAgICAgIGZ1bGxWZXJzaW9uID0gZnVsbFZlcnNpb24uc3Vic3RyaW5nKDAsIGl4KTtcclxuICAgIH1cclxuXHJcbiAgICBtYWpvclZlcnNpb24gPSBwYXJzZUludCgnJyArIGZ1bGxWZXJzaW9uLCAxMCk7XHJcblxyXG4gICAgaWYgKGlzTmFOKG1ham9yVmVyc2lvbikpIHtcclxuICAgICAgICBmdWxsVmVyc2lvbiA9ICcnICsgcGFyc2VGbG9hdChuYXZpZ2F0b3IuYXBwVmVyc2lvbik7XHJcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobmF2aWdhdG9yLmFwcFZlcnNpb24sIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDQ5O1xyXG59XG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fX1xyXG4vLyBNZWRpYVN0cmVhbVJlY29yZGVyLmpzXHJcblxyXG4vKipcclxuICogTWVkaWFTdHJlYW1SZWNvcmRlciBpcyBhbiBhYnN0cmFjdGlvbiBsYXllciBmb3Ige0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYWNhcHR1cmUtcmVjb3JkL01lZGlhUmVjb3JkZXIuaHRtbHxNZWRpYVJlY29yZGVyIEFQSX0uIEl0IGlzIHVzZWQgYnkge0BsaW5rIFJlY29yZFJUQ30gdG8gcmVjb3JkIE1lZGlhU3RyZWFtKHMpIGluIGJvdGggQ2hyb21lIGFuZCBGaXJlZm94LlxyXG4gKiBAc3VtbWFyeSBSdW5zIHRvcCBvdmVyIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWFjYXB0dXJlLXJlY29yZC9NZWRpYVJlY29yZGVyLmh0bWx8TWVkaWFSZWNvcmRlciBBUEl9LlxyXG4gKiBAbGljZW5zZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVR9XHJcbiAqIEBhdXRob3Ige0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW58TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgY29uZmlnID0ge1xyXG4gKiAgICAgbWltZVR5cGU6ICd2aWRlby93ZWJtJywgLy8gdnA4LCB2cDksIGgyNjQsIG1rdiwgb3B1cy92b3JiaXNcclxuICogICAgIGF1ZGlvQml0c1BlclNlY29uZCA6IDI1NiAqIDggKiAxMDI0LFxyXG4gKiAgICAgdmlkZW9CaXRzUGVyU2Vjb25kIDogMjU2ICogOCAqIDEwMjQsXHJcbiAqICAgICBiaXRzUGVyU2Vjb25kOiAyNTYgKiA4ICogMTAyNCwgIC8vIGlmIHRoaXMgaXMgcHJvdmlkZWQsIHNraXAgYWJvdmUgdHdvXHJcbiAqICAgICBjaGVja0ZvckluYWN0aXZlVHJhY2tzOiB0cnVlLFxyXG4gKiAgICAgdGltZVNsaWNlOiAxMDAwLCAvLyBjb25jYXRlbmF0ZSBpbnRlcnZhbHMgYmFzZWQgYmxvYnNcclxuICogICAgIG9uZGF0YWF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSAvLyBnZXQgaW50ZXJ2YWxzIGJhc2VkIGJsb2JzXHJcbiAqIH1cclxuICogdmFyIHJlY29yZGVyID0gbmV3IE1lZGlhU3RyZWFtUmVjb3JkZXIobWVkaWFTdHJlYW0sIGNvbmZpZyk7XHJcbiAqIHJlY29yZGVyLnJlY29yZCgpO1xyXG4gKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICogICAgIHZpZGVvLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAqXHJcbiAqICAgICAvLyBvclxyXG4gKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5ibG9iO1xyXG4gKiB9KTtcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbSAtIE1lZGlhU3RyZWFtIG9iamVjdCBmZXRjaGVkIHVzaW5nIGdldFVzZXJNZWRpYSBBUEkgb3IgZ2VuZXJhdGVkIHVzaW5nIGNhcHR1cmVTdHJlYW1VbnRpbEVuZGVkIG9yIFdlYkF1ZGlvIEFQSS5cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIHtkaXNhYmxlTG9nczp0cnVlLCBpbml0Q2FsbGJhY2s6IGZ1bmN0aW9uLCBtaW1lVHlwZTogXCJ2aWRlby93ZWJtXCIsIHRpbWVTbGljZTogMTAwMH1cclxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIGZpcnN0IGFyZ3VtZW50IFwiTWVkaWFTdHJlYW1cIiBpcyBtaXNzaW5nLiBBbHNvIHRocm93cyBlcnJvciBpZiBcIk1lZGlhUmVjb3JkZXIgQVBJXCIgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTWVkaWFTdHJlYW1SZWNvcmRlcihtZWRpYVN0cmVhbSwgY29uZmlnKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBtZWRpYVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyAnRmlyc3QgYXJndW1lbnQgXCJNZWRpYVN0cmVhbVwiIGlzIHJlcXVpcmVkLic7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBNZWRpYVJlY29yZGVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93ICdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgTWVkaWEgUmVjb3JkZXIgQVBJLiBQbGVhc2UgdHJ5IG90aGVyIG1vZHVsZXMgZS5nLiBXaGFtbXlSZWNvcmRlciBvciBTdGVyZW9BdWRpb1JlY29yZGVyLic7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHtcclxuICAgICAgICAvLyBiaXRzUGVyU2Vjb25kOiAyNTYgKiA4ICogMTAyNCxcclxuICAgICAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm0nXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChjb25maWcudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgIGlmIChnZXRUcmFja3MobWVkaWFTdHJlYW0sICd2aWRlbycpLmxlbmd0aCAmJiBnZXRUcmFja3MobWVkaWFTdHJlYW0sICdhdWRpbycpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyZWFtO1xyXG4gICAgICAgICAgICBpZiAoISFuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5hZGRUcmFjayhnZXRUcmFja3MobWVkaWFTdHJlYW0sICdhdWRpbycpWzBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlYmtpdE1lZGlhU3RyZWFtXHJcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oZ2V0VHJhY2tzKG1lZGlhU3RyZWFtLCAnYXVkaW8nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVkaWFTdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy5taW1lVHlwZSB8fCBjb25maWcubWltZVR5cGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2F1ZGlvJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5taW1lVHlwZSA9IGlzQ2hyb21lID8gJ2F1ZGlvL3dlYm0nIDogJ2F1ZGlvL29nZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLm1pbWVUeXBlICYmIGNvbmZpZy5taW1lVHlwZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgIT09ICdhdWRpby9vZ2cnICYmICEhbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xyXG4gICAgICAgICAgICAvLyBmb3JjaW5nIGJldHRlciBjb2RlY3Mgb24gRmlyZWZveCAodmlhICMxNjYpXHJcbiAgICAgICAgICAgIGNvbmZpZy5taW1lVHlwZSA9ICdhdWRpby9vZ2cnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJyYXlPZkJsb2JzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFycmF5IG9mIGJsb2JzLiBVc2Ugb25seSB3aXRoIFwidGltZVNsaWNlXCIuIEl0cyB1c2VmdWwgdG8gcHJldmlldyByZWNvcmRpbmcgYW55dGltZSwgd2l0aG91dCB1c2luZyB0aGUgXCJzdG9wXCIgbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgYXJyYXlPZkJsb2JzID0gcmVjb3JkZXIuZ2V0QXJyYXlPZkJsb2JzKCk7XHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYXJyYXkgb2YgcmVjb3JkZWQgYmxvYnMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0QXJyYXlPZkJsb2JzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5T2ZCbG9icztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZWNvcmRzIE1lZGlhU3RyZWFtLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWNvcmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBzZXQgZGVmYXVsdHNcclxuICAgICAgICBzZWxmLmJsb2IgPSBudWxsO1xyXG4gICAgICAgIHNlbGYuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAgICBzZWxmLnRpbWVzdGFtcHMgPSBbXTtcclxuICAgICAgICBhbGxTdGF0ZXMgPSBbXTtcclxuICAgICAgICBhcnJheU9mQmxvYnMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHJlY29yZGVySGludHMgPSBjb25maWc7XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXNzaW5nIGZvbGxvd2luZyBjb25maWcgb3ZlciBNZWRpYVJlY29yZGVyIEFQSS4nLCByZWNvcmRlckhpbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgRmlyZWZveCBkb2Vzbid0IGZhaWxzIHRvIHJlY29yZCBzdHJlYW1zIDMtNCB0aW1lcyB3aXRob3V0IHJlbG9hZGluZyB0aGUgcGFnZS5cclxuICAgICAgICAgICAgbWVkaWFSZWNvcmRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNDaHJvbWUgJiYgIWlzTWVkaWFSZWNvcmRlckNvbXBhdGlibGUoKSkge1xyXG4gICAgICAgICAgICAvLyB0byBzdXBwb3J0IHZpZGVvLW9ubHkgcmVjb3JkaW5nIG9uIHN0YWJsZVxyXG4gICAgICAgICAgICByZWNvcmRlckhpbnRzID0gJ3ZpZGVvL3ZwOCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIE1lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmIHJlY29yZGVySGludHMubWltZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKCFNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZChyZWNvcmRlckhpbnRzLm1pbWVUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01lZGlhUmVjb3JkZXIgQVBJIHNlZW1zIHVuYWJsZSB0byByZWNvcmQgbWltZVR5cGU6JywgcmVjb3JkZXJIaW50cy5taW1lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVjb3JkZXJIaW50cy5taW1lVHlwZSA9IGNvbmZpZy50eXBlID09PSAnYXVkaW8nID8gJ2F1ZGlvL3dlYm0nIDogJ3ZpZGVvL3dlYm0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1c2luZyBNZWRpYVJlY29yZGVyIEFQSSBoZXJlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKG1lZGlhU3RyZWFtLCByZWNvcmRlckhpbnRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlc2V0XHJcbiAgICAgICAgICAgIGNvbmZpZy5taW1lVHlwZSA9IHJlY29yZGVySGludHMubWltZVR5cGU7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBjaHJvbWUtYmFzZWQgZmFsbGJhY2tcclxuICAgICAgICAgICAgbWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKG1lZGlhU3RyZWFtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9sZCBoYWNrP1xyXG4gICAgICAgIGlmIChyZWNvcmRlckhpbnRzLm1pbWVUeXBlICYmICFNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCAmJiAnY2FuUmVjb3JkTWltZVR5cGUnIGluIG1lZGlhUmVjb3JkZXIgJiYgbWVkaWFSZWNvcmRlci5jYW5SZWNvcmRNaW1lVHlwZShyZWNvcmRlckhpbnRzLm1pbWVUeXBlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWVkaWFSZWNvcmRlciBBUEkgc2VlbXMgdW5hYmxlIHRvIHJlY29yZCBtaW1lVHlwZTonLCByZWNvcmRlckhpbnRzLm1pbWVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGlzcGF0Y2hpbmcgT25EYXRhQXZhaWxhYmxlIEhhbmRsZXJcclxuICAgICAgICBtZWRpYVJlY29yZGVyLm9uZGF0YWF2YWlsYWJsZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgYWxsU3RhdGVzLnB1c2goJ29uZGF0YWF2YWlsYWJsZTogJyArIGJ5dGVzVG9TaXplKGUuZGF0YS5zaXplKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpbWVTbGljZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRhdGEgJiYgZS5kYXRhLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheU9mQmxvYnMucHVzaChlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWVTdGFtcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5vbmRhdGFhdmFpbGFibGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJ2YWxzIGJhc2VkIGJsb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gY29uZmlnLmdldE5hdGl2ZUJsb2IgPyBlLmRhdGEgOiBuZXcgQmxvYihbZS5kYXRhXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0TWltZVR5cGUocmVjb3JkZXJIaW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5vbmRhdGFhdmFpbGFibGUoYmxvYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWUuZGF0YSB8fCAhZS5kYXRhLnNpemUgfHwgZS5kYXRhLnNpemUgPCAxMDAgfHwgc2VsZi5ibG9iKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCBzdG9wUmVjb3JkaW5nIGFsd2F5cyBnZXR0aW5nIGZpcmVkXHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGlzIGludmFsaWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmVjb3JkaW5nQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY29yZGluZ0NhbGxiYWNrKG5ldyBCbG9iKFtdLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldE1pbWVUeXBlKHJlY29yZGVySGludHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb3JkaW5nQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmJsb2IgPSBjb25maWcuZ2V0TmF0aXZlQmxvYiA/IGUuZGF0YSA6IG5ldyBCbG9iKFtlLmRhdGFdLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRNaW1lVHlwZShyZWNvcmRlckhpbnRzKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLnJlY29yZGluZ0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29yZGluZ0NhbGxiYWNrKHNlbGYuYmxvYik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29yZGluZ0NhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1lZGlhUmVjb3JkZXIub25zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBhbGxTdGF0ZXMucHVzaCgnc3RhcnRlZCcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1lZGlhUmVjb3JkZXIub25wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBhbGxTdGF0ZXMucHVzaCgncGF1c2VkJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbWVkaWFSZWNvcmRlci5vbnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBhbGxTdGF0ZXMucHVzaCgncmVzdW1lZCcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1lZGlhUmVjb3JkZXIub25zdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGFsbFN0YXRlcy5wdXNoKCdzdG9wcGVkJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbWVkaWFSZWNvcmRlci5vbmVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVycm9yLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnVW5rbm93bkVycm9yJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWxsU3RhdGVzLnB1c2goJ2Vycm9yOiAnICsgZXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIHZpYTogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21lZGlhY2FwdHVyZS1yZWNvcmQvTWVkaWFSZWNvcmRlci5odG1sI2V4Y2VwdGlvbi1zdW1tYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaW52YWxpZHN0YXRlJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlIE1lZGlhUmVjb3JkZXIgaXMgbm90IGluIGEgc3RhdGUgaW4gd2hpY2ggdGhlIHByb3Bvc2VkIG9wZXJhdGlvbiBpcyBhbGxvd2VkIHRvIGJlIGV4ZWN1dGVkLicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbm90c3VwcG9ydGVkJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTUlNRSB0eXBlICgnLCByZWNvcmRlckhpbnRzLm1pbWVUeXBlLCAnKSBpcyBub3Qgc3VwcG9ydGVkLicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignc2VjdXJpdHknKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNZWRpYVJlY29yZGVyIHNlY3VyaXR5IGVycm9yJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG9sZGVyIGNvZGUgYmVsb3dcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdPdXRPZk1lbW9yeScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgVUEgaGFzIGV4aGF1c2VkIHRoZSBhdmFpbGFibGUgbWVtb3J5LiBVc2VyIGFnZW50cyBTSE9VTEQgcHJvdmlkZSBhcyBtdWNoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYXMgcG9zc2libGUgaW4gdGhlIG1lc3NhZ2UgYXR0cmlidXRlLicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0lsbGVnYWxTdHJlYW1Nb2RpZmljYXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQSBtb2RpZmljYXRpb24gdG8gdGhlIHN0cmVhbSBoYXMgb2NjdXJyZWQgdGhhdCBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGNvbnRpbnVlIHJlY29yZGluZy4gQW4gZXhhbXBsZSB3b3VsZCBiZSB0aGUgYWRkaXRpb24gb2YgYSBUcmFjayB3aGlsZSByZWNvcmRpbmcgaXMgb2NjdXJyaW5nLiBVc2VyIGFnZW50cyBTSE9VTEQgcHJvdmlkZSBhcyBtdWNoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYXMgcG9zc2libGUgaW4gdGhlIG1lc3NhZ2UgYXR0cmlidXRlLicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ090aGVyUmVjb3JkaW5nRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVXNlZCBmb3IgYW4gZmF0YWwgZXJyb3Igb3RoZXIgdGhhbiB0aG9zZSBsaXN0ZWQgYWJvdmUuIFVzZXIgYWdlbnRzIFNIT1VMRCBwcm92aWRlIGFzIG11Y2ggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhcyBwb3NzaWJsZSBpbiB0aGUgbWVzc2FnZSBhdHRyaWJ1dGUuJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnR2VuZXJpY0Vycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBVQSBjYW5ub3QgcHJvdmlkZSB0aGUgY29kZWMgb3IgcmVjb3JkaW5nIG9wdGlvbiB0aGF0IGhhcyBiZWVuIHJlcXVlc3RlZC4nLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01lZGlhUmVjb3JkZXIgRXJyb3InLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIChmdW5jdGlvbihsb29wZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5tYW51YWxseVN0b3BwZWQgJiYgbWVkaWFSZWNvcmRlciAmJiBtZWRpYVJlY29yZGVyLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy50aW1lc2xpY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIDEwIG1pbnV0ZXMsIGVub3VnaD9cclxuICAgICAgICAgICAgICAgICAgICBtZWRpYVJlY29yZGVyLnN0YXJ0KDEwICogNjAgKiAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wZXIsIDEwMDApO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1lZGlhUmVjb3JkZXIuc3RhdGUgIT09ICdpbmFjdGl2ZScgJiYgbWVkaWFSZWNvcmRlci5zdGF0ZSAhPT0gJ3N0b3BwZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBtZWRpYVJlY29yZGVyLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpbWVTbGljZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdXBkYXRlVGltZVN0YW1wKCk7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuc3RhcnQoY29uZmlnLnRpbWVTbGljZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBpcyA2MCBtaW51dGVzOyBlbm91Z2g/XHJcbiAgICAgICAgICAgIC8vIHVzZSBjb25maWcgPT4ge3RpbWVTbGljZTogMTAwMH0gb3RoZXJ3aXNlXHJcblxyXG4gICAgICAgICAgICBtZWRpYVJlY29yZGVyLnN0YXJ0KDMuNmUrNik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmluaXRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjb25maWcuaW5pdENhbGxiYWNrKCk7IC8vIG9sZCBjb2RlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHRpbWVzdGFtcHMgLSBBcnJheSBvZiB0aW1lIHN0YW1wc1xyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjb25zb2xlLmxvZyhyZWNvcmRlci50aW1lc3RhbXBzKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy50aW1lc3RhbXBzID0gW107XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGltZVN0YW1wKCkge1xyXG4gICAgICAgIHNlbGYudGltZXN0YW1wcy5wdXNoKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcub25UaW1lU3RhbXAgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY29uZmlnLm9uVGltZVN0YW1wKHNlbGYudGltZXN0YW1wc1tzZWxmLnRpbWVzdGFtcHMubGVuZ3RoIC0gMV0sIHNlbGYudGltZXN0YW1wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1pbWVUeXBlKHNlY29uZE9iamVjdCkge1xyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyICYmIG1lZGlhUmVjb3JkZXIubWltZVR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhUmVjb3JkZXIubWltZVR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2Vjb25kT2JqZWN0Lm1pbWVUeXBlIHx8ICd2aWRlby93ZWJtJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3BzIHJlY29yZGluZyBNZWRpYVN0cmVhbS5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24sIHRoYXQgaXMgdXNlZCB0byBwYXNzIHJlY29yZGVkIGJsb2IgYmFjayB0byB0aGUgY2FsbGVlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAqICAgICB2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICBzZWxmLm1hbnVhbGx5U3RvcHBlZCA9IHRydWU7IC8vIHVzZWQgaW5zaWRlIHRoZSBtZWRpYVJlY29yZGVyLm9uZXJyb3JcclxuXHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjb3JkaW5nQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgaWYgKG1lZGlhUmVjb3JkZXIuc3RhdGUgPT09ICdyZWNvcmRpbmcnKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudGltZVNsaWNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ibG9iID0gbmV3IEJsb2IoYXJyYXlPZkJsb2JzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0TWltZVR5cGUoY29uZmlnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5yZWNvcmRpbmdDYWxsYmFjayhzZWxmLmJsb2IpO1xyXG4gICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXVzZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5wYXVzZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyLnN0YXRlID09PSAncmVjb3JkaW5nJykge1xyXG4gICAgICAgICAgICBtZWRpYVJlY29yZGVyLnBhdXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc3VtZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZXN1bWUoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1lZGlhUmVjb3JkZXIuc3RhdGUgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBjdXJyZW50bHkgcmVjb3JkZWQgZGF0YS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGVhclJlY29yZGVkRGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyICYmIG1lZGlhUmVjb3JkZXIuc3RhdGUgPT09ICdyZWNvcmRpbmcnKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3RvcChjbGVhclJlY29yZGVkRGF0YUNCKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsZWFyUmVjb3JkZWREYXRhQ0IoKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXJSZWNvcmRlZERhdGFDQigpIHtcclxuICAgICAgICBhcnJheU9mQmxvYnMgPSBbXTtcclxuICAgICAgICBtZWRpYVJlY29yZGVyID0gbnVsbDtcclxuICAgICAgICBzZWxmLnRpbWVzdGFtcHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWZlcmVuY2UgdG8gXCJNZWRpYVJlY29yZGVyXCIgb2JqZWN0XHJcbiAgICB2YXIgbWVkaWFSZWNvcmRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyB0byBuYXRpdmUgTWVkaWFSZWNvcmRlciBBUElcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB2YXIgaW50ZXJuYWwgPSByZWNvcmRlci5nZXRJbnRlcm5hbFJlY29yZGVyKCk7XHJcbiAgICAgKiBpbnRlcm5hbC5vbmRhdGFhdmFpbGFibGUgPSBmdW5jdGlvbigpIHt9OyAvLyBvdmVycmlkZVxyXG4gICAgICogaW50ZXJuYWwuc3RyZWFtLCBpbnRlcm5hbC5vbnBhdXNlLCBpbnRlcm5hbC5vbnN0b3AsIGV0Yy5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgaW50ZXJuYWwgcmVjb3JkaW5nIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRJbnRlcm5hbFJlY29yZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lZGlhUmVjb3JkZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzTWVkaWFTdHJlYW1BY3RpdmUoKSB7XHJcbiAgICAgICAgaWYgKCdhY3RpdmUnIGluIG1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmICghbWVkaWFTdHJlYW0uYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCdlbmRlZCcgaW4gbWVkaWFTdHJlYW0pIHsgLy8gb2xkIGhhY2tcclxuICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtLmVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvcGVydHkge0Jsb2J9IGJsb2IgLSBSZWNvcmRlZCBkYXRhIGFzIFwiQmxvYlwiIG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbigpIHtcclxuICAgICAqICAgICB2YXIgYmxvYiA9IHJlY29yZGVyLmJsb2I7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5ibG9iID0gbnVsbDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgTWVkaWFSZWNvcmRlciByZWFkb25seSBzdGF0ZS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogdmFyIHN0YXRlID0gcmVjb3JkZXIuZ2V0U3RhdGUoKTtcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgcmVjb3JkaW5nIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnaW5hY3RpdmUnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1lZGlhUmVjb3JkZXIuc3RhdGUgfHwgJ2luYWN0aXZlJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gbGlzdCBvZiBhbGwgcmVjb3JkaW5nIHN0YXRlc1xyXG4gICAgdmFyIGFsbFN0YXRlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IE1lZGlhUmVjb3JkZXIgYWxsIHJlY29yZGluZyBzdGF0ZXMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWFTdHJlYW1SZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciBzdGF0ZSA9IHJlY29yZGVyLmdldEFsbFN0YXRlcygpO1xyXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFsbCByZWNvcmRpbmcgc3RhdGVzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0QWxsU3RhdGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGFsbFN0YXRlcztcclxuICAgIH07XHJcblxyXG4gICAgLy8gaWYgYW55IFRyYWNrIHdpdGhpbiB0aGUgTWVkaWFTdHJlYW0gaXMgbXV0ZWQgb3Igbm90IGVuYWJsZWQgYXQgYW55IHRpbWUsIFxyXG4gICAgLy8gdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHJlY29yZCBibGFjayBmcmFtZXMgXHJcbiAgICAvLyBvciBzaWxlbmNlIHNpbmNlIHRoYXQgaXMgdGhlIGNvbnRlbnQgcHJvZHVjZWQgYnkgdGhlIFRyYWNrXHJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHN0b3BSZWNvcmRpbmcgYXMgc29vbiBhcyBhbnkgc2luZ2xlIHRyYWNrIGVuZHMuXHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jaGVja0ZvckluYWN0aXZlVHJhY2tzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbmZpZy5jaGVja0ZvckluYWN0aXZlVHJhY2tzID0gZmFsc2U7IC8vIGRpc2FibGUgdG8gbWluaW1pemUgQ1BVIHVzYWdlXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8vIHRoaXMgbWV0aG9kIGNoZWNrcyBpZiBtZWRpYSBzdHJlYW0gaXMgc3RvcHBlZFxyXG4gICAgLy8gb3IgaWYgYW55IHRyYWNrIGlzIGVuZGVkLlxyXG4gICAgKGZ1bmN0aW9uIGxvb3BlcigpIHtcclxuICAgICAgICBpZiAoIW1lZGlhUmVjb3JkZXIgfHwgY29uZmlnLmNoZWNrRm9ySW5hY3RpdmVUcmFja3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc01lZGlhU3RyZWFtQWN0aXZlKCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWVkaWFTdHJlYW0gc2VlbXMgc3RvcHBlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnN0b3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VGltZW91dChsb29wZXIsIDEwMDApOyAvLyBjaGVjayBldmVyeSBzZWNvbmRcclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZm9yIGRlYnVnZ2luZ1xyXG4gICAgdGhpcy5uYW1lID0gJ01lZGlhU3RyZWFtUmVjb3JkZXInO1xyXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG59XHJcblxyXG5pZiAodHlwZW9mIFJlY29yZFJUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFJlY29yZFJUQy5NZWRpYVN0cmVhbVJlY29yZGVyID0gTWVkaWFTdHJlYW1SZWNvcmRlcjtcclxufVxyXG5cclxuLy8gc291cmNlIGNvZGUgZnJvbTogaHR0cDovL3R5cGVkYXJyYXkub3JnL3dwLWNvbnRlbnQvcHJvamVjdHMvV2ViQXVkaW9SZWNvcmRlci9zY3JpcHQuanNcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkaWFtb25kL1JlY29yZGVyanMjbGljZW5zZS1taXRcclxuLy8gX19fX19fX19fX19fX19fX19fX19fX1xyXG4vLyBTdGVyZW9BdWRpb1JlY29yZGVyLmpzXHJcblxyXG4vKipcclxuICogU3RlcmVvQXVkaW9SZWNvcmRlciBpcyBhIHN0YW5kYWxvbmUgY2xhc3MgdXNlZCBieSB7QGxpbmsgUmVjb3JkUlRDfSB0byBicmluZyBcInN0ZXJlb1wiIGF1ZGlvLXJlY29yZGluZyBpbiBjaHJvbWUuXHJcbiAqIEBzdW1tYXJ5IEphdmFTY3JpcHQgc3RhbmRhbG9uZSBvYmplY3QgZm9yIHN0ZXJlbyBhdWRpbyByZWNvcmRpbmcuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBTdGVyZW9BdWRpb1JlY29yZGVyXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcmVjb3JkZXIgPSBuZXcgU3RlcmVvQXVkaW9SZWNvcmRlcihNZWRpYVN0cmVhbSwge1xyXG4gKiAgICAgc2FtcGxlUmF0ZTogNDQxMDAsXHJcbiAqICAgICBidWZmZXJTaXplOiA0MDk2XHJcbiAqIH0pO1xyXG4gKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAqICAgICB2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gKiB9KTtcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbSAtIE1lZGlhU3RyZWFtIG9iamVjdCBmZXRjaGVkIHVzaW5nIGdldFVzZXJNZWRpYSBBUEkgb3IgZ2VuZXJhdGVkIHVzaW5nIGNhcHR1cmVTdHJlYW1VbnRpbEVuZGVkIG9yIFdlYkF1ZGlvIEFQSS5cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIHtzYW1wbGVSYXRlOiA0NDEwMCwgYnVmZmVyU2l6ZTogNDA5NiwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzOiAxLCBldGMufVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFN0ZXJlb0F1ZGlvUmVjb3JkZXIobWVkaWFTdHJlYW0sIGNvbmZpZykge1xyXG4gICAgaWYgKCFnZXRUcmFja3MobWVkaWFTdHJlYW0sICdhdWRpbycpLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93ICdZb3VyIHN0cmVhbSBoYXMgbm8gYXVkaW8gdHJhY2tzLic7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyB2YXJpYWJsZXNcclxuICAgIHZhciBsZWZ0Y2hhbm5lbCA9IFtdO1xyXG4gICAgdmFyIHJpZ2h0Y2hhbm5lbCA9IFtdO1xyXG4gICAgdmFyIHJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgdmFyIHJlY29yZGluZ0xlbmd0aCA9IDA7XHJcbiAgICB2YXIganNBdWRpb05vZGU7XHJcblxyXG4gICAgdmFyIG51bWJlck9mQXVkaW9DaGFubmVscyA9IDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc2FtcGxlIHJhdGVzIHN1Y2ggYXMgOEsgb3IgMTZLLiBSZWZlcmVuY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4OTc3MTM2LzU1MjE4MlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2lyZWRTYW1wUmF0ZSAtIERlc2lyZWQgQml0cyBwZXIgc2FtcGxlICogMTAwMFxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHZhciByZWNvcmRlciA9IFN0ZXJlb0F1ZGlvUmVjb3JkZXIobWVkaWFTdHJlYW0sIHtcclxuICAgICAqICAgZGVzaXJlZFNhbXBSYXRlOiAxNiAqIDEwMDAgLy8gYml0cy1wZXItc2FtcGxlICogMTAwMFxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHZhciBkZXNpcmVkU2FtcFJhdGUgPSBjb25maWcuZGVzaXJlZFNhbXBSYXRlO1xyXG5cclxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuICAgIGlmIChjb25maWcubGVmdENoYW5uZWwgPT09IHRydWUpIHtcclxuICAgICAgICBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcubnVtYmVyT2ZBdWRpb0NoYW5uZWxzID09PSAxKSB7XHJcbiAgICAgICAgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzID0gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW51bWJlck9mQXVkaW9DaGFubmVscyB8fCBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPCAxKSB7XHJcbiAgICAgICAgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzID0gMjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGVyZW9BdWRpb1JlY29yZGVyIGlzIHNldCB0byByZWNvcmQgbnVtYmVyIG9mIGNoYW5uZWxzOiAnICsgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBhbnkgVHJhY2sgd2l0aGluIHRoZSBNZWRpYVN0cmVhbSBpcyBtdXRlZCBvciBub3QgZW5hYmxlZCBhdCBhbnkgdGltZSwgXHJcbiAgICAvLyB0aGUgYnJvd3NlciB3aWxsIG9ubHkgcmVjb3JkIGJsYWNrIGZyYW1lcyBcclxuICAgIC8vIG9yIHNpbGVuY2Ugc2luY2UgdGhhdCBpcyB0aGUgY29udGVudCBwcm9kdWNlZCBieSB0aGUgVHJhY2tcclxuICAgIC8vIHNvIHdlIG5lZWQgdG8gc3RvcFJlY29yZGluZyBhcyBzb29uIGFzIGFueSBzaW5nbGUgdHJhY2sgZW5kcy5cclxuICAgIGlmICh0eXBlb2YgY29uZmlnLmNoZWNrRm9ySW5hY3RpdmVUcmFja3MgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uZmlnLmNoZWNrRm9ySW5hY3RpdmVUcmFja3MgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTWVkaWFTdHJlYW1BY3RpdmUoKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5jaGVja0ZvckluYWN0aXZlVHJhY2tzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyBhbHdheXMgcmV0dXJuIFwidHJ1ZVwiXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCdhY3RpdmUnIGluIG1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmICghbWVkaWFTdHJlYW0uYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCdlbmRlZCcgaW4gbWVkaWFTdHJlYW0pIHsgLy8gb2xkIGhhY2tcclxuICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtLmVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZWNvcmRzIE1lZGlhU3RyZWFtLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWNvcmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoaXNNZWRpYVN0cmVhbUFjdGl2ZSgpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnUGxlYXNlIG1ha2Ugc3VyZSBNZWRpYVN0cmVhbSBpcyBhY3RpdmUuJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc2V0VmFyaWFibGVzKCk7XHJcblxyXG4gICAgICAgIGlzQXVkaW9Qcm9jZXNzU3RhcnRlZCA9IGlzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgcmVjb3JkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudGltZVNsaWNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBsb29wZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlTGVmdFJpZ2h0QnVmZmVycyhjb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBdWRpb0J1ZmZlcnMoY29uZmlnLCBjYikge1xyXG4gICAgICAgICAgICB2YXIgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzID0gY29uZmlnLm51bWJlck9mQXVkaW9DaGFubmVscztcclxuXHJcbiAgICAgICAgICAgIC8vIHRvZG86IFwic2xpY2UoMClcIiAtLS0gaXMgaXQgY2F1c2VzIGxvb3A/IFNob3VsZCBiZSByZW1vdmVkP1xyXG4gICAgICAgICAgICB2YXIgbGVmdEJ1ZmZlcnMgPSBjb25maWcubGVmdEJ1ZmZlcnMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodEJ1ZmZlcnMgPSBjb25maWcucmlnaHRCdWZmZXJzLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IGNvbmZpZy5zYW1wbGVSYXRlO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxJbnRlcmxlYXZlZExlbmd0aCA9IGNvbmZpZy5pbnRlcm5hbEludGVybGVhdmVkTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZGVzaXJlZFNhbXBSYXRlID0gY29uZmlnLmRlc2lyZWRTYW1wUmF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRCdWZmZXJzID0gbWVyZ2VCdWZmZXJzKGxlZnRCdWZmZXJzLCBpbnRlcm5hbEludGVybGVhdmVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0QnVmZmVycyA9IG1lcmdlQnVmZmVycyhyaWdodEJ1ZmZlcnMsIGludGVybmFsSW50ZXJsZWF2ZWRMZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkU2FtcFJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0QnVmZmVycyA9IGludGVycG9sYXRlQXJyYXkobGVmdEJ1ZmZlcnMsIGRlc2lyZWRTYW1wUmF0ZSwgc2FtcGxlUmF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRCdWZmZXJzID0gaW50ZXJwb2xhdGVBcnJheShyaWdodEJ1ZmZlcnMsIGRlc2lyZWRTYW1wUmF0ZSwgc2FtcGxlUmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRCdWZmZXJzID0gbWVyZ2VCdWZmZXJzKGxlZnRCdWZmZXJzLCBpbnRlcm5hbEludGVybGVhdmVkTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVzaXJlZFNhbXBSYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdEJ1ZmZlcnMgPSBpbnRlcnBvbGF0ZUFycmF5KGxlZnRCdWZmZXJzLCBkZXNpcmVkU2FtcFJhdGUsIHNhbXBsZVJhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgc2FtcGxlIHJhdGUgYXMgZGVzaXJlZCBzYW1wbGUgcmF0ZVxyXG4gICAgICAgICAgICBpZiAoZGVzaXJlZFNhbXBSYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlID0gZGVzaXJlZFNhbXBSYXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBmb3IgY2hhbmdpbmcgdGhlIHNhbXBsaW5nIHJhdGUsIHJlZmVyZW5jZTpcclxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjg5NzcxMzYvNTUyMTgyXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkoZGF0YSwgbmV3U2FtcGxlUmF0ZSwgb2xkU2FtcGxlUmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpdENvdW50ID0gTWF0aC5yb3VuZChkYXRhLmxlbmd0aCAqIChuZXdTYW1wbGVSYXRlIC8gb2xkU2FtcGxlUmF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJpbmdGYWN0b3IgPSBOdW1iZXIoKGRhdGEubGVuZ3RoIC0gMSkgLyAoZml0Q291bnQgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICBuZXdEYXRhWzBdID0gZGF0YVswXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZml0Q291bnQgLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gaSAqIHNwcmluZ0ZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gTnVtYmVyKE1hdGguZmxvb3IodG1wKSkudG9GaXhlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IE51bWJlcihNYXRoLmNlaWwodG1wKSkudG9GaXhlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdFBvaW50ID0gdG1wIC0gYmVmb3JlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBsaW5lYXJJbnRlcnBvbGF0ZShkYXRhW2JlZm9yZV0sIGRhdGFbYWZ0ZXJdLCBhdFBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld0RhdGFbZml0Q291bnQgLSAxXSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEYXRhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lYXJJbnRlcnBvbGF0ZShiZWZvcmUsIGFmdGVyLCBhdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlICsgKGFmdGVyIC0gYmVmb3JlKSAqIGF0UG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1lcmdlQnVmZmVycyhjaGFubmVsQnVmZmVyLCByTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0NjRBcnJheShyTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxuZyA9IGNoYW5uZWxCdWZmZXIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG5nOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gY2hhbm5lbEJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGJ1ZmZlciwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlcmxlYXZlKGxlZnRDaGFubmVsLCByaWdodENoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBsZWZ0Q2hhbm5lbC5sZW5ndGggKyByaWdodENoYW5uZWwubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQ2NEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4KytdID0gbGVmdENoYW5uZWxbaW5wdXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4KytdID0gcmlnaHRDaGFubmVsW2lucHV0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdyaXRlVVRGQnl0ZXModmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsbmcgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbmc7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgaSwgc3RyaW5nLmNoYXJDb2RlQXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlIGJvdGggY2hhbm5lbHMgdG9nZXRoZXJcclxuICAgICAgICAgICAgdmFyIGludGVybGVhdmVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKG51bWJlck9mQXVkaW9DaGFubmVscyA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlKGxlZnRCdWZmZXJzLCByaWdodEJ1ZmZlcnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZBdWRpb0NoYW5uZWxzID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZCA9IGxlZnRCdWZmZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW50ZXJsZWF2ZWRMZW5ndGggPSBpbnRlcmxlYXZlZC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgd2F2IGZpbGVcclxuICAgICAgICAgICAgdmFyIHJlc3VsdGluZ0J1ZmZlckxlbmd0aCA9IDQ0ICsgaW50ZXJsZWF2ZWRMZW5ndGggKiAyO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihyZXN1bHRpbmdCdWZmZXJMZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJJRkYgY2h1bmsgZGVzY3JpcHRvci9pZGVudGlmaWVyIFxyXG4gICAgICAgICAgICB3cml0ZVVURkJ5dGVzKHZpZXcsIDAsICdSSUZGJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBSSUZGIGNodW5rIGxlbmd0aFxyXG4gICAgICAgICAgICAvLyBjaGFuZ2VkIFwiNDRcIiB0byBcIjM2XCIgdmlhICM0MDFcclxuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBpbnRlcmxlYXZlZExlbmd0aCAqIDIsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gUklGRiB0eXBlIFxyXG4gICAgICAgICAgICB3cml0ZVVURkJ5dGVzKHZpZXcsIDgsICdXQVZFJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBmb3JtYXQgY2h1bmsgaWRlbnRpZmllciBcclxuICAgICAgICAgICAgLy8gRk1UIHN1Yi1jaHVua1xyXG4gICAgICAgICAgICB3cml0ZVVURkJ5dGVzKHZpZXcsIDEyLCAnZm10ICcpO1xyXG5cclxuICAgICAgICAgICAgLy8gZm9ybWF0IGNodW5rIGxlbmd0aCBcclxuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMTYsIDE2LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNhbXBsZSBmb3JtYXQgKHJhdylcclxuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYoMjAsIDEsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gc3RlcmVvICgyIGNoYW5uZWxzKVxyXG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNigyMiwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNhbXBsZSByYXRlIFxyXG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigyNCwgc2FtcGxlUmF0ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBieXRlIHJhdGUgKHNhbXBsZSByYXRlICogYmxvY2sgYWxpZ24pXHJcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDI4LCBzYW1wbGVSYXRlICogbnVtYmVyT2ZBdWRpb0NoYW5uZWxzICogMiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpIFxyXG4gICAgICAgICAgICB2aWV3LnNldFVpbnQxNigzMiwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzICogMiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBiaXRzIHBlciBzYW1wbGUgXHJcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDE2KDM0LCAxNiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBkYXRhIHN1Yi1jaHVua1xyXG4gICAgICAgICAgICAvLyBkYXRhIGNodW5rIGlkZW50aWZpZXIgXHJcbiAgICAgICAgICAgIHdyaXRlVVRGQnl0ZXModmlldywgMzYsICdkYXRhJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBkYXRhIGNodW5rIGxlbmd0aCBcclxuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoNDAsIGludGVybGVhdmVkTGVuZ3RoICogMiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyB3cml0ZSB0aGUgUENNIHNhbXBsZXNcclxuICAgICAgICAgICAgdmFyIGxuZyA9IGludGVybGVhdmVkTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSA0NDtcclxuICAgICAgICAgICAgdmFyIHZvbHVtZSA9IDE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG5nOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuc2V0SW50MTYoaW5kZXgsIGludGVybGVhdmVkW2ldICogKDB4N0ZGRiAqIHZvbHVtZSksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcclxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29uZmlnLm5vV29ya2VyKSB7XHJcbiAgICAgICAgICAgIG1lcmdlQXVkaW9CdWZmZXJzKGNvbmZpZywgZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5idWZmZXIsIGRhdGEudmlldyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIHdlYldvcmtlciA9IHByb2Nlc3NJbldlYldvcmtlcihtZXJnZUF1ZGlvQnVmZmVycyk7XHJcblxyXG4gICAgICAgIHdlYldvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhldmVudC5kYXRhLmJ1ZmZlciwgZXZlbnQuZGF0YS52aWV3KTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod2ViV29ya2VyLndvcmtlclVSTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBraWxsIHdlYndvcmtlciAob3IgQ2hyb21lIHdpbGwga2lsbCB5b3VyIHBhZ2UgYWZ0ZXIgfjI1IGNhbGxzKVxyXG4gICAgICAgICAgICB3ZWJXb3JrZXIudGVybWluYXRlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2ViV29ya2VyLnBvc3RNZXNzYWdlKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0luV2ViV29ya2VyKF9mdW5jdGlvbikge1xyXG4gICAgICAgIHZhciB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtfZnVuY3Rpb24udG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgJzt0aGlzLm9ubWVzc2FnZSA9ICBmdW5jdGlvbiAoZWVlKSB7JyArIF9mdW5jdGlvbi5uYW1lICsgJyhlZWUuZGF0YSk7fSdcclxuICAgICAgICBdLCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcclxuICAgICAgICB3b3JrZXIud29ya2VyVVJMID0gd29ya2VyVVJMO1xyXG4gICAgICAgIHJldHVybiB3b3JrZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzdG9wcyByZWNvcmRpbmcgTWVkaWFTdHJlYW0uXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uLCB0aGF0IGlzIHVzZWQgdG8gcGFzcyByZWNvcmRlZCBibG9iIGJhY2sgdG8gdGhlIGNhbGxlZS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBTdGVyZW9BdWRpb1JlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAgICAgKiAgICAgdmlkZW8uc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgLy8gc3RvcCByZWNvcmRpbmdcclxuICAgICAgICByZWNvcmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgbWVyZ2VMZWZ0UmlnaHRCdWZmZXJzKHtcclxuICAgICAgICAgICAgZGVzaXJlZFNhbXBSYXRlOiBkZXNpcmVkU2FtcFJhdGUsXHJcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXHJcbiAgICAgICAgICAgIG51bWJlck9mQXVkaW9DaGFubmVsczogbnVtYmVyT2ZBdWRpb0NoYW5uZWxzLFxyXG4gICAgICAgICAgICBpbnRlcm5hbEludGVybGVhdmVkTGVuZ3RoOiByZWNvcmRpbmdMZW5ndGgsXHJcbiAgICAgICAgICAgIGxlZnRCdWZmZXJzOiBsZWZ0Y2hhbm5lbCxcclxuICAgICAgICAgICAgcmlnaHRCdWZmZXJzOiBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDEgPyBbXSA6IHJpZ2h0Y2hhbm5lbCxcclxuICAgICAgICAgICAgbm9Xb3JrZXI6IGNvbmZpZy5ub1dvcmtlclxyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGJ1ZmZlciwgdmlldykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtCbG9ifSBibG9iIC0gVGhlIHJlY29yZGVkIGJsb2Igb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgU3RlcmVvQXVkaW9SZWNvcmRlclxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAqICAgICB2YXIgYmxvYiA9IHJlY29yZGVyLmJsb2I7XHJcbiAgICAgICAgICAgICAqIH0pO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc2VsZi5ibG9iID0gbmV3IEJsb2IoW3ZpZXddLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8vd2F2J1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgcmVjb3JkZWQgYnVmZmVyIG9iamVjdC5cclxuICAgICAgICAgICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgKiAgICAgdmFyIGJ1ZmZlciA9IHJlY29yZGVyLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICogfSk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZWxmLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0RhdGFWaWV3fSB2aWV3IC0gVGhlIHJlY29yZGVkIGRhdGEtdmlldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBTdGVyZW9BdWRpb1JlY29yZGVyXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqIHJlY29yZGVyLnN0b3AoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICogICAgIHZhciB2aWV3ID0gcmVjb3JkZXIudmlldztcclxuICAgICAgICAgICAgICogfSk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZWxmLnZpZXcgPSB2aWV3O1xyXG5cclxuICAgICAgICAgICAgc2VsZi5zYW1wbGVSYXRlID0gZGVzaXJlZFNhbXBSYXRlIHx8IHNhbXBsZVJhdGU7XHJcbiAgICAgICAgICAgIHNlbGYuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XHJcblxyXG4gICAgICAgICAgICAvLyByZWNvcmRlZCBhdWRpbyBsZW5ndGhcclxuICAgICAgICAgICAgc2VsZi5sZW5ndGggPSByZWNvcmRpbmdMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpc0F1ZGlvUHJvY2Vzc1N0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VsZi5ibG9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodHlwZW9mIFJlY29yZFJUQy5TdG9yYWdlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIFJlY29yZFJUQy5TdG9yYWdlID0ge1xyXG4gICAgICAgICAgICBBdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjogbnVsbCxcclxuICAgICAgICAgICAgQXVkaW9Db250ZXh0OiB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghUmVjb3JkUlRDLlN0b3JhZ2UuQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgfHwgUmVjb3JkUlRDLlN0b3JhZ2UuQXVkaW9Db250ZXh0Q29uc3RydWN0b3Iuc3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgUmVjb3JkUlRDLlN0b3JhZ2UuQXVkaW9Db250ZXh0Q29uc3RydWN0b3IgPSBuZXcgUmVjb3JkUlRDLlN0b3JhZ2UuQXVkaW9Db250ZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbnRleHQgPSBSZWNvcmRSVEMuU3RvcmFnZS5BdWRpb0NvbnRleHRDb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAvLyBjcmVhdGVzIGFuIGF1ZGlvIG5vZGUgZnJvbSB0aGUgbWljcm9waG9uZSBpbmNvbWluZyBzdHJlYW1cclxuICAgIHZhciBhdWRpb0lucHV0ID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShtZWRpYVN0cmVhbSk7XHJcblxyXG4gICAgdmFyIGxlZ2FsQnVmZmVyVmFsdWVzID0gWzAsIDI1NiwgNTEyLCAxMDI0LCAyMDQ4LCA0MDk2LCA4MTkyLCAxNjM4NF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGcm9tIHRoZSBzcGVjOiBUaGlzIHZhbHVlIGNvbnRyb2xzIGhvdyBmcmVxdWVudGx5IHRoZSBhdWRpb3Byb2Nlc3MgZXZlbnQgaXNcclxuICAgICAqIGRpc3BhdGNoZWQgYW5kIGhvdyBtYW55IHNhbXBsZS1mcmFtZXMgbmVlZCB0byBiZSBwcm9jZXNzZWQgZWFjaCBjYWxsLlxyXG4gICAgICogTG93ZXIgdmFsdWVzIGZvciBidWZmZXIgc2l6ZSB3aWxsIHJlc3VsdCBpbiBhIGxvd2VyIChiZXR0ZXIpIGxhdGVuY3kuXHJcbiAgICAgKiBIaWdoZXIgdmFsdWVzIHdpbGwgYmUgbmVjZXNzYXJ5IHRvIGF2b2lkIGF1ZGlvIGJyZWFrdXAgYW5kIGdsaXRjaGVzXHJcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyIChpbiBzYW1wbGUtZnJhbWVzKSB3aGljaCBuZWVkcyB0b1xyXG4gICAgICogYmUgcHJvY2Vzc2VkIGVhY2ggdGltZSBvbnByb2Nlc3NhdWRpbyBpcyBjYWxsZWQuXHJcbiAgICAgKiBMZWdhbCB2YWx1ZXMgYXJlICgyNTYsIDUxMiwgMTAyNCwgMjA0OCwgNDA5NiwgODE5MiwgMTYzODQpLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJ1ZmZlclNpemUgLSBCdWZmZXItc2l6ZSBmb3IgaG93IGZyZXF1ZW50bHkgdGhlIGF1ZGlvcHJvY2VzcyBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlciA9IG5ldyBTdGVyZW9BdWRpb1JlY29yZGVyKG1lZGlhU3RyZWFtLCB7XHJcbiAgICAgKiAgICAgYnVmZmVyU2l6ZTogNDA5NlxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyBcIjBcIiBtZWFucywgbGV0IGNocm9tZSBkZWNpZGUgdGhlIG1vc3QgYWNjdXJhdGUgYnVmZmVyLXNpemUgZm9yIGN1cnJlbnQgcGxhdGZvcm0uXHJcbiAgICB2YXIgYnVmZmVyU2l6ZSA9IHR5cGVvZiBjb25maWcuYnVmZmVyU2l6ZSA9PT0gJ3VuZGVmaW5lZCcgPyA0MDk2IDogY29uZmlnLmJ1ZmZlclNpemU7XHJcblxyXG4gICAgaWYgKGxlZ2FsQnVmZmVyVmFsdWVzLmluZGV4T2YoYnVmZmVyU2l6ZSkgPT09IC0xKSB7XHJcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xlZ2FsIHZhbHVlcyBmb3IgYnVmZmVyLXNpemUgYXJlICcgKyBKU09OLnN0cmluZ2lmeShsZWdhbEJ1ZmZlclZhbHVlcywgbnVsbCwgJ1xcdCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnRleHQuY3JlYXRlSmF2YVNjcmlwdE5vZGUpIHtcclxuICAgICAgICBqc0F1ZGlvTm9kZSA9IGNvbnRleHQuY3JlYXRlSmF2YVNjcmlwdE5vZGUoYnVmZmVyU2l6ZSwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzLCBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMpO1xyXG4gICAgfSBlbHNlIGlmIChjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcikge1xyXG4gICAgICAgIGpzQXVkaW9Ob2RlID0gY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoYnVmZmVyU2l6ZSwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzLCBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyAnV2ViQXVkaW8gQVBJIGhhcyBubyBzdXBwb3J0IG9uIHRoaXMgYnJvd3Nlci4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbm5lY3QgdGhlIHN0cmVhbSB0byB0aGUgc2NyaXB0IHByb2Nlc3NvclxyXG4gICAgYXVkaW9JbnB1dC5jb25uZWN0KGpzQXVkaW9Ob2RlKTtcclxuXHJcbiAgICBpZiAoIWNvbmZpZy5idWZmZXJTaXplKSB7XHJcbiAgICAgICAgYnVmZmVyU2l6ZSA9IGpzQXVkaW9Ob2RlLmJ1ZmZlclNpemU7IC8vIGRldmljZSBidWZmZXItc2l6ZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNhbXBsZSByYXRlIChpbiBzYW1wbGUtZnJhbWVzIHBlciBzZWNvbmQpIGF0IHdoaWNoIHRoZVxyXG4gICAgICogQXVkaW9Db250ZXh0IGhhbmRsZXMgYXVkaW8uIEl0IGlzIGFzc3VtZWQgdGhhdCBhbGwgQXVkaW9Ob2Rlc1xyXG4gICAgICogaW4gdGhlIGNvbnRleHQgcnVuIGF0IHRoaXMgcmF0ZS4gSW4gbWFraW5nIHRoaXMgYXNzdW1wdGlvbixcclxuICAgICAqIHNhbXBsZS1yYXRlIGNvbnZlcnRlcnMgb3IgXCJ2YXJpc3BlZWRcIiBwcm9jZXNzb3JzIGFyZSBub3Qgc3VwcG9ydGVkXHJcbiAgICAgKiBpbiByZWFsLXRpbWUgcHJvY2Vzc2luZy5cclxuICAgICAqIFRoZSBzYW1wbGVSYXRlIHBhcmFtZXRlciBkZXNjcmliZXMgdGhlIHNhbXBsZS1yYXRlIG9mIHRoZVxyXG4gICAgICogbGluZWFyIFBDTSBhdWRpbyBkYXRhIGluIHRoZSBidWZmZXIgaW4gc2FtcGxlLWZyYW1lcyBwZXIgc2Vjb25kLlxyXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IHNhbXBsZS1yYXRlcyBpbiBhdCBsZWFzdFxyXG4gICAgICogdGhlIHJhbmdlIDIyMDUwIHRvIDk2MDAwLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNhbXBsZVJhdGUgLSBCdWZmZXItc2l6ZSBmb3IgaG93IGZyZXF1ZW50bHkgdGhlIGF1ZGlvcHJvY2VzcyBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlciA9IG5ldyBTdGVyZW9BdWRpb1JlY29yZGVyKG1lZGlhU3RyZWFtLCB7XHJcbiAgICAgKiAgICAgc2FtcGxlUmF0ZTogNDQxMDBcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICB2YXIgc2FtcGxlUmF0ZSA9IHR5cGVvZiBjb25maWcuc2FtcGxlUmF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25maWcuc2FtcGxlUmF0ZSA6IGNvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMDtcclxuXHJcbiAgICBpZiAoc2FtcGxlUmF0ZSA8IDIyMDUwIHx8IHNhbXBsZVJhdGUgPiA5NjAwMCkge1xyXG4gICAgICAgIC8vIFJlZjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjYzMDM5MTgvNTUyMTgyXHJcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NhbXBsZS1yYXRlIG11c3QgYmUgdW5kZXIgcmFuZ2UgMjIwNTAgYW5kIDk2MDAwLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgIGlmIChjb25maWcuZGVzaXJlZFNhbXBSYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEZXNpcmVkIHNhbXBsZS1yYXRlOiAnICsgY29uZmlnLmRlc2lyZWRTYW1wUmF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXVzZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5wYXVzZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc3VtZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFN0ZXJlb0F1ZGlvUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZXN1bWUoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoaXNNZWRpYVN0cmVhbUFjdGl2ZSgpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnUGxlYXNlIG1ha2Ugc3VyZSBNZWRpYVN0cmVhbSBpcyBhY3RpdmUuJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2VlbXMgcmVjb3JkaW5nIGhhcyBiZWVuIHJlc3RhcnRlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlY29yZCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBjdXJyZW50bHkgcmVjb3JkZWQgZGF0YS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBTdGVyZW9BdWRpb1JlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGVhclJlY29yZGVkRGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbmZpZy5jaGVja0ZvckluYWN0aXZlVHJhY2tzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChyZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKGNsZWFyUmVjb3JkZWREYXRhQ0IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2xlYXJSZWNvcmRlZERhdGFDQigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXNldFZhcmlhYmxlcygpIHtcclxuICAgICAgICBsZWZ0Y2hhbm5lbCA9IFtdO1xyXG4gICAgICAgIHJpZ2h0Y2hhbm5lbCA9IFtdO1xyXG4gICAgICAgIHJlY29yZGluZ0xlbmd0aCA9IDA7XHJcbiAgICAgICAgaXNBdWRpb1Byb2Nlc3NTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICBjb250ZXh0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgc2VsZi5sZWZ0Y2hhbm5lbCA9IGxlZnRjaGFubmVsO1xyXG4gICAgICAgIHNlbGYucmlnaHRjaGFubmVsID0gcmlnaHRjaGFubmVsO1xyXG4gICAgICAgIHNlbGYubnVtYmVyT2ZBdWRpb0NoYW5uZWxzID0gbnVtYmVyT2ZBdWRpb0NoYW5uZWxzO1xyXG4gICAgICAgIHNlbGYuZGVzaXJlZFNhbXBSYXRlID0gZGVzaXJlZFNhbXBSYXRlO1xyXG4gICAgICAgIHNlbGYuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XHJcbiAgICAgICAgc2VsZi5yZWNvcmRpbmdMZW5ndGggPSByZWNvcmRpbmdMZW5ndGg7XHJcblxyXG4gICAgICAgIGludGVydmFsc0Jhc2VkQnVmZmVycyA9IHtcclxuICAgICAgICAgICAgbGVmdDogW10sXHJcbiAgICAgICAgICAgIHJpZ2h0OiBbXSxcclxuICAgICAgICAgICAgcmVjb3JkaW5nTGVuZ3RoOiAwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhclJlY29yZGVkRGF0YUNCKCkge1xyXG4gICAgICAgIGlmIChqc0F1ZGlvTm9kZSkge1xyXG4gICAgICAgICAgICBqc0F1ZGlvTm9kZS5vbmF1ZGlvcHJvY2VzcyA9IG51bGw7XHJcbiAgICAgICAgICAgIGpzQXVkaW9Ob2RlLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAganNBdWRpb05vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGF1ZGlvSW5wdXQpIHtcclxuICAgICAgICAgICAgYXVkaW9JbnB1dC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGF1ZGlvSW5wdXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzZXRWYXJpYWJsZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICB0aGlzLm5hbWUgPSAnU3RlcmVvQXVkaW9SZWNvcmRlcic7XHJcbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGlzQXVkaW9Qcm9jZXNzU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uQXVkaW9Qcm9jZXNzRGF0YUF2YWlsYWJsZShlKSB7XHJcbiAgICAgICAgaWYgKGlzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc01lZGlhU3RyZWFtQWN0aXZlKCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWVkaWFTdHJlYW0gc2VlbXMgc3RvcHBlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBqc0F1ZGlvTm9kZS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFyZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGF1ZGlvSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvSW5wdXQuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgYXVkaW9JbnB1dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIFwib25hdWRpb3Byb2Nlc3NcIiBldmVudCdzIGZpcnN0IGludm9jYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCB7ZnVuY3Rpb259IG9uQXVkaW9Qcm9jZXNzU3RhcnRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBTdGVyZW9BdWRpb1JlY29yZGVyXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiByZWNvcmRlci5vbkF1ZGlvUHJvY2Vzc1N0YXJ0ZWQ6IGZ1bmN0aW9uKCkgeyB9O1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICghaXNBdWRpb1Byb2Nlc3NTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIGlzQXVkaW9Qcm9jZXNzU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcub25BdWRpb1Byb2Nlc3NTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcub25BdWRpb1Byb2Nlc3NTdGFydGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcuaW5pdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuaW5pdENhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsZWZ0ID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcclxuXHJcbiAgICAgICAgLy8gd2UgY2xvbmUgdGhlIHNhbXBsZXNcclxuICAgICAgICB2YXIgY2hMZWZ0ID0gbmV3IEZsb2F0MzJBcnJheShsZWZ0KTtcclxuICAgICAgICBsZWZ0Y2hhbm5lbC5wdXNoKGNoTGVmdCk7XHJcblxyXG4gICAgICAgIGlmIChudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDIpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgxKTtcclxuICAgICAgICAgICAgdmFyIGNoUmlnaHQgPSBuZXcgRmxvYXQzMkFycmF5KHJpZ2h0KTtcclxuICAgICAgICAgICAgcmlnaHRjaGFubmVsLnB1c2goY2hSaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZWNvcmRpbmdMZW5ndGggKz0gYnVmZmVyU2l6ZTtcclxuXHJcbiAgICAgICAgLy8gZXhwb3J0IHJhdyBQQ01cclxuICAgICAgICBzZWxmLnJlY29yZGluZ0xlbmd0aCA9IHJlY29yZGluZ0xlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudGltZVNsaWNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpbnRlcnZhbHNCYXNlZEJ1ZmZlcnMucmVjb3JkaW5nTGVuZ3RoICs9IGJ1ZmZlclNpemU7XHJcbiAgICAgICAgICAgIGludGVydmFsc0Jhc2VkQnVmZmVycy5sZWZ0LnB1c2goY2hMZWZ0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsc0Jhc2VkQnVmZmVycy5yaWdodC5wdXNoKGNoUmlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGpzQXVkaW9Ob2RlLm9uYXVkaW9wcm9jZXNzID0gb25BdWRpb1Byb2Nlc3NEYXRhQXZhaWxhYmxlO1xyXG5cclxuICAgIC8vIHRvIHByZXZlbnQgc2VsZiBhdWRpbyB0byBiZSBjb25uZWN0ZWQgd2l0aCBzcGVha2Vyc1xyXG4gICAgaWYgKGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbikge1xyXG4gICAgICAgIGpzQXVkaW9Ob2RlLmNvbm5lY3QoY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBqc0F1ZGlvTm9kZS5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4cG9ydCByYXcgUENNXHJcbiAgICB0aGlzLmxlZnRjaGFubmVsID0gbGVmdGNoYW5uZWw7XHJcbiAgICB0aGlzLnJpZ2h0Y2hhbm5lbCA9IHJpZ2h0Y2hhbm5lbDtcclxuICAgIHRoaXMubnVtYmVyT2ZBdWRpb0NoYW5uZWxzID0gbnVtYmVyT2ZBdWRpb0NoYW5uZWxzO1xyXG4gICAgdGhpcy5kZXNpcmVkU2FtcFJhdGUgPSBkZXNpcmVkU2FtcFJhdGU7XHJcbiAgICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xyXG4gICAgc2VsZi5yZWNvcmRpbmdMZW5ndGggPSByZWNvcmRpbmdMZW5ndGg7XHJcblxyXG4gICAgLy8gaGVscGVyIGZvciBpbnRlcnZhbHMgYmFzZWQgYmxvYnNcclxuICAgIHZhciBpbnRlcnZhbHNCYXNlZEJ1ZmZlcnMgPSB7XHJcbiAgICAgICAgbGVmdDogW10sXHJcbiAgICAgICAgcmlnaHQ6IFtdLFxyXG4gICAgICAgIHJlY29yZGluZ0xlbmd0aDogMFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0aGlzIGxvb3BlciBpcyB1c2VkIHRvIHN1cHBvcnQgaW50ZXJ2YWxzIGJhc2VkIGJsb2JzICh2aWEgdGltZVNsaWNlK29uZGF0YWF2YWlsYWJsZSlcclxuICAgIGZ1bmN0aW9uIGxvb3BlcigpIHtcclxuICAgICAgICBpZiAoIXJlY29yZGluZyB8fCB0eXBlb2YgY29uZmlnLm9uZGF0YWF2YWlsYWJsZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY29uZmlnLnRpbWVTbGljZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGludGVydmFsc0Jhc2VkQnVmZmVycy5sZWZ0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtZXJnZUxlZnRSaWdodEJ1ZmZlcnMoe1xyXG4gICAgICAgICAgICAgICAgZGVzaXJlZFNhbXBSYXRlOiBkZXNpcmVkU2FtcFJhdGUsXHJcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlLFxyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzOiBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMsXHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEludGVybGVhdmVkTGVuZ3RoOiBpbnRlcnZhbHNCYXNlZEJ1ZmZlcnMucmVjb3JkaW5nTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbGVmdEJ1ZmZlcnM6IGludGVydmFsc0Jhc2VkQnVmZmVycy5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHRCdWZmZXJzOiBudW1iZXJPZkF1ZGlvQ2hhbm5lbHMgPT09IDEgPyBbXSA6IGludGVydmFsc0Jhc2VkQnVmZmVycy5yaWdodFxyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihidWZmZXIsIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3ZpZXddLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F1ZGlvL3dhdidcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLm9uZGF0YWF2YWlsYWJsZShibG9iKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3BlciwgY29uZmlnLnRpbWVTbGljZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJ2YWxzQmFzZWRCdWZmZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogW10sXHJcbiAgICAgICAgICAgICAgICByaWdodDogW10sXHJcbiAgICAgICAgICAgICAgICByZWNvcmRpbmdMZW5ndGg6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3BlciwgY29uZmlnLnRpbWVTbGljZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5pZiAodHlwZW9mIFJlY29yZFJUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFJlY29yZFJUQy5TdGVyZW9BdWRpb1JlY29yZGVyID0gU3RlcmVvQXVkaW9SZWNvcmRlcjtcclxufVxyXG5cclxuLy8gX19fX19fX19fX19fX19fX19cclxuLy8gQ2FudmFzUmVjb3JkZXIuanNcclxuXHJcbi8qKlxyXG4gKiBDYW52YXNSZWNvcmRlciBpcyBhIHN0YW5kYWxvbmUgY2xhc3MgdXNlZCBieSB7QGxpbmsgUmVjb3JkUlRDfSB0byBicmluZyBIVE1MNS1DYW52YXMgcmVjb3JkaW5nIGludG8gdmlkZW8gV2ViTS4gSXQgdXNlcyBIVE1MMkNhbnZhcyBsaWJyYXJ5IGFuZCBydW5zIHRvcCBvdmVyIHtAbGluayBXaGFtbXl9LlxyXG4gKiBAc3VtbWFyeSBIVE1MMkNhbnZhcyByZWNvcmRpbmcgaW50byB2aWRlbyBXZWJNLlxyXG4gKiBAbGljZW5zZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVR9XHJcbiAqIEBhdXRob3Ige0BsaW5rIGh0dHBzOi8vTXVhektoYW4uY29tfE11YXogS2hhbn1cclxuICogQHR5cGVkZWYgQ2FudmFzUmVjb3JkZXJcclxuICogQGNsYXNzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciByZWNvcmRlciA9IG5ldyBDYW52YXNSZWNvcmRlcihodG1sRWxlbWVudCwgeyBkaXNhYmxlTG9nczogdHJ1ZSwgdXNlV2hhbW15UmVjb3JkZXI6IHRydWUgfSk7XHJcbiAqIHJlY29yZGVyLnJlY29yZCgpO1xyXG4gKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICogICAgIHZpZGVvLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAqIH0pO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbGVtZW50IC0gcXVlcnlTZWxlY3Rvci9nZXRFbGVtZW50QnlJZC9nZXRFbGVtZW50c0J5VGFnTmFtZVswXS9ldGMuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSB7ZGlzYWJsZUxvZ3M6dHJ1ZSwgaW5pdENhbGxiYWNrOiBmdW5jdGlvbn1cclxuICovXHJcblxyXG5mdW5jdGlvbiBDYW52YXNSZWNvcmRlcihodG1sRWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICBpZiAodHlwZW9mIGh0bWwyY2FudmFzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93ICdQbGVhc2UgbGluazogaHR0cHM6Ly93d3cud2VicnRjLWV4cGVyaW1lbnQuY29tL3NjcmVlbnNob3QuanMnO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgIGlmICghY29uZmlnLmZyYW1lSW50ZXJ2YWwpIHtcclxuICAgICAgICBjb25maWcuZnJhbWVJbnRlcnZhbCA9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHZpYSBEZXRlY3RSVEMuanNcclxuICAgIHZhciBpc0NhbnZhc1N1cHBvcnRzU3RyZWFtQ2FwdHVyaW5nID0gZmFsc2U7XHJcbiAgICBbJ2NhcHR1cmVTdHJlYW0nLCAnbW96Q2FwdHVyZVN0cmVhbScsICd3ZWJraXRDYXB0dXJlU3RyZWFtJ10uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcclxuICAgICAgICAgICAgaXNDYW52YXNTdXBwb3J0c1N0cmVhbUNhcHR1cmluZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIF9pc0Nocm9tZSA9ICghIXdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbiB8fCAhIXdpbmRvdy53ZWJraXRHZXRVc2VyTWVkaWEpICYmICEhd2luZG93LmNocm9tZTtcclxuXHJcbiAgICB2YXIgY2hyb21lVmVyc2lvbiA9IDUwO1xyXG4gICAgdmFyIG1hdGNoQXJyYXkgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbShlfGl1bSlcXC8oWzAtOV0rKVxcLi8pO1xyXG4gICAgaWYgKF9pc0Nocm9tZSAmJiBtYXRjaEFycmF5ICYmIG1hdGNoQXJyYXlbMl0pIHtcclxuICAgICAgICBjaHJvbWVWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hBcnJheVsyXSwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfaXNDaHJvbWUgJiYgY2hyb21lVmVyc2lvbiA8IDUyKSB7XHJcbiAgICAgICAgaXNDYW52YXNTdXBwb3J0c1N0cmVhbUNhcHR1cmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcudXNlV2hhbW15UmVjb3JkZXIpIHtcclxuICAgICAgICBpc0NhbnZhc1N1cHBvcnRzU3RyZWFtQ2FwdHVyaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdsb2JhbENhbnZhcywgbWVkaWFTdHJlYW1SZWNvcmRlcjtcclxuXHJcbiAgICBpZiAoaXNDYW52YXNTdXBwb3J0c1N0cmVhbUNhcHR1cmluZykge1xyXG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdZb3VyIGJyb3dzZXIgc3VwcG9ydHMgYm90aCBNZWRpUmVjb3JkZXIgQVBJIGFuZCBjYW52YXMuY2FwdHVyZVN0cmVhbSEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChodG1sRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGdsb2JhbENhbnZhcyA9IGh0bWxFbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaHRtbEVsZW1lbnQgaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgICAgICAgZ2xvYmFsQ2FudmFzID0gaHRtbEVsZW1lbnQuY2FudmFzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93ICdQbGVhc2UgcGFzcyBlaXRoZXIgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELic7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghIW5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcclxuICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW52YXMgcmVjb3JkaW5nIGlzIE5PVCBzdXBwb3J0ZWQgaW4gRmlyZWZveC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzUmVjb3JkaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVjb3JkcyBDYW52YXMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWNvcmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc1JlY29yZGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChpc0NhbnZhc1N1cHBvcnRzU3RyZWFtQ2FwdHVyaW5nICYmICFjb25maWcudXNlV2hhbW15UmVjb3JkZXIpIHtcclxuICAgICAgICAgICAgLy8gQ2FudmFzQ2FwdHVyZU1lZGlhU3RyZWFtXHJcbiAgICAgICAgICAgIHZhciBjYW52YXNNZWRpYVN0cmVhbTtcclxuICAgICAgICAgICAgaWYgKCdjYXB0dXJlU3RyZWFtJyBpbiBnbG9iYWxDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc01lZGlhU3RyZWFtID0gZ2xvYmFsQ2FudmFzLmNhcHR1cmVTdHJlYW0oMjUpOyAvLyAyNSBGUFNcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgnbW96Q2FwdHVyZVN0cmVhbScgaW4gZ2xvYmFsQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNNZWRpYVN0cmVhbSA9IGdsb2JhbENhbnZhcy5tb3pDYXB0dXJlU3RyZWFtKDI1KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgnd2Via2l0Q2FwdHVyZVN0cmVhbScgaW4gZ2xvYmFsQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNNZWRpYVN0cmVhbSA9IGdsb2JhbENhbnZhcy53ZWJraXRDYXB0dXJlU3RyZWFtKDI1KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBtZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gICAgICAgICAgICAgICAgbWRTdHJlYW0uYWRkVHJhY2soZ2V0VHJhY2tzKGNhbnZhc01lZGlhU3RyZWFtLCAndmlkZW8nKVswXSk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNNZWRpYVN0cmVhbSA9IG1kU3RyZWFtO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjYW52YXNNZWRpYVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2NhcHR1cmVTdHJlYW0gQVBJIGFyZSBOT1QgYXZhaWxhYmxlLic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGU6IEphbiAxOCwgMjAxNiBzdGF0dXMgaXMgdGhhdCwgXHJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggTWVkaWFSZWNvcmRlciBBUEkgY2FuJ3QgcmVjb3JkIENhbnZhc0NhcHR1cmVNZWRpYVN0cmVhbSBvYmplY3QuXHJcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtUmVjb3JkZXIgPSBuZXcgTWVkaWFTdHJlYW1SZWNvcmRlcihjYW52YXNNZWRpYVN0cmVhbSwge1xyXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGNvbmZpZy5taW1lVHlwZSB8fCAndmlkZW8vd2VibSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtUmVjb3JkZXIucmVjb3JkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2hhbW15LmZyYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICBsYXN0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBkcmF3Q2FudmFzRnJhbWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuaW5pdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5pbml0Q2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0V2ViUEltYWdlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGh0bWxFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmcmFtZXNMZW5ndGggPSB3aGFtbXkuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICB3aGFtbXkuZnJhbWVzLmZvckVhY2goZnVuY3Rpb24oZnJhbWUsIGlkeCkge1xyXG4gICAgICAgICAgICB2YXIgZnJhbWVzUmVtYWluaW5nID0gZnJhbWVzTGVuZ3RoIC0gaWR4O1xyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZnJhbWVzUmVtYWluaW5nICsgJy8nICsgZnJhbWVzTGVuZ3RoICsgJyBmcmFtZXMgcmVtYWluaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb25maWcub25FbmNvZGluZ0NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcub25FbmNvZGluZ0NhbGxiYWNrKGZyYW1lc1JlbWFpbmluZywgZnJhbWVzTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdlYnAgPSBmcmFtZS5pbWFnZS50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnLCAxKTtcclxuICAgICAgICAgICAgd2hhbW15LmZyYW1lc1tpZHhdLmltYWdlID0gd2VicDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dlbmVyYXRpbmcgV2ViTScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzdG9wcyByZWNvcmRpbmcgQ2FudmFzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiwgdGhhdCBpcyB1c2VkIHRvIHBhc3MgcmVjb3JkZWQgYmxvYiBiYWNrIHRvIHRoZSBjYWxsZWUuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAqICAgICB2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaXNSZWNvcmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoaXNDYW52YXNTdXBwb3J0c1N0cmVhbUNhcHR1cmluZyAmJiBtZWRpYVN0cmVhbVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtUmVjb3JkZXIuc3RvcChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0V2ViUEltYWdlcyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QmxvYn0gYmxvYiAtIFJlY29yZGVkIGZyYW1lcyBpbiB2aWRlby93ZWJtIGJsb2IuXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDYW52YXNSZWNvcmRlclxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5ibG9iO1xyXG4gICAgICAgICAgICAgKiB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHdoYW1teS5jb21waWxlKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY29yZGluZyBmaW5pc2hlZCEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LmJsb2IgPSBibG9iO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmJsb2IuZm9yRWFjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYmxvYiA9IG5ldyBCbG9iKFtdLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2aWRlby93ZWJtJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoYXQuYmxvYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2hhbW15LmZyYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGlzUGF1c2VkUmVjb3JkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXVzZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc1JlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucGF1c2UoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlzUGF1c2VkUmVjb3JkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKG1lZGlhU3RyZWFtUmVjb3JkZXIgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIG1lZGlhU3RyZWFtUmVjb3JkZXIucGF1c2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXN1bWVzIHRoZSByZWNvcmRpbmcgcHJvY2Vzcy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnJlc3VtZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlzUGF1c2VkUmVjb3JkaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChtZWRpYVN0cmVhbVJlY29yZGVyIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1SZWNvcmRlcikge1xyXG4gICAgICAgICAgICBtZWRpYVN0cmVhbVJlY29yZGVyLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzUmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBjdXJyZW50bHkgcmVjb3JkZWQgZGF0YS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLmNsZWFyUmVjb3JkZWREYXRhKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xlYXJSZWNvcmRlZERhdGEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoaXNSZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKGNsZWFyUmVjb3JkZWREYXRhQ0IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclJlY29yZGVkRGF0YUNCKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFyUmVjb3JkZWREYXRhQ0IoKSB7XHJcbiAgICAgICAgd2hhbW15LmZyYW1lcyA9IFtdO1xyXG4gICAgICAgIGlzUmVjb3JkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgaXNQYXVzZWRSZWNvcmRpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICB0aGlzLm5hbWUgPSAnQ2FudmFzUmVjb3JkZXInO1xyXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsb25lQ2FudmFzKCkge1xyXG4gICAgICAgIC8vY3JlYXRlIGEgbmV3IGNhbnZhc1xyXG4gICAgICAgIHZhciBuZXdDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgICAgICAvL3NldCBkaW1lbnNpb25zXHJcbiAgICAgICAgbmV3Q2FudmFzLndpZHRoID0gaHRtbEVsZW1lbnQud2lkdGg7XHJcbiAgICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IGh0bWxFbGVtZW50LmhlaWdodDtcclxuXHJcbiAgICAgICAgLy9hcHBseSB0aGUgb2xkIGNhbnZhcyB0byB0aGUgbmV3IG9uZVxyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGh0bWxFbGVtZW50LCAwLCAwKTtcclxuXHJcbiAgICAgICAgLy9yZXR1cm4gdGhlIG5ldyBjYW52YXNcclxuICAgICAgICByZXR1cm4gbmV3Q2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXdDYW52YXNGcmFtZSgpIHtcclxuICAgICAgICBpZiAoaXNQYXVzZWRSZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgbGFzdFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZHJhd0NhbnZhc0ZyYW1lLCA1MDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGh0bWxFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFRpbWU7XHJcbiAgICAgICAgICAgIC8vIHZpYSAjMjA2LCBieSBKYWNrIGkuZS4gQFNleW1vdXJyXHJcbiAgICAgICAgICAgIGxhc3RUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgICAgICB3aGFtbXkuZnJhbWVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGNsb25lQ2FudmFzKCksXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNSZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZHJhd0NhbnZhc0ZyYW1lLCBjb25maWcuZnJhbWVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaHRtbDJjYW52YXMoaHRtbEVsZW1lbnQsIHtcclxuICAgICAgICAgICAgZ3JhYk1vdXNlOiB0eXBlb2YgY29uZmlnLnNob3dNb3VzZVBvaW50ZXIgPT09ICd1bmRlZmluZWQnIHx8IGNvbmZpZy5zaG93TW91c2VQb2ludGVyLFxyXG4gICAgICAgICAgICBvbnJlbmRlcmVkOiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFRpbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZHJhd0NhbnZhc0ZyYW1lLCBjb25maWcuZnJhbWVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdmlhICMyMDYsIGJ5IEphY2sgaS5lLiBAU2V5bW91cnJcclxuICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hhbW15LmZyYW1lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2Uvd2VicCcsIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChkcmF3Q2FudmFzRnJhbWUsIGNvbmZpZy5mcmFtZUludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsYXN0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgIHZhciB3aGFtbXkgPSBuZXcgV2hhbW15LlZpZGVvKDEwMCk7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLkNhbnZhc1JlY29yZGVyID0gQ2FudmFzUmVjb3JkZXI7XHJcbn1cblxyXG4vLyBfX19fX19fX19fX19fX19fX1xyXG4vLyBXaGFtbXlSZWNvcmRlci5qc1xyXG5cclxuLyoqXHJcbiAqIFdoYW1teVJlY29yZGVyIGlzIGEgc3RhbmRhbG9uZSBjbGFzcyB1c2VkIGJ5IHtAbGluayBSZWNvcmRSVEN9IHRvIGJyaW5nIHZpZGVvIHJlY29yZGluZyBpbiBDaHJvbWUuIEl0IHJ1bnMgdG9wIG92ZXIge0BsaW5rIFdoYW1teX0uXHJcbiAqIEBzdW1tYXJ5IFZpZGVvIHJlY29yZGluZyBmZWF0dXJlIGluIENocm9tZS5cclxuICogQGxpY2Vuc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUfVxyXG4gKiBAYXV0aG9yIHtAbGluayBodHRwczovL011YXpLaGFuLmNvbXxNdWF6IEtoYW59XHJcbiAqIEB0eXBlZGVmIFdoYW1teVJlY29yZGVyXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcmVjb3JkZXIgPSBuZXcgV2hhbW15UmVjb3JkZXIobWVkaWFTdHJlYW0pO1xyXG4gKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAqICAgICB2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gKiB9KTtcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBtZWRpYVN0cmVhbSAtIE1lZGlhU3RyZWFtIG9iamVjdCBmZXRjaGVkIHVzaW5nIGdldFVzZXJNZWRpYSBBUEkgb3IgZ2VuZXJhdGVkIHVzaW5nIGNhcHR1cmVTdHJlYW1VbnRpbEVuZGVkIG9yIFdlYkF1ZGlvIEFQSS5cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIHtkaXNhYmxlTG9nczogdHJ1ZSwgaW5pdENhbGxiYWNrOiBmdW5jdGlvbiwgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsIGV0Yy59XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gV2hhbW15UmVjb3JkZXIobWVkaWFTdHJlYW0sIGNvbmZpZykge1xyXG5cclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICBpZiAoIWNvbmZpZy5mcmFtZUludGVydmFsKSB7XHJcbiAgICAgICAgY29uZmlnLmZyYW1lSW50ZXJ2YWwgPSAxMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbmZpZy5kaXNhYmxlTG9ncykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBmcmFtZXMtaW50ZXJ2YWw6JywgY29uZmlnLmZyYW1lSW50ZXJ2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVjb3JkcyB2aWRlby5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBXaGFtbXlSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnJlY29yZCgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJlY29yZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghY29uZmlnLndpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy53aWR0aCA9IDMyMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY29uZmlnLmhlaWdodCkge1xyXG4gICAgICAgICAgICBjb25maWcuaGVpZ2h0ID0gMjQwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcudmlkZW8pIHtcclxuICAgICAgICAgICAgY29uZmlnLnZpZGVvID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcuY2FudmFzKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5jYW52YXMgPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBjb25maWcuY2FudmFzLndpZHRoIHx8IDMyMDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY29uZmlnLmNhbnZhcy5oZWlnaHQgfHwgMjQwO1xyXG5cclxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgIC8vIHNldHRpbmcgZGVmYXVsdHNcclxuICAgICAgICBpZiAoY29uZmlnLnZpZGVvICYmIGNvbmZpZy52aWRlbyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmlkZW8gPSBjb25maWcudmlkZW8uY2xvbmVOb2RlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmluaXRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmluaXRDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG5cclxuICAgICAgICAgICAgc2V0U3JjT2JqZWN0KG1lZGlhU3RyZWFtLCB2aWRlbyk7XHJcblxyXG4gICAgICAgICAgICB2aWRlby5vbmxvYWRlZG1ldGFkYXRhID0gZnVuY3Rpb24oKSB7IC8vIFwib25sb2FkZWRtZXRhZGF0YVwiIG1heSBOT1Qgd29yayBpbiBGRj9cclxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuaW5pdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmluaXRDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmlkZW8ud2lkdGggPSBjb25maWcudmlkZW8ud2lkdGg7XHJcbiAgICAgICAgICAgIHZpZGVvLmhlaWdodCA9IGNvbmZpZy52aWRlby5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2aWRlby5tdXRlZCA9IHRydWU7XHJcbiAgICAgICAgdmlkZW8ucGxheSgpO1xyXG5cclxuICAgICAgICBsYXN0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHdoYW1teSA9IG5ldyBXaGFtbXkuVmlkZW8oKTtcclxuXHJcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUxvZ3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NhbnZhcyByZXNvbHV0aW9ucycsIGNhbnZhcy53aWR0aCwgJyonLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZpZGVvIHdpZHRoL2hlaWdodCcsIHZpZGVvLndpZHRoIHx8IGNhbnZhcy53aWR0aCwgJyonLCB2aWRlby5oZWlnaHQgfHwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkcmF3RnJhbWVzKGNvbmZpZy5mcmFtZUludGVydmFsKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGFuZCBwdXNoIGZyYW1lcyB0byBXaGFtbXlcclxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gZnJhbWVJbnRlcnZhbCAtIHNldCBtaW5pbXVtIGludGVydmFsIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gZWFjaCB0aW1lIHdlIHB1c2ggYSBmcmFtZSB0byBXaGFtbXlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZHJhd0ZyYW1lcyhmcmFtZUludGVydmFsKSB7XHJcbiAgICAgICAgZnJhbWVJbnRlcnZhbCA9IHR5cGVvZiBmcmFtZUludGVydmFsICE9PSAndW5kZWZpbmVkJyA/IGZyYW1lSW50ZXJ2YWwgOiAxMDtcclxuXHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsYXN0VGltZTtcclxuICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGRyYXdGcmFtZXMsIGZyYW1lSW50ZXJ2YWwsIGZyYW1lSW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzUGF1c2VkUmVjb3JkaW5nKSB7XHJcbiAgICAgICAgICAgIGxhc3RUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGRyYXdGcmFtZXMsIDEwMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2aWEgIzIwNiwgYnkgSmFjayBpLmUuIEBTZXltb3VyclxyXG4gICAgICAgIGxhc3RUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIGlmICh2aWRlby5wYXVzZWQpIHtcclxuICAgICAgICAgICAgLy8gdmlhOiBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L3B1bGwvMzE2XHJcbiAgICAgICAgICAgIC8vIFR3ZWFrIGZvciBBbmRyb2lkIENocm9tZVxyXG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB3aGFtbXkuZnJhbWVzLnB1c2goe1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGltYWdlOiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS93ZWJwJylcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFpc1N0b3BEcmF3aW5nKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZHJhd0ZyYW1lcywgZnJhbWVJbnRlcnZhbCwgZnJhbWVJbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFzeW5jTG9vcChvKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gby5sZW5ndGg7XHJcblxyXG4gICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG8uY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gXCJzZXRUaW1lb3V0XCIgYWRkZWQgYnkgSmltIE1jTGVvZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgby5mdW5jdGlvblRvTG9vcChsb29wLCBpKTtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZW1vdmUgYmxhY2sgZnJhbWVzIGZyb20gdGhlIGJlZ2lubmluZyB0byB0aGUgc3BlY2lmaWVkIGZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBfZnJhbWVzIC0gYXJyYXkgb2YgZnJhbWVzIHRvIGJlIGNoZWNrZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBfZnJhbWVzVG9DaGVjayAtIG51bWJlciBvZiBmcmFtZSB1bnRpbCBjaGVjayB3aWxsIGJlIGV4ZWN1dGVkICgtMSAtIHdpbGwgZHJvcCBhbGwgZnJhbWVzIHVudGlsIGZyYW1lIG5vdCBtYXRjaGVkIHdpbGwgYmUgZm91bmQpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gX3BpeFRvbGVyYW5jZSAtIDAgLSB2ZXJ5IHN0cmljdCAob25seSBibGFjayBwaXhlbCBjb2xvcikgOyAxIC0gYWxsXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gX2ZyYW1lVG9sZXJhbmNlIC0gMCAtIHZlcnkgc3RyaWN0IChvbmx5IGJsYWNrIGZyYW1lIGNvbG9yKSA7IDEgLSBhbGxcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBmcmFtZXNcclxuICAgICAqL1xyXG4gICAgLy8gcHVsbCMyOTMgYnkgQHZvbG9kYWxleGV5XHJcbiAgICBmdW5jdGlvbiBkcm9wQmxhY2tGcmFtZXMoX2ZyYW1lcywgX2ZyYW1lc1RvQ2hlY2ssIF9waXhUb2xlcmFuY2UsIF9mcmFtZVRvbGVyYW5jZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgbG9jYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBsb2NhbENhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICBsb2NhbENhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjb250ZXh0MmQgPSBsb2NhbENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHZhciByZXN1bHRGcmFtZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGNoZWNrVW50aWxOb3RCbGFjayA9IF9mcmFtZXNUb0NoZWNrID09PSAtMTtcclxuICAgICAgICB2YXIgZW5kQ2hlY2tGcmFtZSA9IChfZnJhbWVzVG9DaGVjayAmJiBfZnJhbWVzVG9DaGVjayA+IDAgJiYgX2ZyYW1lc1RvQ2hlY2sgPD0gX2ZyYW1lcy5sZW5ndGgpID9cclxuICAgICAgICAgICAgX2ZyYW1lc1RvQ2hlY2sgOiBfZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgc2FtcGxlQ29sb3IgPSB7XHJcbiAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgIGc6IDAsXHJcbiAgICAgICAgICAgIGI6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtYXhDb2xvckRpZmZlcmVuY2UgPSBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgIE1hdGgucG93KDI1NSwgMikgK1xyXG4gICAgICAgICAgICBNYXRoLnBvdygyNTUsIDIpICtcclxuICAgICAgICAgICAgTWF0aC5wb3coMjU1LCAyKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIHBpeFRvbGVyYW5jZSA9IF9waXhUb2xlcmFuY2UgJiYgX3BpeFRvbGVyYW5jZSA+PSAwICYmIF9waXhUb2xlcmFuY2UgPD0gMSA/IF9waXhUb2xlcmFuY2UgOiAwO1xyXG4gICAgICAgIHZhciBmcmFtZVRvbGVyYW5jZSA9IF9mcmFtZVRvbGVyYW5jZSAmJiBfZnJhbWVUb2xlcmFuY2UgPj0gMCAmJiBfZnJhbWVUb2xlcmFuY2UgPD0gMSA/IF9mcmFtZVRvbGVyYW5jZSA6IDA7XHJcbiAgICAgICAgdmFyIGRvTm90Q2hlY2tOZXh0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGFzeW5jTG9vcCh7XHJcbiAgICAgICAgICAgIGxlbmd0aDogZW5kQ2hlY2tGcmFtZSxcclxuICAgICAgICAgICAgZnVuY3Rpb25Ub0xvb3A6IGZ1bmN0aW9uKGxvb3AsIGYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaFBpeENvdW50LCBlbmRQaXhDaGVjaywgbWF4UGl4Q291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaEltYWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb05vdENoZWNrTmV4dCAmJiBtYXhQaXhDb3VudCAtIG1hdGNoUGl4Q291bnQgPD0gbWF4UGl4Q291bnQgKiBmcmFtZVRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlZCBibGFjayBmcmFtZSA6ICcgKyBmICsgJyA7IGZyYW1lIGR1cmF0aW9uICcgKyBfZnJhbWVzW2ZdLmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJhbWUgaXMgcGFzc2VkIDogJyArIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tVbnRpbE5vdEJsYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb05vdENoZWNrTmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RnJhbWVzLnB1c2goX2ZyYW1lc1tmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkb05vdENoZWNrTmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0MmQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dDJkLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFBpeENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUGl4Q2hlY2sgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFBpeENvdW50ID0gaW1hZ2VEYXRhLmRhdGEubGVuZ3RoIC8gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBpeCA9IDA7IHBpeCA8IGVuZFBpeENoZWNrOyBwaXggKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb2xvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByOiBpbWFnZURhdGEuZGF0YVtwaXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGc6IGltYWdlRGF0YS5kYXRhW3BpeCArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGltYWdlRGF0YS5kYXRhW3BpeCArIDJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yRGlmZmVyZW5jZSA9IE1hdGguc3FydChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjdXJyZW50Q29sb3IuciAtIHNhbXBsZUNvbG9yLnIsIDIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjdXJyZW50Q29sb3IuZyAtIHNhbXBsZUNvbG9yLmcsIDIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjdXJyZW50Q29sb3IuYiAtIHNhbXBsZUNvbG9yLmIsIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBjb2xvciBpdCBpcyBkaWZmZXJlbmNlIGluIGNvbG9yIHZlY3RvcnMgKHIxLGcxLGIxKSA8PT4gKHIyLGcyLGIyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yRGlmZmVyZW5jZSA8PSBtYXhDb2xvckRpZmZlcmVuY2UgKiBwaXhUb2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFBpeENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IF9mcmFtZXNbZl0uaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEZyYW1lcyA9IHJlc3VsdEZyYW1lcy5jb25jYXQoX2ZyYW1lcy5zbGljZShlbmRDaGVja0ZyYW1lKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEZyYW1lcy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSBsYXN0IGZyYW1lIHNob3VsZCBiZSBhdmFpbGFibGUgZm9yIG5leHQgbWFuaXB1bGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG90YWwgZHVyYXRpb24gb2YgYWxsIGZyYW1lcyB3aWxsIGJlIDwgMTAwMCB0aGFuIGZmbXBlZyBkb2Vzbid0IHdvcmsgd2VsbC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEZyYW1lcy5wdXNoKF9mcmFtZXNbX2ZyYW1lcy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRGcmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzU3RvcERyYXdpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3BzIHJlY29yZGluZyB2aWRlby5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24sIHRoYXQgaXMgdXNlZCB0byBwYXNzIHJlY29yZGVkIGJsb2IgYmFjayB0byB0aGUgY2FsbGVlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFdoYW1teVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAgICAgKiAgICAgdmlkZW8uc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgaXNTdG9wRHJhd2luZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYW5hbHlzZSBvZiBhbGwgZnJhbWVzIHRha2VzIHNvbWUgdGltZSFcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBlLmcuIGRyb3BCbGFja0ZyYW1lcyhmcmFtZXMsIDEwLCAxLCAxKSAtIHdpbGwgY3V0IGFsbCAxMCBmcmFtZXNcclxuICAgICAgICAgICAgLy8gZS5nLiBkcm9wQmxhY2tGcmFtZXMoZnJhbWVzLCAxMCwgMC41LCAwLjUpIC0gd2lsbCBhbmFseXNlIDEwIGZyYW1lc1xyXG4gICAgICAgICAgICAvLyBlLmcuIGRyb3BCbGFja0ZyYW1lcyhmcmFtZXMsIDEwKSA9PT0gZHJvcEJsYWNrRnJhbWVzKGZyYW1lcywgMTAsIDAsIDApIC0gd2lsbCBhbmFseXNlIDEwIGZyYW1lcyB3aXRoIHN0cmljdCBibGFjayBjb2xvclxyXG4gICAgICAgICAgICBkcm9wQmxhY2tGcmFtZXMod2hhbW15LmZyYW1lcywgLTEsIG51bGwsIG51bGwsIGZ1bmN0aW9uKGZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgd2hhbW15LmZyYW1lcyA9IGZyYW1lcztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0byBkaXNwbGF5IGFkdmVydGlzZW1lbnQgaW1hZ2VzIVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5hZHZlcnRpc2VtZW50ICYmIGNvbmZpZy5hZHZlcnRpc2VtZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoYW1teS5mcmFtZXMgPSBjb25maWcuYWR2ZXJ0aXNlbWVudC5jb25jYXQod2hhbW15LmZyYW1lcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jsb2J9IGJsb2IgLSBSZWNvcmRlZCBmcmFtZXMgaW4gdmlkZW8vd2VibSBibG9iLlxyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIFdoYW1teVJlY29yZGVyXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAqICAgICB2YXIgYmxvYiA9IHJlY29yZGVyLmJsb2I7XHJcbiAgICAgICAgICAgICAgICAgKiB9KTtcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgd2hhbW15LmNvbXBpbGUoZnVuY3Rpb24oYmxvYikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJsb2IgPSBibG9iO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYmxvYi5mb3JFYWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJsb2IgPSBuZXcgQmxvYihbXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZpZGVvL3dlYm0nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKF90aGlzLmJsb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAxMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpc1BhdXNlZFJlY29yZGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcGF1c2VzIHRoZSByZWNvcmRpbmcgcHJvY2Vzcy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBXaGFtbXlSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnBhdXNlKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc1BhdXNlZFJlY29yZGluZyA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVzdW1lcyB0aGUgcmVjb3JkaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgV2hhbW15UmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZXN1bWUoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc1BhdXNlZFJlY29yZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoaXNTdG9wRHJhd2luZykge1xyXG4gICAgICAgICAgICB0aGlzLnJlY29yZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgY3VycmVudGx5IHJlY29yZGVkIGRhdGEuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgV2hhbW15UmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5jbGVhclJlY29yZGVkRGF0YSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmNsZWFyUmVjb3JkZWREYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0b3BEcmF3aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcChjbGVhclJlY29yZGVkRGF0YUNCKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJSZWNvcmRlZERhdGFDQigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhclJlY29yZGVkRGF0YUNCKCkge1xyXG4gICAgICAgIHdoYW1teS5mcmFtZXMgPSBbXTtcclxuICAgICAgICBpc1N0b3BEcmF3aW5nID0gdHJ1ZTtcclxuICAgICAgICBpc1BhdXNlZFJlY29yZGluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvciBkZWJ1Z2dpbmdcclxuICAgIHRoaXMubmFtZSA9ICdXaGFtbXlSZWNvcmRlcic7XHJcbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICB2YXIgdmlkZW87XHJcbiAgICB2YXIgbGFzdFRpbWU7XHJcbiAgICB2YXIgd2hhbW15O1xyXG59XHJcblxyXG5pZiAodHlwZW9mIFJlY29yZFJUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFJlY29yZFJUQy5XaGFtbXlSZWNvcmRlciA9IFdoYW1teVJlY29yZGVyO1xyXG59XG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FudGltYXR0ZXIxNS93aGFtbXkvYmxvYi9tYXN0ZXIvTElDRU5TRVxyXG4vLyBfX19fX19fX19cclxuLy8gV2hhbW15LmpzXHJcblxyXG4vLyB0b2RvOiBGaXJlZm94IG5vdyBzdXBwb3J0cyB3ZWJwIGZvciB3ZWJtIGNvbnRhaW5lcnMhXHJcbi8vIHRoZWlyIE1lZGlhUmVjb3JkZXIgaW1wbGVtZW50YXRpb24gd29ya3Mgd2VsbCFcclxuLy8gc2hvdWxkIHdlIHByb3ZpZGUgYW4gb3B0aW9uIHRvIHJlY29yZCB2aWEgV2hhbW15LmpzIG9yIE1lZGlhUmVjb3JkZXIgQVBJIGlzIGEgYmV0dGVyIHNvbHV0aW9uP1xyXG5cclxuLyoqXHJcbiAqIFdoYW1teSBpcyBhIHN0YW5kYWxvbmUgY2xhc3MgdXNlZCBieSB7QGxpbmsgUmVjb3JkUlRDfSB0byBicmluZyB2aWRlbyByZWNvcmRpbmcgaW4gQ2hyb21lLiBJdCBpcyB3cml0dGVuIGJ5IHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW50aW1hdHRlcjE1fGFudGltYXR0ZXIxNX1cclxuICogQHN1bW1hcnkgQSByZWFsIHRpbWUgamF2YXNjcmlwdCB3ZWJtIGVuY29kZXIgYmFzZWQgb24gYSBjYW52YXMgaGFjay5cclxuICogQGxpY2Vuc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUfVxyXG4gKiBAYXV0aG9yIHtAbGluayBodHRwczovL011YXpLaGFuLmNvbXxNdWF6IEtoYW59XHJcbiAqIEB0eXBlZGVmIFdoYW1teVxyXG4gKiBAY2xhc3NcclxuICogQGV4YW1wbGVcclxuICogdmFyIHJlY29yZGVyID0gbmV3IFdoYW1teSgpLlZpZGVvKDE1KTtcclxuICogcmVjb3JkZXIuYWRkKGNvbnRleHQgfHwgY2FudmFzIHx8IGRhdGFVUkwpO1xyXG4gKiB2YXIgb3V0cHV0ID0gcmVjb3JkZXIuY29tcGlsZSgpO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqL1xyXG5cclxudmFyIFdoYW1teSA9IChmdW5jdGlvbigpIHtcclxuICAgIC8vIGEgbW9yZSBhYnN0cmFjdC1pc2ggQVBJXHJcblxyXG4gICAgZnVuY3Rpb24gV2hhbW15VmlkZW8oZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAxO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IDAuODtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhc3MgQ2FudmFzIG9yIENvbnRleHQgb3IgaW1hZ2Uvd2VicChzdHJpbmcpIHRvIHtAbGluayBXaGFtbXl9IGVuY29kZXIuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgV2hhbW15XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIgPSBuZXcgV2hhbW15KCkuVmlkZW8oMC44LCAxMDApO1xyXG4gICAgICogcmVjb3JkZXIuYWRkKGNhbnZhcyB8fCBjb250ZXh0IHx8ICdpbWFnZS93ZWJwJyk7XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhbWUgLSBDYW52YXMgfHwgQ29udGV4dCB8fCBpbWFnZS93ZWJwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBTdGljayBhIGR1cmF0aW9uIChpbiBtaWxsaXNlY29uZHMpXHJcbiAgICAgKi9cclxuICAgIFdoYW1teVZpZGVvLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBpZiAoJ2NhbnZhcycgaW4gZnJhbWUpIHsgLy9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgICAgICAgICAgZnJhbWUgPSBmcmFtZS5jYW52YXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gZnJhbWUpIHtcclxuICAgICAgICAgICAgZnJhbWUgPSBmcmFtZS50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnLCB0aGlzLnF1YWxpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCEoL15kYXRhOmltYWdlXFwvd2VicDtiYXNlNjQsL2lnKS50ZXN0KGZyYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnSW5wdXQgbXVzdCBiZSBmb3JtYXR0ZWQgcHJvcGVybHkgYXMgYSBiYXNlNjQgZW5jb2RlZCBEYXRhVVJJIG9mIHR5cGUgaW1hZ2Uvd2VicCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhbWVzLnB1c2goe1xyXG4gICAgICAgICAgICBpbWFnZTogZnJhbWUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCB0aGlzLmR1cmF0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NJbldlYldvcmtlcihfZnVuY3Rpb24pIHtcclxuICAgICAgICB2YXIgYmxvYiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW19mdW5jdGlvbi50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAndGhpcy5vbm1lc3NhZ2UgPSAgZnVuY3Rpb24gKGVlZSkgeycgKyBfZnVuY3Rpb24ubmFtZSArICcoZWVlLmRhdGEpO30nXHJcbiAgICAgICAgXSwge1xyXG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2IpO1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3aGFtbXlJbldlYldvcmtlcihmcmFtZXMpIHtcclxuICAgICAgICBmdW5jdGlvbiBBcnJheVRvV2ViTShmcmFtZXMpIHtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBjaGVja0ZyYW1lcyhmcmFtZXMpO1xyXG4gICAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNsdXN0ZXJNYXhEdXJhdGlvbiA9IDMwMDAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIEVCTUwgPSBbe1xyXG4gICAgICAgICAgICAgICAgJ2lkJzogMHgxYTQ1ZGZhMywgLy8gRUJNTFxyXG4gICAgICAgICAgICAgICAgJ2RhdGEnOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogMSxcclxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAweDQyODYgLy8gRUJNTFZlcnNpb25cclxuICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg0MmY3IC8vIEVCTUxSZWFkVmVyc2lvblxyXG4gICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogNCxcclxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAweDQyZjIgLy8gRUJNTE1heElETGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiA4LFxyXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IDB4NDJmMyAvLyBFQk1MTWF4U2l6ZUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogJ3dlYm0nLFxyXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IDB4NDI4MiAvLyBEb2NUeXBlXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICdpZCc6IDB4NDI4NyAvLyBEb2NUeXBlVmVyc2lvblxyXG4gICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogMixcclxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAweDQyODUgLy8gRG9jVHlwZVJlYWRWZXJzaW9uXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAnaWQnOiAweDE4NTM4MDY3LCAvLyBTZWdtZW50XHJcbiAgICAgICAgICAgICAgICAnZGF0YSc6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHgxNTQ5YTk2NiwgLy8gSW5mb1xyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAxZTYsIC8vZG8gdGhpbmdzIGluIG1pbGxpc2VjcyAobnVtIG9mIG5hbm9zZWNzIGZvciBkdXJhdGlvbiBzY2FsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHgyYWQ3YjEgLy8gVGltZWNvZGVTY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnd2hhbW15JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg0ZDgwIC8vIE11eGluZ0FwcFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnd2hhbW15JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg1NzQxIC8vIFdyaXRpbmdBcHBcclxuICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogZG91YmxlVG9TdHJpbmcoaW5mby5kdXJhdGlvbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IDB4NDQ4OSAvLyBEdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHgxNjU0YWU2YiwgLy8gVHJhY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiAweGFlLCAvLyBUcmFja0VudHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IDB4ZDcgLy8gVHJhY2tOdW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg3M2M1IC8vIFRyYWNrVUlEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6IDB4OWMgLy8gRmxhZ0xhY2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6ICd1bmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHgyMmI1OWMgLy8gTGFuZ3VhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAnVl9WUDgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg4NiAvLyBDb2RlY0lEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogJ1ZQOCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiAweDI1ODY4OCAvLyBDb2RlY05hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHg4MyAvLyBUcmFja1R5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHhlMCwgLy8gVmlkZW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSc6IGluZm8ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHhiMCAvLyBQaXhlbFdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBpbmZvLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiAweGJhIC8vIFBpeGVsSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgICAgIC8vR2VuZXJhdGUgY2x1c3RlcnMgKG1heCBkdXJhdGlvbilcclxuICAgICAgICAgICAgdmFyIGZyYW1lTnVtYmVyID0gMDtcclxuICAgICAgICAgICAgdmFyIGNsdXN0ZXJUaW1lY29kZSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChmcmFtZU51bWJlciA8IGZyYW1lcy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2x1c3RlckZyYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsdXN0ZXJEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlckZyYW1lcy5wdXNoKGZyYW1lc1tmcmFtZU51bWJlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEdXJhdGlvbiArPSBmcmFtZXNbZnJhbWVOdW1iZXJdLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lTnVtYmVyKys7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChmcmFtZU51bWJlciA8IGZyYW1lcy5sZW5ndGggJiYgY2x1c3RlckR1cmF0aW9uIDwgY2x1c3Rlck1heER1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY2x1c3RlckNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsdXN0ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogMHgxZjQzYjY3NSwgLy8gQ2x1c3RlclxyXG4gICAgICAgICAgICAgICAgICAgICdkYXRhJzogZ2V0Q2x1c3RlckRhdGEoY2x1c3RlclRpbWVjb2RlLCBjbHVzdGVyQ291bnRlciwgY2x1c3RlckZyYW1lcylcclxuICAgICAgICAgICAgICAgIH07IC8vQWRkIGNsdXN0ZXIgdG8gc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgRUJNTFsxXS5kYXRhLnB1c2goY2x1c3Rlcik7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyVGltZWNvZGUgKz0gY2x1c3RlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVFQk1MKEVCTUwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2x1c3RlckRhdGEoY2x1c3RlclRpbWVjb2RlLCBjbHVzdGVyQ291bnRlciwgY2x1c3RlckZyYW1lcykge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tcclxuICAgICAgICAgICAgICAgICdkYXRhJzogY2x1c3RlclRpbWVjb2RlLFxyXG4gICAgICAgICAgICAgICAgJ2lkJzogMHhlNyAvLyBUaW1lY29kZVxyXG4gICAgICAgICAgICB9XS5jb25jYXQoY2x1c3RlckZyYW1lcy5tYXAoZnVuY3Rpb24od2VicCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gbWFrZVNpbXBsZUJsb2NrKHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNjYXJkYWJsZTogMCxcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZTogd2VicC5kYXRhLnNsaWNlKDQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGludmlzaWJsZTogMCxcclxuICAgICAgICAgICAgICAgICAgICBrZXlmcmFtZTogMSxcclxuICAgICAgICAgICAgICAgICAgICBsYWNpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tOdW06IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZWNvZGU6IE1hdGgucm91bmQoY2x1c3RlckNvdW50ZXIpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXJDb3VudGVyICs9IHdlYnAuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGJsb2NrLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAweGEzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdW1zIHRoZSBsZW5ndGhzIG9mIGFsbCB0aGUgZnJhbWVzIGFuZCBnZXRzIHRoZSBkdXJhdGlvblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjaGVja0ZyYW1lcyhmcmFtZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFmcmFtZXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ1NvbWV0aGluZyB3ZW50IHdyb25nLiBNYXliZSBXZWJQIGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuJ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGZyYW1lc1swXS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGZyYW1lc1swXS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGZyYW1lc1swXS5kdXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiArPSBmcmFtZXNbaV0uZHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBudW1Ub0J1ZmZlcihudW0pIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChudW0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKG51bSAmIDB4ZmYpO1xyXG4gICAgICAgICAgICAgICAgbnVtID0gbnVtID4+IDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBhcnRzLnJldmVyc2UoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzdHJUb0J1ZmZlcihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHN0ci5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGJpdHNUb0J1ZmZlcihiaXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgICAgIHZhciBwYWQgPSAoYml0cy5sZW5ndGggJSA4KSA/IChuZXcgQXJyYXkoMSArIDggLSAoYml0cy5sZW5ndGggJSA4KSkpLmpvaW4oJzAnKSA6ICcnO1xyXG4gICAgICAgICAgICBiaXRzID0gcGFkICsgYml0cztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2gocGFyc2VJbnQoYml0cy5zdWJzdHIoaSwgOCksIDIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUVCTUwoanNvbikge1xyXG4gICAgICAgICAgICB2YXIgZWJtbCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ganNvbltpXS5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZ2VuZXJhdGVFQk1MKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYml0c1RvQnVmZmVyKGRhdGEudG9TdHJpbmcoMikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyVG9CdWZmZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEuc2l6ZSB8fCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgemVyb2VzID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLmxvZyhsZW4pIC8gTWF0aC5sb2coMikpIC8gOCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZVRvU3RyaW5nID0gbGVuLnRvU3RyaW5nKDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhZGRlZCA9IChuZXcgQXJyYXkoKHplcm9lcyAqIDcgKyA3ICsgMSkgLSBzaXplVG9TdHJpbmcubGVuZ3RoKSkuam9pbignMCcpICsgc2l6ZVRvU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAobmV3IEFycmF5KHplcm9lcykpLmpvaW4oJzAnKSArICcxJyArIHBhZGRlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBlYm1sLnB1c2gobnVtVG9CdWZmZXIoanNvbltpXS5pZCkpO1xyXG4gICAgICAgICAgICAgICAgZWJtbC5wdXNoKGJpdHNUb0J1ZmZlcihzaXplKSk7XHJcbiAgICAgICAgICAgICAgICBlYm1sLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihlYm1sLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAndmlkZW8vd2VibSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB0b0JpblN0ck9sZChiaXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBwYWQgPSAoYml0cy5sZW5ndGggJSA4KSA/IChuZXcgQXJyYXkoMSArIDggLSAoYml0cy5sZW5ndGggJSA4KSkpLmpvaW4oJzAnKSA6ICcnO1xyXG4gICAgICAgICAgICBiaXRzID0gcGFkICsgYml0cztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYml0cy5zdWJzdHIoaSwgOCksIDIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VTaW1wbGVCbG9jayhkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBmbGFncyA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5rZXlmcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gMTI4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5pbnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGZsYWdzIHw9IDg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmxhY2luZykge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gKGRhdGEubGFjaW5nIDw8IDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5kaXNjYXJkYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEudHJhY2tOdW0gPiAxMjcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdUcmFja051bWJlciA+IDEyNyBub3Qgc3VwcG9ydGVkJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG91dCA9IFtkYXRhLnRyYWNrTnVtIHwgMHg4MCwgZGF0YS50aW1lY29kZSA+PiA4LCBkYXRhLnRpbWVjb2RlICYgMHhmZiwgZmxhZ3NdLm1hcChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcclxuICAgICAgICAgICAgfSkuam9pbignJykgKyBkYXRhLmZyYW1lO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlV2ViUChyaWZmKSB7XHJcbiAgICAgICAgICAgIHZhciBWUDggPSByaWZmLlJJRkZbMF0uV0VCUFswXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmcmFtZVN0YXJ0ID0gVlA4LmluZGV4T2YoJ1xceDlkXFx4MDFcXHgyYScpOyAvLyBBIFZQOCBrZXlmcmFtZSBzdGFydHMgd2l0aCB0aGUgMHg5ZDAxMmEgaGVhZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gW107IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNbaV0gPSBWUDguY2hhckNvZGVBdChmcmFtZVN0YXJ0ICsgMyArIGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgd2lkdGgsIGhlaWdodCwgdG1wO1xyXG5cclxuICAgICAgICAgICAgLy90aGUgY29kZSBiZWxvdyBpcyBsaXRlcmFsbHkgY29waWVkIHZlcmJhdGltIGZyb20gdGhlIGJpdHN0cmVhbSBzcGVjXHJcbiAgICAgICAgICAgIHRtcCA9IChjWzFdIDw8IDgpIHwgY1swXTtcclxuICAgICAgICAgICAgd2lkdGggPSB0bXAgJiAweDNGRkY7XHJcbiAgICAgICAgICAgIHRtcCA9IChjWzNdIDw8IDgpIHwgY1syXTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdG1wICYgMHgzRkZGO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBWUDgsXHJcbiAgICAgICAgICAgICAgICByaWZmOiByaWZmXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRTdHJMZW5ndGgoc3RyaW5nLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZy5zdWJzdHIob2Zmc2V0ICsgNCwgNCkuc3BsaXQoJycpLm1hcChmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5wYWRkZWQgPSBpLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBBcnJheSg4IC0gdW5wYWRkZWQubGVuZ3RoICsgMSkpLmpvaW4oJzAnKSArIHVucGFkZGVkO1xyXG4gICAgICAgICAgICB9KS5qb2luKCcnKSwgMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJzZVJJRkYoc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgY2h1bmtzID0ge307XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgc3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc3RyaW5nLnN1YnN0cihvZmZzZXQsIDQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGdldFN0ckxlbmd0aChzdHJpbmcsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHN0cmluZy5zdWJzdHIob2Zmc2V0ICsgNCArIDQsIGxlbik7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNCArIDQgKyBsZW47XHJcbiAgICAgICAgICAgICAgICBjaHVua3NbaWRdID0gY2h1bmtzW2lkXSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09ICdSSUZGJyB8fCBpZCA9PT0gJ0xJU1QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW2lkXS5wdXNoKHBhcnNlUklGRihkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tpZF0ucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2h1bmtzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZG91YmxlVG9TdHJpbmcobnVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKFxyXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKG5ldyBGbG9hdDY0QXJyYXkoW251bV0pKS5idWZmZXIpLCAwKS5tYXAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSk7XHJcbiAgICAgICAgICAgIH0pLnJldmVyc2UoKS5qb2luKCcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB3ZWJtID0gbmV3IEFycmF5VG9XZWJNKGZyYW1lcy5tYXAoZnVuY3Rpb24oZnJhbWUpIHtcclxuICAgICAgICAgICAgdmFyIHdlYnAgPSBwYXJzZVdlYlAocGFyc2VSSUZGKGF0b2IoZnJhbWUuaW1hZ2Uuc2xpY2UoMjMpKSkpO1xyXG4gICAgICAgICAgICB3ZWJwLmR1cmF0aW9uID0gZnJhbWUuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWJwO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgcG9zdE1lc3NhZ2Uod2VibSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGZyYW1lcyBpbiBXZWJNIGNvbnRhaW5lci4gSXQgdXNlcyBXZWJXb3JraW52b2tlIHRvIGludm9rZSAnQXJyYXlUb1dlYk0nIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24sIHRoYXQgaXMgdXNlZCB0byBwYXNzIHJlY29yZGVkIGJsb2IgYmFjayB0byB0aGUgY2FsbGVlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFdoYW1teVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyID0gbmV3IFdoYW1teSgpLlZpZGVvKDAuOCwgMTAwKTtcclxuICAgICAqIHJlY29yZGVyLmNvbXBpbGUoZnVuY3Rpb24oYmxvYikge1xyXG4gICAgICogICAgLy8gYmxvYi5zaXplIC0gYmxvYi50eXBlXHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgV2hhbW15VmlkZW8ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciB3ZWJXb3JrZXIgPSBwcm9jZXNzSW5XZWJXb3JrZXIod2hhbW15SW5XZWJXb3JrZXIpO1xyXG5cclxuICAgICAgICB3ZWJXb3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXZlbnQuZGF0YS5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgd2ViV29ya2VyLnBvc3RNZXNzYWdlKHRoaXMuZnJhbWVzKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG1vcmUgYWJzdHJhY3QtaXNoIEFQSS5cclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFdoYW1teVxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICogcmVjb3JkZXIgPSBuZXcgV2hhbW15KCkuVmlkZW8oMC44LCAxMDApO1xyXG4gICAgICAgICAqIEBwYXJhbSB7P251bWJlcn0gc3BlZWQgLSAwLjhcclxuICAgICAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHF1YWxpdHkgLSAxMDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBWaWRlbzogV2hhbW15VmlkZW9cclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG5pZiAodHlwZW9mIFJlY29yZFJUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFJlY29yZFJUQy5XaGFtbXkgPSBXaGFtbXk7XHJcbn1cblxyXG4vLyBfX19fX19fX19fX19fXyAoaW5kZXhlZC1kYilcclxuLy8gRGlza1N0b3JhZ2UuanNcclxuXHJcbi8qKlxyXG4gKiBEaXNrU3RvcmFnZSBpcyBhIHN0YW5kYWxvbmUgb2JqZWN0IHVzZWQgYnkge0BsaW5rIFJlY29yZFJUQ30gdG8gc3RvcmUgcmVjb3JkZWQgYmxvYnMgaW4gSW5kZXhlZERCIHN0b3JhZ2UuXHJcbiAqIEBzdW1tYXJ5IFdyaXRpbmcgYmxvYnMgaW50byBJbmRleGVkREIuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBEaXNrU3RvcmFnZS5TdG9yZSh7XHJcbiAqICAgICBhdWRpb0Jsb2I6IHlvdXJBdWRpb0Jsb2IsXHJcbiAqICAgICB2aWRlb0Jsb2I6IHlvdXJWaWRlb0Jsb2IsXHJcbiAqICAgICBnaWZCbG9iICA6IHlvdXJHaWZCbG9iXHJcbiAqIH0pO1xyXG4gKiBEaXNrU3RvcmFnZS5GZXRjaChmdW5jdGlvbihkYXRhVVJMLCB0eXBlKSB7XHJcbiAqICAgICBpZih0eXBlID09PSAnYXVkaW9CbG9iJykgeyB9XHJcbiAqICAgICBpZih0eXBlID09PSAndmlkZW9CbG9iJykgeyB9XHJcbiAqICAgICBpZih0eXBlID09PSAnZ2lmQmxvYicpICAgeyB9XHJcbiAqIH0pO1xyXG4gKiAvLyBEaXNrU3RvcmFnZS5kYXRhU3RvcmVOYW1lID0gJ3JlY29yZFJUQyc7XHJcbiAqIC8vIERpc2tTdG9yYWdlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnJvcikgeyB9O1xyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBpbml0IC0gVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBpbml0aWFsaXplIEluZGV4ZWREQiBPYmplY3RTdG9yZS4gVGhvdWdoLCBpdCBpcyBhdXRvLXVzZWQgaW50ZXJuYWxseS5cclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gRmV0Y2ggLSBUaGlzIG1ldGhvZCBmZXRjaGVzIHN0b3JlZCBibG9icyBmcm9tIEluZGV4ZWREQi5cclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gU3RvcmUgLSBUaGlzIG1ldGhvZCBzdG9yZXMgYmxvYnMgaW4gSW5kZXhlZERCLlxyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvbkVycm9yIC0gVGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGZvciBhbnkga25vd24vdW5rbm93biBlcnJvci5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFTdG9yZU5hbWUgLSBOYW1lIG9mIHRoZSBPYmplY3RTdG9yZSBjcmVhdGVkIGluIEluZGV4ZWREQiBzdG9yYWdlLlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqL1xyXG5cclxuXHJcbnZhciBEaXNrU3RvcmFnZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBpbml0aWFsaXplIEluZGV4ZWREQiBPYmplY3RTdG9yZS4gVGhvdWdoLCBpdCBpcyBhdXRvLXVzZWQgaW50ZXJuYWxseS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBEaXNrU3RvcmFnZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogRGlza1N0b3JhZ2UuaW5pdCgpO1xyXG4gICAgICovXHJcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhlZERCID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgaW5kZXhlZERCLm9wZW4gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0luZGV4ZWREQiBBUEkgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGJWZXJzaW9uID0gMTtcclxuICAgICAgICB2YXIgZGJOYW1lID0gdGhpcy5kYk5hbWUgfHwgbG9jYXRpb24uaHJlZi5yZXBsYWNlKC9cXC98OnwjfCV8XFwufFxcW3xcXF0vZywgJycpLFxyXG4gICAgICAgICAgICBkYjtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKGRiTmFtZSwgZGJWZXJzaW9uKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0U3RvcmUoZGF0YUJhc2UpIHtcclxuICAgICAgICAgICAgZGF0YUJhc2UuY3JlYXRlT2JqZWN0U3RvcmUoc2VsZi5kYXRhU3RvcmVOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHB1dEluREIoKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtzZWxmLmRhdGFTdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi52aWRlb0Jsb2IpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuZGF0YVN0b3JlTmFtZSkucHV0KHNlbGYudmlkZW9CbG9iLCAndmlkZW9CbG9iJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmdpZkJsb2IpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuZGF0YVN0b3JlTmFtZSkucHV0KHNlbGYuZ2lmQmxvYiwgJ2dpZkJsb2InKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuYXVkaW9CbG9iKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLmRhdGFTdG9yZU5hbWUpLnB1dChzZWxmLmF1ZGlvQmxvYiwgJ2F1ZGlvQmxvYicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGcm9tU3RvcmUocG9ydGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuZGF0YVN0b3JlTmFtZSkuZ2V0KHBvcnRpb25OYW1lKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2soZXZlbnQudGFyZ2V0LnJlc3VsdCwgcG9ydGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdldEZyb21TdG9yZSgnYXVkaW9CbG9iJyk7XHJcbiAgICAgICAgICAgIGdldEZyb21TdG9yZSgndmlkZW9CbG9iJyk7XHJcbiAgICAgICAgICAgIGdldEZyb21TdG9yZSgnZ2lmQmxvYicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gc2VsZi5vbkVycm9yO1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkYiA9IHJlcXVlc3QucmVzdWx0O1xyXG4gICAgICAgICAgICBkYi5vbmVycm9yID0gc2VsZi5vbkVycm9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRiLnNldFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYi52ZXJzaW9uICE9PSBkYlZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0VmVyc2lvbiA9IGRiLnNldFZlcnNpb24oZGJWZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRWZXJzaW9uLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVPYmplY3RTdG9yZShkYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dEluREIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXRJbkRCKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdXRJbkRCKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgY3JlYXRlT2JqZWN0U3RvcmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGZldGNoZXMgc3RvcmVkIGJsb2JzIGZyb20gSW5kZXhlZERCLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIERpc2tTdG9yYWdlXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBEaXNrU3RvcmFnZS5GZXRjaChmdW5jdGlvbihkYXRhVVJMLCB0eXBlKSB7XHJcbiAgICAgKiAgICAgaWYodHlwZSA9PT0gJ2F1ZGlvQmxvYicpIHsgfVxyXG4gICAgICogICAgIGlmKHR5cGUgPT09ICd2aWRlb0Jsb2InKSB7IH1cclxuICAgICAqICAgICBpZih0eXBlID09PSAnZ2lmQmxvYicpICAgeyB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgRmV0Y2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3JlcyBibG9icyBpbiBJbmRleGVkREIuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgRGlza1N0b3JhZ2VcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIERpc2tTdG9yYWdlLlN0b3JlKHtcclxuICAgICAqICAgICBhdWRpb0Jsb2I6IHlvdXJBdWRpb0Jsb2IsXHJcbiAgICAgKiAgICAgdmlkZW9CbG9iOiB5b3VyVmlkZW9CbG9iLFxyXG4gICAgICogICAgIGdpZkJsb2IgIDogeW91ckdpZkJsb2JcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBTdG9yZTogZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb0Jsb2IgPSBjb25maWcuYXVkaW9CbG9iO1xyXG4gICAgICAgIHRoaXMudmlkZW9CbG9iID0gY29uZmlnLnZpZGVvQmxvYjtcclxuICAgICAgICB0aGlzLmdpZkJsb2IgPSBjb25maWcuZ2lmQmxvYjtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGZvciBhbnkga25vd24vdW5rbm93biBlcnJvci5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBEaXNrU3RvcmFnZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogRGlza1N0b3JhZ2Uub25FcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAqICAgICBhbGVyb3QoIEpTT04uc3RyaW5naWZ5KGVycm9yKSApO1xyXG4gICAgICogfTtcclxuICAgICAqL1xyXG4gICAgb25FcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAnXFx0JykpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhU3RvcmVOYW1lIC0gTmFtZSBvZiB0aGUgT2JqZWN0U3RvcmUgY3JlYXRlZCBpbiBJbmRleGVkREIgc3RvcmFnZS5cclxuICAgICAqIEBtZW1iZXJvZiBEaXNrU3RvcmFnZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogRGlza1N0b3JhZ2UuZGF0YVN0b3JlTmFtZSA9ICdyZWNvcmRSVEMnO1xyXG4gICAgICovXHJcbiAgICBkYXRhU3RvcmVOYW1lOiAncmVjb3JkUlRDJyxcclxuICAgIGRiTmFtZTogbnVsbFxyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBSZWNvcmRSVEMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBSZWNvcmRSVEMuRGlza1N0b3JhZ2UgPSBEaXNrU3RvcmFnZTtcclxufVxuXHJcbi8vIF9fX19fX19fX19fX19fXHJcbi8vIEdpZlJlY29yZGVyLmpzXHJcblxyXG4vKipcclxuICogR2lmUmVjb3JkZXIgaXMgc3RhbmRhbG9uZSBjYWxzcyB1c2VkIGJ5IHtAbGluayBSZWNvcmRSVEN9IHRvIHJlY29yZCB2aWRlbyBvciBjYW52YXMgaW50byBhbmltYXRlZCBnaWYuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBHaWZSZWNvcmRlclxyXG4gKiBAY2xhc3NcclxuICogQGV4YW1wbGVcclxuICogdmFyIHJlY29yZGVyID0gbmV3IEdpZlJlY29yZGVyKG1lZGlhU3RyZWFtIHx8IGNhbnZhcyB8fCBjb250ZXh0LCB7IG9uR2lmUHJldmlldzogZnVuY3Rpb24sIG9uR2lmUmVjb3JkaW5nU3RhcnRlZDogZnVuY3Rpb24sIHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMCwgZnJhbWVSYXRlOiAyMDAsIHF1YWxpdHk6IDEwIH0pO1xyXG4gKiByZWNvcmRlci5yZWNvcmQoKTtcclxuICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAqICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICogfSk7XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDfFJlY29yZFJUQyBTb3VyY2UgQ29kZX1cclxuICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gbWVkaWFTdHJlYW0gLSBNZWRpYVN0cmVhbSBvYmplY3Qgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0ge2Rpc2FibGVMb2dzOnRydWUsIGluaXRDYWxsYmFjazogZnVuY3Rpb24sIHdpZHRoOiAzMjAsIGhlaWdodDogMjQwLCBmcmFtZVJhdGU6IDIwMCwgcXVhbGl0eTogMTB9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gR2lmUmVjb3JkZXIobWVkaWFTdHJlYW0sIGNvbmZpZykge1xyXG4gICAgaWYgKHR5cGVvZiBHSUZFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vd3d3LndlYnJ0Yy1leHBlcmltZW50LmNvbS9naWYtcmVjb3JkZXIuanMnO1xyXG4gICAgICAgIChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgdmFyIGlzSFRNTE9iamVjdCA9IG1lZGlhU3RyZWFtIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHx8IG1lZGlhU3RyZWFtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZWNvcmRzIE1lZGlhU3RyZWFtLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEdpZlJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVjb3JkKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjb3JkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBHSUZFbmNvZGVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHNlbGYucmVjb3JkLCAxMDAwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0xvYWRlZE1ldGFEYXRhKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc2VsZi5yZWNvcmQsIDEwMDApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSFRNTE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLndpZHRoID0gdmlkZW8ub2Zmc2V0V2lkdGggfHwgMzIwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5oZWlnaHQgPSB2aWRlby5vZmZzZXRIZWlnaHQgfHwgMjQwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy52aWRlbykge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLnZpZGVvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5jYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5jYW52YXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNvbmZpZy5jYW52YXMud2lkdGggfHwgMzIwO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY29uZmlnLmNhbnZhcy5oZWlnaHQgfHwgMjQwO1xyXG5cclxuICAgICAgICAgICAgdmlkZW8ud2lkdGggPSBjb25maWcudmlkZW8ud2lkdGggfHwgMzIwO1xyXG4gICAgICAgICAgICB2aWRlby5oZWlnaHQgPSBjb25maWcudmlkZW8uaGVpZ2h0IHx8IDI0MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGV4dGVybmFsIGxpYnJhcnkgdG8gcmVjb3JkIGFzIEdJRiBpbWFnZXNcclxuICAgICAgICBnaWZFbmNvZGVyID0gbmV3IEdJRkVuY29kZXIoKTtcclxuXHJcbiAgICAgICAgLy8gdm9pZCBzZXRSZXBlYXQoaW50IGl0ZXIpIFxyXG4gICAgICAgIC8vIFNldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc2V0IG9mIEdJRiBmcmFtZXMgc2hvdWxkIGJlIHBsYXllZC4gXHJcbiAgICAgICAgLy8gRGVmYXVsdCBpcyAxOyAwIG1lYW5zIHBsYXkgaW5kZWZpbml0ZWx5LlxyXG4gICAgICAgIGdpZkVuY29kZXIuc2V0UmVwZWF0KDApO1xyXG5cclxuICAgICAgICAvLyB2b2lkIHNldEZyYW1lUmF0ZShOdW1iZXIgZnBzKSBcclxuICAgICAgICAvLyBTZXRzIGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQuIFxyXG4gICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gc2V0RGVsYXkoMTAwMC9mcHMpLlxyXG4gICAgICAgIC8vIFVzaW5nIFwic2V0RGVsYXlcIiBpbnN0ZWFkIG9mIFwic2V0RnJhbWVSYXRlXCJcclxuICAgICAgICBnaWZFbmNvZGVyLnNldERlbGF5KGNvbmZpZy5mcmFtZVJhdGUgfHwgMjAwKTtcclxuXHJcbiAgICAgICAgLy8gdm9pZCBzZXRRdWFsaXR5KGludCBxdWFsaXR5KSBcclxuICAgICAgICAvLyBTZXRzIHF1YWxpdHkgb2YgY29sb3IgcXVhbnRpemF0aW9uIChjb252ZXJzaW9uIG9mIGltYWdlcyB0byB0aGUgXHJcbiAgICAgICAgLy8gbWF4aW11bSAyNTYgY29sb3JzIGFsbG93ZWQgYnkgdGhlIEdJRiBzcGVjaWZpY2F0aW9uKS4gXHJcbiAgICAgICAgLy8gTG93ZXIgdmFsdWVzIChtaW5pbXVtID0gMSkgcHJvZHVjZSBiZXR0ZXIgY29sb3JzLCBcclxuICAgICAgICAvLyBidXQgc2xvdyBwcm9jZXNzaW5nIHNpZ25pZmljYW50bHkuIDEwIGlzIHRoZSBkZWZhdWx0LCBcclxuICAgICAgICAvLyBhbmQgcHJvZHVjZXMgZ29vZCBjb2xvciBtYXBwaW5nIGF0IHJlYXNvbmFibGUgc3BlZWRzLiBcclxuICAgICAgICAvLyBWYWx1ZXMgZ3JlYXRlciB0aGFuIDIwIGRvIG5vdCB5aWVsZCBzaWduaWZpY2FudCBpbXByb3ZlbWVudHMgaW4gc3BlZWQuXHJcbiAgICAgICAgZ2lmRW5jb2Rlci5zZXRRdWFsaXR5KGNvbmZpZy5xdWFsaXR5IHx8IDEwKTtcclxuXHJcbiAgICAgICAgLy8gQm9vbGVhbiBzdGFydCgpIFxyXG4gICAgICAgIC8vIFRoaXMgd3JpdGVzIHRoZSBHSUYgSGVhZGVyIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IGZhaWxzLlxyXG4gICAgICAgIGdpZkVuY29kZXIuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcub25HaWZSZWNvcmRpbmdTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5vbkdpZlJlY29yZGluZ1N0YXJ0ZWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdWaWRlb0ZyYW1lKHRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuY2xlYXJlZFJlY29yZGVkRGF0YSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNQYXVzZWRSZWNvcmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdWaWRlb0ZyYW1lKHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdWaWRlb0ZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEZyYW1lVGltZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0RnJhbWVUaW1lID0gdGltZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gfjEwIGZwc1xyXG4gICAgICAgICAgICBpZiAodGltZSAtIGxhc3RGcmFtZVRpbWUgPCA5MCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzSFRNTE9iamVjdCAmJiB2aWRlby5wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHZpYTogaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9XZWJSVEMtRXhwZXJpbWVudC9wdWxsLzMxNlxyXG4gICAgICAgICAgICAgICAgLy8gVHdlYWsgZm9yIEFuZHJvaWQgQ2hyb21lXHJcbiAgICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaXNIVE1MT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5vbkdpZlByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5vbkdpZlByZXZpZXcoY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnaWZFbmNvZGVyLmFkZEZyYW1lKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBsYXN0RnJhbWVUaW1lID0gdGltZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxhc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3VmlkZW9GcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuaW5pdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5pbml0Q2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgc3RvcHMgcmVjb3JkaW5nIE1lZGlhU3RyZWFtLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiwgdGhhdCBpcyB1c2VkIHRvIHBhc3MgcmVjb3JkZWQgYmxvYiBiYWNrIHRvIHRoZSBjYWxsZWUuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lmUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAqICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGxhc3RBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShsYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW5kVGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QmxvYn0gYmxvYiAtIFRoZSByZWNvcmRlZCBibG9iIG9iamVjdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgR2lmUmVjb3JkZXJcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIHJlY29yZGVyLnN0b3AoZnVuY3Rpb24oKXtcclxuICAgICAgICAgKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5ibG9iO1xyXG4gICAgICAgICAqIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmxvYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShnaWZFbmNvZGVyLnN0cmVhbSgpLmJpbildLCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9naWYnXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNhbGxiYWNrKHRoaXMuYmxvYik7XHJcblxyXG4gICAgICAgIC8vIGJ1ZzogZmluZCBhIHdheSB0byBjbGVhciBvbGQgcmVjb3JkZWQgYmxvYnNcclxuICAgICAgICBnaWZFbmNvZGVyLnN0cmVhbSgpLmJpbiA9IFtdO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaXNQYXVzZWRSZWNvcmRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHBhdXNlcyB0aGUgcmVjb3JkaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lmUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5wYXVzZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaXNQYXVzZWRSZWNvcmRpbmcgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc3VtZXMgdGhlIHJlY29yZGluZyBwcm9jZXNzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEdpZlJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVzdW1lKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaXNQYXVzZWRSZWNvcmRpbmcgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgY3VycmVudGx5IHJlY29yZGVkIGRhdGEuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lmUmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5jbGVhclJlY29yZGVkRGF0YSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmNsZWFyUmVjb3JkZWREYXRhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5jbGVhcmVkUmVjb3JkZWREYXRhID0gdHJ1ZTtcclxuICAgICAgICBjbGVhclJlY29yZGVkRGF0YUNCKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFyUmVjb3JkZWREYXRhQ0IoKSB7XHJcbiAgICAgICAgaWYgKGdpZkVuY29kZXIpIHtcclxuICAgICAgICAgICAgZ2lmRW5jb2Rlci5zdHJlYW0oKS5iaW4gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIGRlYnVnZ2luZ1xyXG4gICAgdGhpcy5uYW1lID0gJ0dpZlJlY29yZGVyJztcclxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGlmIChpc0hUTUxPYmplY3QpIHtcclxuICAgICAgICBpZiAobWVkaWFTdHJlYW0gaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IG1lZGlhU3RyZWFtO1xyXG4gICAgICAgICAgICBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcclxuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhU3RyZWFtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IG1lZGlhU3RyZWFtLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIGNhbnZhcyA9IG1lZGlhU3RyZWFtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNMb2FkZWRNZXRhRGF0YSA9IHRydWU7XHJcblxyXG4gICAgaWYgKCFpc0hUTUxPYmplY3QpIHtcclxuICAgICAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcclxuICAgICAgICB2aWRlby5hdXRvcGxheSA9IHRydWU7XHJcbiAgICAgICAgdmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xyXG5cclxuICAgICAgICBpc0xvYWRlZE1ldGFEYXRhID0gZmFsc2U7XHJcbiAgICAgICAgdmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpc0xvYWRlZE1ldGFEYXRhID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzZXRTcmNPYmplY3QobWVkaWFTdHJlYW0sIHZpZGVvKTtcclxuXHJcbiAgICAgICAgdmlkZW8ucGxheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsYXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG4gICAgdmFyIHN0YXJ0VGltZSwgZW5kVGltZSwgbGFzdEZyYW1lVGltZTtcclxuXHJcbiAgICB2YXIgZ2lmRW5jb2RlcjtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLkdpZlJlY29yZGVyID0gR2lmUmVjb3JkZXI7XHJcbn1cblxyXG4vLyBMYXN0IHRpbWUgdXBkYXRlZDogMjAxOS0wNi0yMSA0OjA5OjQyIEFNIFVUQ1xyXG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fX19fXHJcbi8vIE11bHRpU3RyZWFtc01peGVyIHYxLjIuMlxyXG5cclxuLy8gT3Blbi1Tb3VyY2VkOiBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL011bHRpU3RyZWFtc01peGVyXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBNdWF6IEtoYW4gICAgIC0gd3d3Lk11YXpLaGFuLmNvbVxyXG4vLyBNSVQgTGljZW5zZSAgIC0gd3d3LldlYlJUQy1FeHBlcmltZW50LmNvbS9saWNlbmNlXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5mdW5jdGlvbiBNdWx0aVN0cmVhbXNNaXhlcihhcnJheU9mTWVkaWFTdHJlYW1zLCBlbGVtZW50Q2xhc3MpIHtcclxuXHJcbiAgICB2YXIgYnJvd3NlckZha2VVc2VyQWdlbnQgPSAnRmFrZS81LjAgKEZha2VPUykgQXBwbGVXZWJLaXQvMTIzIChLSFRNTCwgbGlrZSBHZWNrbykgRmFrZS8xMi4zLjQ1NjcuODkgRmFrZS8xMjMuNDUnO1xyXG5cclxuICAgIChmdW5jdGlvbih0aGF0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWNvcmRSVEMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhhdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsb2JhbC5uYXZpZ2F0b3IgPSB7XHJcbiAgICAgICAgICAgIHVzZXJBZ2VudDogYnJvd3NlckZha2VVc2VyQWdlbnQsXHJcbiAgICAgICAgICAgIGdldFVzZXJNZWRpYTogZnVuY3Rpb24oKSB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghZ2xvYmFsLmNvbnNvbGUpIHtcclxuICAgICAgICAgICAgZ2xvYmFsLmNvbnNvbGUgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsLmNvbnNvbGUubG9nID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZ2xvYmFsLmNvbnNvbGUuZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbC5jb25zb2xlLmVycm9yID0gZ2xvYmFsLmNvbnNvbGUubG9nID0gZ2xvYmFsLmNvbnNvbGUubG9nIHx8IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8qZ2xvYmFsIGRvY3VtZW50OnRydWUgKi9cclxuICAgICAgICAgICAgdGhhdC5kb2N1bWVudCA9IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jYXB0dXJlU3RyZWFtID0gZG9jdW1lbnQubW96Q2FwdHVyZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd0ltYWdlOiBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7fVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGF0LkhUTUxWaWRlb0VsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLypnbG9iYWwgbG9jYXRpb246dHJ1ZSAqL1xyXG4gICAgICAgICAgICB0aGF0LmxvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2w6ICdmaWxlOicsXHJcbiAgICAgICAgICAgICAgICBocmVmOiAnJyxcclxuICAgICAgICAgICAgICAgIGhhc2g6ICcnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHNjcmVlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLypnbG9iYWwgc2NyZWVuOnRydWUgKi9cclxuICAgICAgICAgICAgdGhhdC5zY3JlZW4gPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBVUkwgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8qZ2xvYmFsIHNjcmVlbjp0cnVlICovXHJcbiAgICAgICAgICAgIHRoYXQuVVJMID0ge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlT2JqZWN0VVJMOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmV2b2tlT2JqZWN0VVJMOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKmdsb2JhbCB3aW5kb3c6dHJ1ZSAqL1xyXG4gICAgICAgIHRoYXQud2luZG93ID0gZ2xvYmFsO1xyXG4gICAgfSkodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBudWxsKTtcclxuXHJcbiAgICAvLyByZXF1aXJlczogY2hyb21lOi8vZmxhZ3MvI2VuYWJsZS1leHBlcmltZW50YWwtd2ViLXBsYXRmb3JtLWZlYXR1cmVzXHJcblxyXG4gICAgZWxlbWVudENsYXNzID0gZWxlbWVudENsYXNzIHx8ICdtdWx0aS1zdHJlYW1zLW1peGVyJztcclxuXHJcbiAgICB2YXIgdmlkZW9zID0gW107XHJcbiAgICB2YXIgaXNTdG9wRHJhd2luZ0ZyYW1lcyA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IC0xO1xyXG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICctMTAwMGVtJztcclxuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJy0xMDAwZW0nO1xyXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9IGVsZW1lbnRDbGFzcztcclxuICAgIChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuXHJcbiAgICB0aGlzLmRpc2FibGVMb2dzID0gZmFsc2U7XHJcbiAgICB0aGlzLmZyYW1lSW50ZXJ2YWwgPSAxMDtcclxuXHJcbiAgICB0aGlzLndpZHRoID0gMzYwO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAyNDA7XHJcblxyXG4gICAgLy8gdXNlIGdhaW4gbm9kZSB0byBwcmV2ZW50IGVjaG9cclxuICAgIHRoaXMudXNlR2Fpbk5vZGUgPSB0cnVlO1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvLyBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xyXG4gICAgLy8gQ3Jvc3MtQnJvd3Nlci1EZWNsYXJhdGlvbnMuanNcclxuXHJcbiAgICAvLyBXZWJBdWRpbyBBUEkgcmVwcmVzZW50ZXJcclxuICAgIHZhciBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0O1xyXG5cclxuICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2Via2l0QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvKmdsb2JhbCBBdWRpb0NvbnRleHQ6dHJ1ZSAqL1xyXG4gICAgICAgICAgICBBdWRpb0NvbnRleHQgPSB3ZWJraXRBdWRpb0NvbnRleHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG1vekF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLypnbG9iYWwgQXVkaW9Db250ZXh0OnRydWUgKi9cclxuICAgICAgICAgICAgQXVkaW9Db250ZXh0ID0gbW96QXVkaW9Db250ZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKmpzaGludCAtVzA3OSAqL1xyXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkw7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBVUkwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3ZWJraXRVUkwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLypnbG9iYWwgVVJMOnRydWUgKi9cclxuICAgICAgICBVUkwgPSB3ZWJraXRVUkw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID09PSAndW5kZWZpbmVkJykgeyAvLyBtYXliZSB3aW5kb3cubmF2aWdhdG9yP1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW07XHJcblxyXG4gICAgaWYgKHR5cGVvZiBNZWRpYVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdlYmtpdE1lZGlhU3RyZWFtICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIE1lZGlhU3RyZWFtID0gd2Via2l0TWVkaWFTdHJlYW07XHJcbiAgICB9XHJcblxyXG4gICAgLypnbG9iYWwgTWVkaWFTdHJlYW06dHJ1ZSAqL1xyXG4gICAgaWYgKHR5cGVvZiBNZWRpYVN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBvdmVycmlkZSBcInN0b3BcIiBtZXRob2QgZm9yIGFsbCBicm93c2Vyc1xyXG4gICAgICAgIGlmICh0eXBlb2YgTWVkaWFTdHJlYW0ucHJvdG90eXBlLnN0b3AgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIE1lZGlhU3RyZWFtLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBTdG9yYWdlLkF1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dDtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBTdG9yYWdlLkF1ZGlvQ29udGV4dCA9IHdlYmtpdEF1ZGlvQ29udGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTcmNPYmplY3Qoc3RyZWFtLCBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCdzcmNPYmplY3QnIGluIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XHJcbiAgICAgICAgfSBlbHNlIGlmICgnbW96U3JjT2JqZWN0JyBpbiBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQubW96U3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRyYXdWaWRlb3NUb0NhbnZhcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3VmlkZW9zVG9DYW52YXMoKSB7XHJcbiAgICAgICAgaWYgKGlzU3RvcERyYXdpbmdGcmFtZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHZpZGVvc0xlbmd0aCA9IHZpZGVvcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhciBmdWxsY2FudmFzID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xyXG4gICAgICAgIHZpZGVvcy5mb3JFYWNoKGZ1bmN0aW9uKHZpZGVvKSB7XHJcbiAgICAgICAgICAgIGlmICghdmlkZW8uc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICB2aWRlby5zdHJlYW0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvLnN0cmVhbS5mdWxsY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxsY2FudmFzID0gdmlkZW87XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiB2aWRlby5zdHJlYW0uYWN0aXZlIG9yIHZpZGVvLnN0cmVhbS5saXZlIHRvIGZpeCBibGFuayBmcmFtZXMgaXNzdWVzP1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2godmlkZW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChmdWxsY2FudmFzKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGZ1bGxjYW52YXMuc3RyZWFtLndpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZnVsbGNhbnZhcy5zdHJlYW0uaGVpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB2aWRlb3NMZW5ndGggPiAxID8gcmVtYWluaW5nWzBdLndpZHRoICogMiA6IHJlbWFpbmluZ1swXS53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAxO1xyXG4gICAgICAgICAgICBpZiAodmlkZW9zTGVuZ3RoID09PSAzIHx8IHZpZGVvc0xlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlkZW9zTGVuZ3RoID09PSA1IHx8IHZpZGVvc0xlbmd0aCA9PT0gNikge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gMztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlkZW9zTGVuZ3RoID09PSA3IHx8IHZpZGVvc0xlbmd0aCA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmlkZW9zTGVuZ3RoID09PSA5IHx8IHZpZGVvc0xlbmd0aCA9PT0gMTApIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IDU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlbWFpbmluZ1swXS5oZWlnaHQgKiBoZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gc2VsZi53aWR0aCB8fCAzNjA7XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzZWxmLmhlaWdodCB8fCAyNDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZnVsbGNhbnZhcyAmJiBmdWxsY2FudmFzIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgICAgICAgICBkcmF3SW1hZ2UoZnVsbGNhbnZhcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW1haW5pbmcuZm9yRWFjaChmdW5jdGlvbih2aWRlbywgaWR4KSB7XHJcbiAgICAgICAgICAgIGRyYXdJbWFnZSh2aWRlbywgaWR4KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dChkcmF3VmlkZW9zVG9DYW52YXMsIHNlbGYuZnJhbWVJbnRlcnZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0ltYWdlKHZpZGVvLCBpZHgpIHtcclxuICAgICAgICBpZiAoaXNTdG9wRHJhd2luZ0ZyYW1lcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHZpZGVvLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB2aWRlby5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChpZHggPT09IDEpIHtcclxuICAgICAgICAgICAgeCA9IHZpZGVvLndpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlkeCA9PT0gMikge1xyXG4gICAgICAgICAgICB5ID0gdmlkZW8uaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlkeCA9PT0gMykge1xyXG4gICAgICAgICAgICB4ID0gdmlkZW8ud2lkdGg7XHJcbiAgICAgICAgICAgIHkgPSB2aWRlby5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaWR4ID09PSA0KSB7XHJcbiAgICAgICAgICAgIHkgPSB2aWRlby5oZWlnaHQgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlkeCA9PT0gNSkge1xyXG4gICAgICAgICAgICB4ID0gdmlkZW8ud2lkdGg7XHJcbiAgICAgICAgICAgIHkgPSB2aWRlby5oZWlnaHQgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlkeCA9PT0gNikge1xyXG4gICAgICAgICAgICB5ID0gdmlkZW8uaGVpZ2h0ICogMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpZHggPT09IDcpIHtcclxuICAgICAgICAgICAgeCA9IHZpZGVvLndpZHRoO1xyXG4gICAgICAgICAgICB5ID0gdmlkZW8uaGVpZ2h0ICogMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW8uc3RyZWFtLmxlZnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHggPSB2aWRlby5zdHJlYW0ubGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW8uc3RyZWFtLnRvcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgeSA9IHZpZGVvLnN0cmVhbS50b3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZpZGVvLnN0cmVhbS53aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgd2lkdGggPSB2aWRlby5zdHJlYW0ud2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZpZGVvLnN0cmVhbS5oZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHZpZGVvLnN0cmVhbS5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlbywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW8uc3RyZWFtLm9uUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZpZGVvLnN0cmVhbS5vblJlbmRlcihjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBpZHgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNaXhlZFN0cmVhbSgpIHtcclxuICAgICAgICBpc1N0b3BEcmF3aW5nRnJhbWVzID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG1peGVkVmlkZW9TdHJlYW0gPSBnZXRNaXhlZFZpZGVvU3RyZWFtKCk7XHJcblxyXG4gICAgICAgIHZhciBtaXhlZEF1ZGlvU3RyZWFtID0gZ2V0TWl4ZWRBdWRpb1N0cmVhbSgpO1xyXG4gICAgICAgIGlmIChtaXhlZEF1ZGlvU3RyZWFtKSB7XHJcbiAgICAgICAgICAgIG1peGVkQXVkaW9TdHJlYW0uZ2V0VHJhY2tzKCkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0LmtpbmQgPT09ICdhdWRpbyc7XHJcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcclxuICAgICAgICAgICAgICAgIG1peGVkVmlkZW9TdHJlYW0uYWRkVHJhY2sodHJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmdWxsY2FudmFzO1xyXG4gICAgICAgIGFycmF5T2ZNZWRpYVN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcclxuICAgICAgICAgICAgaWYgKHN0cmVhbS5mdWxsY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxsY2FudmFzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBtaXhlZFZpZGVvU3RyZWFtLnByb3RvdHlwZS5hcHBlbmRTdHJlYW1zID0gYXBwZW5kU3RyZWFtcztcclxuICAgICAgICAvLyBtaXhlZFZpZGVvU3RyZWFtLnByb3RvdHlwZS5yZXNldFZpZGVvU3RyZWFtcyA9IHJlc2V0VmlkZW9TdHJlYW1zO1xyXG4gICAgICAgIC8vIG1peGVkVmlkZW9TdHJlYW0ucHJvdG90eXBlLmNsZWFyUmVjb3JkZWREYXRhID0gY2xlYXJSZWNvcmRlZERhdGE7XHJcblxyXG4gICAgICAgIHJldHVybiBtaXhlZFZpZGVvU3RyZWFtO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1peGVkVmlkZW9TdHJlYW0oKSB7XHJcbiAgICAgICAgcmVzZXRWaWRlb1N0cmVhbXMoKTtcclxuXHJcbiAgICAgICAgdmFyIGNhcHR1cmVkU3RyZWFtO1xyXG5cclxuICAgICAgICBpZiAoJ2NhcHR1cmVTdHJlYW0nIGluIGNhbnZhcykge1xyXG4gICAgICAgICAgICBjYXB0dXJlZFN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICgnbW96Q2FwdHVyZVN0cmVhbScgaW4gY2FudmFzKSB7XHJcbiAgICAgICAgICAgIGNhcHR1cmVkU3RyZWFtID0gY2FudmFzLm1vekNhcHR1cmVTdHJlYW0oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFzZWxmLmRpc2FibGVMb2dzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VwZ3JhZGUgdG8gbGF0ZXN0IENocm9tZSBvciBvdGhlcndpc2UgZW5hYmxlIHRoaXMgZmxhZzogY2hyb21lOi8vZmxhZ3MvI2VuYWJsZS1leHBlcmltZW50YWwtd2ViLXBsYXRmb3JtLWZlYXR1cmVzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmlkZW9TdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuXHJcbiAgICAgICAgY2FwdHVyZWRTdHJlYW0uZ2V0VHJhY2tzKCkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gJ3ZpZGVvJztcclxuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XHJcbiAgICAgICAgICAgIHZpZGVvU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2FudmFzLnN0cmVhbSA9IHZpZGVvU3RyZWFtO1xyXG5cclxuICAgICAgICByZXR1cm4gdmlkZW9TdHJlYW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TWl4ZWRBdWRpb1N0cmVhbSgpIHtcclxuICAgICAgICAvLyB2aWE6IEBwZWhyc29uc1xyXG4gICAgICAgIGlmICghU3RvcmFnZS5BdWRpb0NvbnRleHRDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBTdG9yYWdlLkF1ZGlvQ29udGV4dENvbnN0cnVjdG9yID0gbmV3IFN0b3JhZ2UuQXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmF1ZGlvQ29udGV4dCA9IFN0b3JhZ2UuQXVkaW9Db250ZXh0Q29uc3RydWN0b3I7XHJcblxyXG4gICAgICAgIHNlbGYuYXVkaW9Tb3VyY2VzID0gW107XHJcblxyXG4gICAgICAgIGlmIChzZWxmLnVzZUdhaW5Ob2RlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZ2Fpbk5vZGUgPSBzZWxmLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgICAgIHNlbGYuZ2Fpbk5vZGUuY29ubmVjdChzZWxmLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgIHNlbGYuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7IC8vIGRvbid0IGhlYXIgc2VsZlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tzTGVuZ3RoID0gMDtcclxuICAgICAgICBhcnJheU9mTWVkaWFTdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RyZWFtLmdldFRyYWNrcygpLmZpbHRlcihmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gJ2F1ZGlvJztcclxuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhdWRpb1RyYWNrc0xlbmd0aCsrO1xyXG5cclxuICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlID0gc2VsZi5hdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLnVzZUdhaW5Ob2RlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpb1NvdXJjZS5jb25uZWN0KHNlbGYuZ2Fpbk5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmF1ZGlvU291cmNlcy5wdXNoKGF1ZGlvU291cmNlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFhdWRpb1RyYWNrc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIFwic2VsZi5hdWRpb0NvbnRleHRcIiBpcyBub3QgaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgLy8gdGhhdCdzIHdoeSB3ZSd2ZSB0byBpZ25vcmUgcmVzdCBvZiB0aGUgY29kZVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmF1ZGlvRGVzdGluYXRpb24gPSBzZWxmLmF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XHJcbiAgICAgICAgc2VsZi5hdWRpb1NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihhdWRpb1NvdXJjZSkge1xyXG4gICAgICAgICAgICBhdWRpb1NvdXJjZS5jb25uZWN0KHNlbGYuYXVkaW9EZXN0aW5hdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuYXVkaW9EZXN0aW5hdGlvbi5zdHJlYW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VmlkZW8oc3RyZWFtKSB7XHJcbiAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuXHJcbiAgICAgICAgc2V0U3JjT2JqZWN0KHN0cmVhbSwgdmlkZW8pO1xyXG5cclxuICAgICAgICB2aWRlby5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3M7XHJcblxyXG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcclxuICAgICAgICB2aWRlby52b2x1bWUgPSAwO1xyXG5cclxuICAgICAgICB2aWRlby53aWR0aCA9IHN0cmVhbS53aWR0aCB8fCBzZWxmLndpZHRoIHx8IDM2MDtcclxuICAgICAgICB2aWRlby5oZWlnaHQgPSBzdHJlYW0uaGVpZ2h0IHx8IHNlbGYuaGVpZ2h0IHx8IDI0MDtcclxuXHJcbiAgICAgICAgdmlkZW8ucGxheSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmlkZW87XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hcHBlbmRTdHJlYW1zID0gZnVuY3Rpb24oc3RyZWFtcykge1xyXG4gICAgICAgIGlmICghc3RyZWFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyAnRmlyc3QgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIShzdHJlYW1zIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbXMgPSBbc3RyZWFtc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5raW5kID09PSAndmlkZW8nO1xyXG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlkZW8gPSBnZXRWaWRlbyhzdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgdmlkZW8uc3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgdmlkZW9zLnB1c2godmlkZW8pO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld1N0cmVhbS5hZGRUcmFjayhzdHJlYW0uZ2V0VHJhY2tzKCkuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5raW5kID09PSAndmlkZW8nO1xyXG4gICAgICAgICAgICAgICAgfSlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmZpbHRlcihmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gJ2F1ZGlvJztcclxuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlID0gc2VsZi5hdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuYXVkaW9EZXN0aW5hdGlvbiA9IHNlbGYuYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGF1ZGlvU291cmNlLmNvbm5lY3Qoc2VsZi5hdWRpb0Rlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXdTdHJlYW0uYWRkVHJhY2soc2VsZi5hdWRpb0Rlc3RpbmF0aW9uLnN0cmVhbS5nZXRUcmFja3MoKS5maWx0ZXIoZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmtpbmQgPT09ICdhdWRpbyc7XHJcbiAgICAgICAgICAgICAgICB9KVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFycmF5T2ZNZWRpYVN0cmVhbXMucHVzaChuZXdTdHJlYW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnJlbGVhc2VTdHJlYW1zID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmlkZW9zID0gW107XHJcbiAgICAgICAgaXNTdG9wRHJhd2luZ0ZyYW1lcyA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmdhaW5Ob2RlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBzZWxmLmdhaW5Ob2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmF1ZGlvU291cmNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc2VsZi5hdWRpb1NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZWxmLmF1ZGlvU291cmNlcyA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYuYXVkaW9EZXN0aW5hdGlvbikge1xyXG4gICAgICAgICAgICBzZWxmLmF1ZGlvRGVzdGluYXRpb24uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBzZWxmLmF1ZGlvRGVzdGluYXRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYuYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuYXVkaW9Db250ZXh0LmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLmF1ZGlvQ29udGV4dCA9IG51bGw7XHJcblxyXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmIChjYW52YXMuc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zdHJlYW0uc3RvcCgpO1xyXG4gICAgICAgICAgICBjYW52YXMuc3RyZWFtID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucmVzZXRWaWRlb1N0cmVhbXMgPSBmdW5jdGlvbihzdHJlYW1zKSB7XHJcbiAgICAgICAgaWYgKHN0cmVhbXMgJiYgIShzdHJlYW1zIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbXMgPSBbc3RyZWFtc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXNldFZpZGVvU3RyZWFtcyhzdHJlYW1zKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRWaWRlb1N0cmVhbXMoc3RyZWFtcykge1xyXG4gICAgICAgIHZpZGVvcyA9IFtdO1xyXG4gICAgICAgIHN0cmVhbXMgPSBzdHJlYW1zIHx8IGFycmF5T2ZNZWRpYVN0cmVhbXM7XHJcblxyXG4gICAgICAgIC8vIHZpYTogQGFkcmlhbi1iZXJcclxuICAgICAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RyZWFtLmdldFRyYWNrcygpLmZpbHRlcihmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQua2luZCA9PT0gJ3ZpZGVvJztcclxuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdmlkZW8gPSBnZXRWaWRlbyhzdHJlYW0pO1xyXG4gICAgICAgICAgICB2aWRlby5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgICAgIHZpZGVvcy5wdXNoKHZpZGVvKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICB0aGlzLm5hbWUgPSAnTXVsdGlTdHJlYW1zTWl4ZXInO1xyXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0TWl4ZWRTdHJlYW0gPSBnZXRNaXhlZFN0cmVhbTtcclxuXHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnIC8qICYmICEhbW9kdWxlLmV4cG9ydHMqLyApIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE11bHRpU3RyZWFtc01peGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoJ011bHRpU3RyZWFtc01peGVyJywgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlTdHJlYW1zTWl4ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxyXG4vLyBfX19fX19fX19fX19fX19fX19fX19fXHJcbi8vIE11bHRpU3RyZWFtUmVjb3JkZXIuanNcclxuXHJcbi8qXHJcbiAqIFZpZGVvIGNvbmZlcmVuY2UgcmVjb3JkaW5nLCB1c2luZyBjYXB0dXJlU3RyZWFtIEFQSSBhbG9uZyB3aXRoIFdlYkF1ZGlvIGFuZCBDYW52YXMyRCBBUEkuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE11bHRpU3RyZWFtUmVjb3JkZXIgY2FuIHJlY29yZCBtdWx0aXBsZSB2aWRlb3MgaW4gc2luZ2xlIGNvbnRhaW5lci5cclxuICogQHN1bW1hcnkgTXVsdGktdmlkZW9zIHJlY29yZGVyLlxyXG4gKiBAbGljZW5zZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVR9XHJcbiAqIEBhdXRob3Ige0BsaW5rIGh0dHBzOi8vTXVhektoYW4uY29tfE11YXogS2hhbn1cclxuICogQHR5cGVkZWYgTXVsdGlTdHJlYW1SZWNvcmRlclxyXG4gKiBAY2xhc3NcclxuICogQGV4YW1wbGVcclxuICogdmFyIG9wdGlvbnMgPSB7XHJcbiAqICAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm0nXHJcbiAqIH1cclxuICogdmFyIHJlY29yZGVyID0gbmV3IE11bHRpU3RyZWFtUmVjb3JkZXIoQXJyYXlPZk1lZGlhU3RyZWFtcywgb3B0aW9ucyk7XHJcbiAqIHJlY29yZGVyLnJlY29yZCgpO1xyXG4gKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICogICAgIHZpZGVvLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAqXHJcbiAqICAgICAvLyBvclxyXG4gKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5ibG9iO1xyXG4gKiB9KTtcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9SZWNvcmRSVEN8UmVjb3JkUlRDIFNvdXJjZSBDb2RlfVxyXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtc30gbWVkaWFTdHJlYW1zIC0gQXJyYXkgb2YgTWVkaWFTdHJlYW1zLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0ge2Rpc2FibGVMb2dzOnRydWUsIGZyYW1lSW50ZXJ2YWw6IDEsIG1pbWVUeXBlOiBcInZpZGVvL3dlYm1cIn1cclxuICovXHJcblxyXG5mdW5jdGlvbiBNdWx0aVN0cmVhbVJlY29yZGVyKGFycmF5T2ZNZWRpYVN0cmVhbXMsIG9wdGlvbnMpIHtcclxuICAgIGFycmF5T2ZNZWRpYVN0cmVhbXMgPSBhcnJheU9mTWVkaWFTdHJlYW1zIHx8IFtdO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBtaXhlcjtcclxuICAgIHZhciBtZWRpYVJlY29yZGVyO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcclxuICAgICAgICBlbGVtZW50Q2xhc3M6ICdtdWx0aS1zdHJlYW1zLW1peGVyJyxcclxuICAgICAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm0nLFxyXG4gICAgICAgIHZpZGVvOiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAzNjAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMjQwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMuZnJhbWVJbnRlcnZhbCkge1xyXG4gICAgICAgIG9wdGlvbnMuZnJhbWVJbnRlcnZhbCA9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghb3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgIG9wdGlvbnMudmlkZW8gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9wdGlvbnMudmlkZW8ud2lkdGgpIHtcclxuICAgICAgICBvcHRpb25zLnZpZGVvLndpZHRoID0gMzYwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghb3B0aW9ucy52aWRlby5oZWlnaHQpIHtcclxuICAgICAgICBvcHRpb25zLnZpZGVvLmhlaWdodCA9IDI0MDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlY29yZHMgYWxsIE1lZGlhU3RyZWFtcy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVjb3JkKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjb3JkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZ2l0aHViL211YXota2hhbi9NdWx0aVN0cmVhbXNNaXhlclxyXG4gICAgICAgIG1peGVyID0gbmV3IE11bHRpU3RyZWFtc01peGVyKGFycmF5T2ZNZWRpYVN0cmVhbXMsIG9wdGlvbnMuZWxlbWVudENsYXNzIHx8ICdtdWx0aS1zdHJlYW1zLW1peGVyJyk7XHJcblxyXG4gICAgICAgIGlmIChnZXRBbGxWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtaXhlci5mcmFtZUludGVydmFsID0gb3B0aW9ucy5mcmFtZUludGVydmFsIHx8IDEwO1xyXG4gICAgICAgICAgICBtaXhlci53aWR0aCA9IG9wdGlvbnMudmlkZW8ud2lkdGggfHwgMzYwO1xyXG4gICAgICAgICAgICBtaXhlci5oZWlnaHQgPSBvcHRpb25zLnZpZGVvLmhlaWdodCB8fCAyNDA7XHJcbiAgICAgICAgICAgIG1peGVyLnN0YXJ0RHJhd2luZ0ZyYW1lcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJldmlld1N0cmVhbSAmJiB0eXBlb2Ygb3B0aW9ucy5wcmV2aWV3U3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucHJldmlld1N0cmVhbShtaXhlci5nZXRNaXhlZFN0cmVhbSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlY29yZCB1c2luZyBNZWRpYVJlY29yZGVyIEFQSVxyXG4gICAgICAgIG1lZGlhUmVjb3JkZXIgPSBuZXcgTWVkaWFTdHJlYW1SZWNvcmRlcihtaXhlci5nZXRNaXhlZFN0cmVhbSgpLCBvcHRpb25zKTtcclxuICAgICAgICBtZWRpYVJlY29yZGVyLnJlY29yZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRBbGxWaWRlb1RyYWNrcygpIHtcclxuICAgICAgICB2YXIgdHJhY2tzID0gW107XHJcbiAgICAgICAgYXJyYXlPZk1lZGlhU3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSkge1xyXG4gICAgICAgICAgICBnZXRUcmFja3Moc3RyZWFtLCAndmlkZW8nKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFja3MucHVzaCh0cmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cmFja3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzdG9wcyByZWNvcmRpbmcgTWVkaWFTdHJlYW0uXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uLCB0aGF0IGlzIHVzZWQgdG8gcGFzcyByZWNvcmRlZCBibG9iIGJhY2sgdG8gdGhlIGNhbGxlZS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcChmdW5jdGlvbihibG9iKSB7XHJcbiAgICAgKiAgICAgdmlkZW8uc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghbWVkaWFSZWNvcmRlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtZWRpYVJlY29yZGVyLnN0b3AoZnVuY3Rpb24oYmxvYikge1xyXG4gICAgICAgICAgICBzZWxmLmJsb2IgPSBibG9iO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soYmxvYik7XHJcblxyXG4gICAgICAgICAgICBzZWxmLmNsZWFyUmVjb3JkZWREYXRhKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcGF1c2VzIHRoZSByZWNvcmRpbmcgcHJvY2Vzcy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucGF1c2UoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIucGF1c2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVzdW1lcyB0aGUgcmVjb3JkaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgTXVsdGlTdHJlYW1SZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnJlc3VtZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBjdXJyZW50bHkgcmVjb3JkZWQgZGF0YS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGVhclJlY29yZGVkRGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChtZWRpYVJlY29yZGVyKSB7XHJcbiAgICAgICAgICAgIG1lZGlhUmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAgICAgICAgbWVkaWFSZWNvcmRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWl4ZXIpIHtcclxuICAgICAgICAgICAgbWl4ZXIucmVsZWFzZVN0cmVhbXMoKTtcclxuICAgICAgICAgICAgbWl4ZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgZXh0cmEgbWVkaWEtc3RyZWFtcyB0byBleGlzdGluZyByZWNvcmRpbmdzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE11bHRpU3RyZWFtUmVjb3JkZXJcclxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1zfSBtZWRpYVN0cmVhbXMgLSBBcnJheSBvZiBNZWRpYVN0cmVhbXNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5hZGRTdHJlYW1zKFtuZXdBdWRpb1N0cmVhbSwgbmV3VmlkZW9TdHJlYW1dKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5hZGRTdHJlYW1zID0gZnVuY3Rpb24oc3RyZWFtcykge1xyXG4gICAgICAgIGlmICghc3RyZWFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyAnRmlyc3QgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIShzdHJlYW1zIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHN0cmVhbXMgPSBbc3RyZWFtc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcnJheU9mTWVkaWFTdHJlYW1zLmNvbmNhdChzdHJlYW1zKTtcclxuXHJcbiAgICAgICAgaWYgKCFtZWRpYVJlY29yZGVyIHx8ICFtaXhlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtaXhlci5hcHBlbmRTdHJlYW1zKHN0cmVhbXMpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5wcmV2aWV3U3RyZWFtICYmIHR5cGVvZiBvcHRpb25zLnByZXZpZXdTdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wcmV2aWV3U3RyZWFtKG1peGVyLmdldE1peGVkU3RyZWFtKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB2aWRlb3MgZHVyaW5nIGxpdmUgcmVjb3JkaW5nLiBSZXBsYWNlIG9sZCB2aWRlb3MgZS5nLiByZXBsYWNlIGNhbWVyYXMgd2l0aCBmdWxsLXNjcmVlbi5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtc30gbWVkaWFTdHJlYW1zIC0gQXJyYXkgb2YgTWVkaWFTdHJlYW1zXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVzZXRWaWRlb1N0cmVhbXMoW25ld1ZpZGVvMSwgbmV3VmlkZW8yXSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzZXRWaWRlb1N0cmVhbXMgPSBmdW5jdGlvbihzdHJlYW1zKSB7XHJcbiAgICAgICAgaWYgKCFtaXhlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyZWFtcyAmJiAhKHN0cmVhbXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgc3RyZWFtcyA9IFtzdHJlYW1zXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1peGVyLnJlc2V0VmlkZW9TdHJlYW1zKHN0cmVhbXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgTXVsdGlTdHJlYW1zTWl4ZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBNdWx0aVN0cmVhbVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbGV0IG1peGVyID0gcmVjb3JkZXIuZ2V0TWl4ZXIoKTtcclxuICAgICAqIG1peGVyLmFwcGVuZFN0cmVhbXMoW25ld1N0cmVhbV0pO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmdldE1peGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1peGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBmb3IgZGVidWdnaW5nXHJcbiAgICB0aGlzLm5hbWUgPSAnTXVsdGlTdHJlYW1SZWNvcmRlcic7XHJcbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH07XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLk11bHRpU3RyZWFtUmVjb3JkZXIgPSBNdWx0aVN0cmVhbVJlY29yZGVyO1xyXG59XG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fXHJcbi8vIFJlY29yZFJUQy5wcm9taXNlcy5qc1xyXG5cclxuLyoqXHJcbiAqIFJlY29yZFJUQ1Byb21pc2VzSGFuZGxlciBhZGRzIHByb21pc2VzIHN1cHBvcnQgaW4ge0BsaW5rIFJlY29yZFJUQ30uIFRyeSBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9zaW1wbGUtZGVtb3MvUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyLmh0bWx8ZGVtbyBoZXJlfVxyXG4gKiBAc3VtbWFyeSBQcm9taXNlcyBmb3Ige0BsaW5rIFJlY29yZFJUQ31cclxuICogQGxpY2Vuc2Uge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWF6LWtoYW4vUmVjb3JkUlRDL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUfVxyXG4gKiBAYXV0aG9yIHtAbGluayBodHRwczovL011YXpLaGFuLmNvbXxNdWF6IEtoYW59XHJcbiAqIEB0eXBlZGVmIFJlY29yZFJUQ1Byb21pc2VzSGFuZGxlclxyXG4gKiBAY2xhc3NcclxuICogQGV4YW1wbGVcclxuICogdmFyIHJlY29yZGVyID0gbmV3IFJlY29yZFJUQ1Byb21pc2VzSGFuZGxlcihtZWRpYVN0cmVhbSwgb3B0aW9ucyk7XHJcbiAqIHJlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKClcclxuICogICAgICAgICAudGhlbihzdWNjZXNzQ0IpXHJcbiAqICAgICAgICAgLmNhdGNoKGVycm9yQ0IpO1xyXG4gKiAvLyBOb3RlOiBZb3UgY2FuIGFjY2VzcyBhbGwgUmVjb3JkUlRDIEFQSSB1c2luZyBcInJlY29yZGVyLnJlY29yZFJUQ1wiIGUuZy4gXHJcbiAqIHJlY29yZGVyLnJlY29yZFJUQy5vblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7fTtcclxuICogcmVjb3JkZXIucmVjb3JkUlRDLnNldFJlY29yZGluZ0R1cmF0aW9uKDUwMDApO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG1lZGlhU3RyZWFtIC0gU2luZ2xlIG1lZGlhLXN0cmVhbSBvYmplY3QsIGFycmF5IG9mIG1lZGlhLXN0cmVhbXMsIGh0bWwtY2FudmFzLWVsZW1lbnQsIGV0Yy5cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIHt0eXBlOlwidmlkZW9cIiwgcmVjb3JkZXJUeXBlOiBNZWRpYVN0cmVhbVJlY29yZGVyLCBkaXNhYmxlTG9nczogdHJ1ZSwgbnVtYmVyT2ZBdWRpb0NoYW5uZWxzOiAxLCBidWZmZXJTaXplOiAwLCBzYW1wbGVSYXRlOiAwLCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgZXRjLn1cclxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIFwibmV3XCIga2V5d29yZCBpcyBub3QgdXNlZCB0byBpbml0aWF0ZSBcIlJlY29yZFJUQ1Byb21pc2VzSGFuZGxlclwiLiBBbHNvIHRocm93cyBlcnJvciBpZiBmaXJzdCBhcmd1bWVudCBcIk1lZGlhU3RyZWFtXCIgaXMgbWlzc2luZy5cclxuICogQHJlcXVpcmVzIHtAbGluayBSZWNvcmRSVEN9XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyKG1lZGlhU3RyZWFtLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIXRoaXMpIHtcclxuICAgICAgICB0aHJvdyAnVXNlIFwibmV3IFJlY29yZFJUQ1Byb21pc2VzSGFuZGxlcigpXCInO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbWVkaWFTdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgJ0ZpcnN0IGFyZ3VtZW50IFwiTWVkaWFTdHJlYW1cIiBpcyByZXF1aXJlZC4nO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcm9wZXJ0eSB7QmxvYn0gYmxvYiAtIEFjY2Vzcy9yZWFjaCB0aGUgbmF0aXZlIHtAbGluayBSZWNvcmRSVEN9IG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENQcm9taXNlc0hhbmRsZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBsZXQgaW50ZXJuYWwgPSByZWNvcmRlci5yZWNvcmRSVEMuZ2V0SW50ZXJuYWxSZWNvcmRlcigpO1xyXG4gICAgICogYWxlcnQoaW50ZXJuYWwgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVJlY29yZGVyKTtcclxuICAgICAqIHJlY29yZGVyLnJlY29yZFJUQy5vblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7fTtcclxuICAgICAqL1xyXG4gICAgc2VsZi5yZWNvcmRSVEMgPSBuZXcgUmVjb3JkUlRDKG1lZGlhU3RyZWFtLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlY29yZHMgTWVkaWFTdHJlYW0uXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RhcnRSZWNvcmRpbmcoKVxyXG4gICAgICogICAgICAgICAudGhlbihzdWNjZXNzQ0IpXHJcbiAgICAgKiAgICAgICAgIC5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHNlbGYucmVjb3JkUlRDLnN0YXJ0UmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3BzIHRoZSByZWNvcmRpbmcuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZygpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5nZXRCbG9iKCk7XHJcbiAgICAgKiB9KS5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yZWNvcmRSVEMuc3RvcFJlY29yZGluZyhmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJsb2IgPSBzZWxmLnJlY29yZFJUQy5nZXRCbG9iKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5ibG9iIHx8ICFzZWxmLmJsb2Iuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoJ0VtcHR5IGJsb2IuJywgc2VsZi5ibG9iKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1cmwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHBhdXNlcyB0aGUgcmVjb3JkaW5nLiBZb3UgY2FuIHJlc3VtZSByZWNvcmRpbmcgdXNpbmcgXCJyZXN1bWVSZWNvcmRpbmdcIiBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucGF1c2VSZWNvcmRpbmcoKVxyXG4gICAgICogICAgICAgICAudGhlbihzdWNjZXNzQ0IpXHJcbiAgICAgKiAgICAgICAgIC5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXVzZVJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHNlbGYucmVjb3JkUlRDLnBhdXNlUmVjb3JkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc3VtZXMgdGhlIHJlY29yZGluZy5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENQcm9taXNlc0hhbmRsZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5yZXN1bWVSZWNvcmRpbmcoKVxyXG4gICAgICogICAgICAgICAudGhlbihzdWNjZXNzQ0IpXHJcbiAgICAgKiAgICAgICAgIC5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXN1bWVSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29yZFJUQy5yZXN1bWVSZWNvcmRpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBkYXRhLXVybCBmb3IgdGhlIHJlY29yZGVkIGJsb2IuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZygpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgcmVjb3JkZXIuZ2V0RGF0YVVSTCgpLnRoZW4oZnVuY3Rpb24oZGF0YVVSTCkge1xyXG4gICAgICogICAgICAgICB3aW5kb3cub3BlbihkYXRhVVJMKTtcclxuICAgICAqICAgICB9KS5jYXRjaChlcnJvckNCKTs7XHJcbiAgICAgKiB9KS5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXREYXRhVVJMID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29yZFJUQy5nZXREYXRhVVJMKGZ1bmN0aW9uKGRhdGFVUkwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGFVUkwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlY29yZGVkIGJsb2IuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuc3RvcFJlY29yZGluZygpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgcmVjb3JkZXIuZ2V0QmxvYigpLnRoZW4oZnVuY3Rpb24oYmxvYikge30pXHJcbiAgICAgKiB9KS5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRCbG9iID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlY29yZFJUQy5nZXRCbG9iKCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbnRlcm5hbCByZWNvcmRpbmcgb2JqZWN0LlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFJlY29yZFJUQ1Byb21pc2VzSGFuZGxlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGxldCBpbnRlcm5hbFJlY29yZGVyID0gYXdhaXQgcmVjb3JkZXIuZ2V0SW50ZXJuYWxSZWNvcmRlcigpO1xyXG4gICAgICogaWYoaW50ZXJuYWxSZWNvcmRlciBpbnN0YW5jZW9mIE11bHRpU3RyZWFtUmVjb3JkZXIpIHtcclxuICAgICAqICAgICBpbnRlcm5hbFJlY29yZGVyLmFkZFN0cmVhbXMoW25ld0F1ZGlvU3RyZWFtXSk7XHJcbiAgICAgKiAgICAgaW50ZXJuYWxSZWNvcmRlci5yZXNldFZpZGVvU3RyZWFtcyhbc2NyZWVuU3RyZWFtXSk7XHJcbiAgICAgKiB9XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5nZXRJbnRlcm5hbFJlY29yZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlY29yZFJUQy5nZXRJbnRlcm5hbFJlY29yZGVyKCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIHJlY29yZGVyLiBTbyB0aGF0IHlvdSBjYW4gcmV1c2Ugc2luZ2xlIHJlY29yZGVyIGluc3RhbmNlIG1hbnkgdGltZXMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXdhaXQgcmVjb3JkZXIucmVzZXQoKTtcclxuICAgICAqIHJlY29yZGVyLnN0YXJ0UmVjb3JkaW5nKCk7IC8vIHJlY29yZCBhZ2FpblxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlY29yZFJUQy5yZXNldCgpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBSZWNvcmRSVEMgaW5zdGFuY2UuIENsZWFyIGFsbCByZWNvcmRlcnMgYW5kIG9iamVjdHMuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuZGVzdHJveSgpLnRoZW4oc3VjY2Vzc0NCKS5jYXRjaChlcnJvckNCKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlY29yZFJUQy5kZXN0cm95KCkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgcmVjb3JkZXIncyByZWFkb25seSBzdGF0ZS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBSZWNvcmRSVENQcm9taXNlc0hhbmRsZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBsZXQgc3RhdGUgPSBhd2FpdCByZWNvcmRlci5nZXRTdGF0ZSgpO1xyXG4gICAgICogLy8gb3JcclxuICAgICAqIHJlY29yZGVyLmdldFN0YXRlKCkudGhlbihzdGF0ZSA9PiB7IGNvbnNvbGUubG9nKHN0YXRlKTsgfSlcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgcmVjb3JkaW5nIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLnJlY29yZFJUQy5nZXRTdGF0ZSgpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCbG9ifSBibG9iIC0gUmVjb3JkZWQgZGF0YSBhcyBcIkJsb2JcIiBvYmplY3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXdhaXQgcmVjb3JkZXIuc3RvcFJlY29yZGluZygpO1xyXG4gICAgICogbGV0IGJsb2IgPSByZWNvcmRlci5nZXRCbG9iKCk7IC8vIG9yIFwicmVjb3JkZXIucmVjb3JkUlRDLmJsb2JcIlxyXG4gICAgICogaW52b2tlU2F2ZUFzRGlhbG9nKGJsb2IpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLmJsb2IgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjb3JkUlRDIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvbiAtIFJlbGVhc2UgdmVyc2lvbiBudW1iZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBhbGVydChyZWNvcmRlci52ZXJzaW9uKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy52ZXJzaW9uID0gJzUuNi4yJztcclxufVxyXG5cclxuaWYgKHR5cGVvZiBSZWNvcmRSVEMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBSZWNvcmRSVEMuUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyID0gUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyO1xyXG59XG5cclxuLy8gX19fX19fX19fX19fX19fX19fX19fX1xyXG4vLyBXZWJBc3NlbWJseVJlY29yZGVyLmpzXHJcblxyXG4vKipcclxuICogV2ViQXNzZW1ibHlSZWNvcmRlciBsZXRzIHlvdSBjcmVhdGUgd2VibSB2aWRlb3MgaW4gSmF2YVNjcmlwdCB2aWEgV2ViQXNzZW1ibHkuIFRoZSBsaWJyYXJ5IGNvbnN1bWVzIHJhdyBSR0JBMzIgYnVmZmVycyAoNCBieXRlcyBwZXIgcGl4ZWwpIGFuZCB0dXJucyB0aGVtIGludG8gYSB3ZWJtIHZpZGVvIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBhbmQgcXVhbGl0eS4gVGhpcyBtYWtlcyBpdCBjb21wYXRpYmxlIG91dC1vZi10aGUtYm94IHdpdGggSW1hZ2VEYXRhIGZyb20gYSBDQU5WQVMuIFdpdGggcmVhbHRpbWUgbW9kZSB5b3UgY2FuIGFsc28gdXNlIHdlYm0td2FzbSBmb3Igc3RyZWFtaW5nIHdlYm0gdmlkZW9zLlxyXG4gKiBAc3VtbWFyeSBWaWRlbyByZWNvcmRpbmcgZmVhdHVyZSBpbiBDaHJvbWUsIEZpcmVmb3ggYW5kIG1heWJlIEVkZ2UuXHJcbiAqIEBsaWNlbnNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVH1cclxuICogQGF1dGhvciB7QGxpbmsgaHR0cHM6Ly9NdWF6S2hhbi5jb218TXVheiBLaGFufVxyXG4gKiBAdHlwZWRlZiBXZWJBc3NlbWJseVJlY29yZGVyXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcmVjb3JkZXIgPSBuZXcgV2ViQXNzZW1ibHlSZWNvcmRlcihtZWRpYVN0cmVhbSk7XHJcbiAqIHJlY29yZGVyLnJlY29yZCgpO1xyXG4gKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICogICAgIHZpZGVvLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAqIH0pO1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1JlY29yZFJUQ3xSZWNvcmRSVEMgU291cmNlIENvZGV9XHJcbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG1lZGlhU3RyZWFtIC0gTWVkaWFTdHJlYW0gb2JqZWN0IGZldGNoZWQgdXNpbmcgZ2V0VXNlck1lZGlhIEFQSSBvciBnZW5lcmF0ZWQgdXNpbmcgY2FwdHVyZVN0cmVhbVVudGlsRW5kZWQgb3IgV2ViQXVkaW8gQVBJLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0ge3dlYkFzc2VtYmx5UGF0aDond2VibS13YXNtLndhc20nLHdvcmtlclBhdGg6ICd3ZWJtLXdvcmtlci5qcycsIGZyYW1lUmF0ZTogMzAsIHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAsIGJpdHJhdGU6IDEwMjQsIHJlYWx0aW1lOiB0cnVlfVxyXG4gKi9cclxuZnVuY3Rpb24gV2ViQXNzZW1ibHlSZWNvcmRlcihzdHJlYW0sIGNvbmZpZykge1xyXG4gICAgLy8gYmFzZWQgb246IGdpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy93ZWJtLXdhc21cclxuXHJcbiAgICBpZiAodHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV3JpdGFibGVTdHJlYW0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBmaXhlcyByZWFkYWJsZS93cml0YWJsZSBzdHJlYW1zIGlzc3Vlc1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvbGxvd2luZyBwb2x5ZmlsbCBpcyBzdHJvbmdseSByZWNvbW1lbmRlZDogaHR0cHM6Ly91bnBrZy5jb20vQG1hdHRpYXNidWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9seWZpbGwubWluLmpzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgIGNvbmZpZy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCA2NDA7XHJcbiAgICBjb25maWcuaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCA0ODA7XHJcbiAgICBjb25maWcuZnJhbWVSYXRlID0gY29uZmlnLmZyYW1lUmF0ZSB8fCAzMDtcclxuICAgIGNvbmZpZy5iaXRyYXRlID0gY29uZmlnLmJpdHJhdGUgfHwgMTIwMDtcclxuICAgIGNvbmZpZy5yZWFsdGltZSA9IGNvbmZpZy5yZWFsdGltZSB8fCB0cnVlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlclVSTChidWZmZXIsIHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbYnVmZmVyXSwge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICcnXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaW5pc2hlZDtcclxuXHJcbiAgICBmdW5jdGlvbiBjYW1lcmFTdHJlYW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbihjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcclxuICAgICAgICAgICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpZGVvLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2aWRlby53aWR0aCA9IGNvbmZpZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZpZGVvLnZvbHVtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2aWRlby5vbnBsYXlpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdnMud2lkdGggPSBjb25maWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ZzLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGN2cy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZVRpbWVvdXQgPSAxMDAwIC8gY29uZmlnLmZyYW1lUmF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FtZXJhVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBmKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2FtZXJhVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLm9uVmlkZW9Qcm9jZXNzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5vblZpZGVvUHJvY2Vzc1N0YXJ0ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uc3RhdGUgIT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCBmcmFtZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3b3JrZXI7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RhcnRSZWNvcmRpbmcoc3RyZWFtLCBidWZmZXIpIHtcclxuICAgICAgICBpZiAoIWNvbmZpZy53b3JrZXJQYXRoICYmICFidWZmZXIpIHtcclxuICAgICAgICAgICAgZmluaXNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlzIGl0IHNhZmUgdG8gdXNlIEBsYXRlc3QgP1xyXG5cclxuICAgICAgICAgICAgZmV0Y2goXHJcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly91bnBrZy5jb20vd2VibS13YXNtQGxhdGVzdC9kaXN0L3dlYm0td29ya2VyLmpzJ1xyXG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24ocikge1xyXG4gICAgICAgICAgICAgICAgci5hcnJheUJ1ZmZlcigpLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSZWNvcmRpbmcoc3RyZWFtLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy53b3JrZXJQYXRoICYmIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25maWcud29ya2VyUGF0aCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNvbmZpZy53b3JrZXJQYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dvcmtlclBhdGggcGFyYW1ldGVyIGlzIG1pc3NpbmcuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3b3JrZXIgPSBuZXcgV29ya2VyKGNvbmZpZy53b3JrZXJQYXRoKTtcclxuXHJcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKGNvbmZpZy53ZWJBc3NlbWJseVBhdGggfHwgJ2h0dHBzOi8vdW5wa2cuY29tL3dlYm0td2FzbUBsYXRlc3QvZGlzdC93ZWJtLXdhc20ud2FzbScpO1xyXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09ICdSRUFEWScpIHtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYml0cmF0ZTogY29uZmlnLmJpdHJhdGUgfHwgMTIwMCxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lYmFzZURlbjogY29uZmlnLmZyYW1lUmF0ZSB8fCAzMCxcclxuICAgICAgICAgICAgICAgICAgICByZWFsdGltZTogY29uZmlnLnJlYWx0aW1lXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYW1lcmFTdHJlYW0oKS5waXBlVG8obmV3IFdyaXRhYmxlU3RyZWFtKHtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHb3QgaW1hZ2UsIGJ1dCByZWNvcmRlciBpcyBmaW5pc2hlZCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKGltYWdlLmRhdGEuYnVmZmVyLCBbaW1hZ2UuZGF0YS5idWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISFldmVudC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlPZkJ1ZmZlcnMucHVzaChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVjb3JkcyB2aWRlby5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBXZWJBc3NlbWJseVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIucmVjb3JkKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVjb3JkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYXJyYXlPZkJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICBpc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmxvYiA9IG51bGw7XHJcbiAgICAgICAgc3RhcnRSZWNvcmRpbmcoc3RyZWFtKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuaW5pdENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5pbml0Q2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpc1BhdXNlZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHBhdXNlcyB0aGUgcmVjb3JkaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgV2ViQXNzZW1ibHlSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnBhdXNlKCk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc1BhdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVzdW1lcyB0aGUgcmVjb3JkaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgV2ViQXNzZW1ibHlSZWNvcmRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHJlY29yZGVyLnJlc3VtZSgpO1xyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlzUGF1c2VkID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHRlcm1pbmF0ZShjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghd29ya2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2FpdCBmb3IgbnVsbCBldmVudCBkYXRhIHRvIGluZGljYXRlIHRoYXQgdGhlIGVuY29kaW5nIGlzIGNvbXBsZXRlXHJcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgd29ya2VyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJyYXlPZkJ1ZmZlcnMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHN0b3BzIHJlY29yZGluZyB2aWRlby5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24sIHRoYXQgaXMgdXNlZCB0byBwYXNzIHJlY29yZGVkIGJsb2IgYmFjayB0byB0aGUgY2FsbGVlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIFdlYkFzc2VtYmx5UmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKGJsb2IpIHtcclxuICAgICAqICAgICB2aWRlby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgcmVjb3JkZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICB0ZXJtaW5hdGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJlY29yZGVyLmJsb2IgPSBuZXcgQmxvYihhcnJheU9mQnVmZmVycywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZpZGVvL3dlYm0nXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2socmVjb3JkZXIuYmxvYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGZvciBkZWJ1Z2dpbmdcclxuICAgIHRoaXMubmFtZSA9ICdXZWJBc3NlbWJseVJlY29yZGVyJztcclxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyBjdXJyZW50bHkgcmVjb3JkZWQgZGF0YS5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBXZWJBc3NlbWJseVJlY29yZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogcmVjb3JkZXIuY2xlYXJSZWNvcmRlZERhdGEoKTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGVhclJlY29yZGVkRGF0YSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFycmF5T2ZCdWZmZXJzID0gW107XHJcbiAgICAgICAgaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJsb2IgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyB0b2RvOiBpZiByZWNvcmRpbmctT04gdGhlbiBTVE9QIGl0IGZpcnN0XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IHtCbG9ifSBibG9iIC0gVGhlIHJlY29yZGVkIGJsb2Igb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIFdlYkFzc2VtYmx5UmVjb3JkZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiByZWNvcmRlci5zdG9wKGZ1bmN0aW9uKCl7XHJcbiAgICAgKiAgICAgdmFyIGJsb2IgPSByZWNvcmRlci5ibG9iO1xyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYmxvYiA9IG51bGw7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YgUmVjb3JkUlRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgUmVjb3JkUlRDLldlYkFzc2VtYmx5UmVjb3JkZXIgPSBXZWJBc3NlbWJseVJlY29yZGVyO1xyXG59XG4iXSwibmFtZXMiOlsiUmVjb3JkUlRDIiwibWVkaWFTdHJlYW0iLCJjb25maWciLCJ0eXBlIiwiUmVjb3JkUlRDQ29uZmlndXJhdGlvbiIsInNlbGYiLCJzdGFydFJlY29yZGluZyIsImNvbmZpZzIiLCJkaXNhYmxlTG9ncyIsImNvbnNvbGUiLCJsb2ciLCJ2ZXJzaW9uIiwibWVkaWFSZWNvcmRlciIsImNsZWFyUmVjb3JkZWREYXRhIiwicmVjb3JkIiwic2V0U3RhdGUiLCJyZWNvcmRpbmdEdXJhdGlvbiIsImhhbmRsZVJlY29yZGluZ0R1cmF0aW9uIiwiaW5pdFJlY29yZGVyIiwiaW5pdENhbGxiYWNrIiwiUmVjb3JkZXIiLCJHZXRSZWNvcmRlclR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJzdG9wUmVjb3JkaW5nIiwiY2FsbGJhY2siLCJ3YXJuaW5nTG9nIiwic3RhdGUiLCJyZXN1bWVSZWNvcmRpbmciLCJzZXRUaW1lb3V0Iiwid2FybiIsInN0b3AiLCJfY2FsbGJhY2siLCJfX2Jsb2IiLCJjYWxsIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJibG9iIiwiYnl0ZXNUb1NpemUiLCJzaXplIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZSIsImF1dG9Xcml0ZVRvRGlzayIsImdldERhdGFVUkwiLCJkYXRhVVJMIiwicGFyYW1ldGVyIiwiRGlza1N0b3JhZ2UiLCJTdG9yZSIsInBhdXNlUmVjb3JkaW5nIiwicGF1c2UiLCJyZXN1bWUiLCJyZWFkRmlsZSIsIl9ibG9iIiwicG9zdE1lc3NhZ2UiLCJGaWxlUmVhZGVyU3luYyIsInJlYWRBc0RhdGFVUkwiLCJfbWVkaWFSZWNvcmRlciIsIldvcmtlciIsIm5hdmlnYXRvciIsIm1vekdldFVzZXJNZWRpYSIsIndlYldvcmtlciIsInByb2Nlc3NJbldlYldvcmtlciIsIm9ubWVzc2FnZSIsImV2ZW50IiwiZGF0YSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJfZnVuY3Rpb24iLCJCbG9iIiwidG9TdHJpbmciLCJ3b3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJjb3VudGVyIiwib25SZWNvcmRpbmdTdG9wcGVkIiwib25TdGF0ZUNoYW5nZWQiLCJXQVJOSU5HIiwicmV0dXJuT2JqZWN0Iiwic2V0UmVjb3JkaW5nRHVyYXRpb24iLCJnZXRCbG9iIiwidG9VUkwiLCJnZXRJbnRlcm5hbFJlY29yZGVyIiwic2F2ZSIsImZpbGVOYW1lIiwiaW52b2tlU2F2ZUFzRGlhbG9nIiwiZ2V0RnJvbURpc2siLCJzZXRBZHZlcnRpc2VtZW50QXJyYXkiLCJhcnJheU9mV2ViUEltYWdlcyIsImFkdmVydGlzZW1lbnQiLCJsZW5ndGgiLCJpIiwicHVzaCIsImR1cmF0aW9uIiwiaW1hZ2UiLCJidWZmZXJTaXplIiwic2FtcGxlUmF0ZSIsImJ1ZmZlciIsInJlc2V0IiwiZ2V0U3RhdGUiLCJkZXN0cm95IiwiZGlzYWJsZUxvZ3NDYWNoZSIsIlN0b3JhZ2UiLCJBdWRpb0NvbnRleHRDb25zdHJ1Y3RvciIsImNsb3NlIiwicHJvcCIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiLCJGZXRjaCIsIl90eXBlIiwicmVwbGFjZSIsIndyaXRlVG9EaXNrIiwib3B0aW9ucyIsImF1ZGlvIiwidmlkZW8iLCJnaWYiLCJhdWRpb0RhdGFVUkwiLCJ2aWRlb0RhdGFVUkwiLCJnaWZEYXRhVVJMIiwiYXVkaW9CbG9iIiwidmlkZW9CbG9iIiwiZ2lmQmxvYiIsInJlY29yZGVyVHlwZSIsIldoYW1teVJlY29yZGVyIiwiQ2FudmFzUmVjb3JkZXIiLCJXZWJBc3NlbWJseVJlY29yZGVyIiwiR2lmUmVjb3JkZXIiLCJTdGVyZW9BdWRpb1JlY29yZGVyIiwiTWVkaWFTdHJlYW1SZWNvcmRlciIsImdldFRyYWNrcyIsIk1lZGlhUmVjb3JkZXIiLCJwcm90b3R5cGUiLCJtaW1lVHlwZSIsInNwbGl0IiwiYml0c1BlclNlY29uZCIsInJlY29yZGVyIiwiaXNDaHJvbWUiLCJpc0VkZ2UiLCJpc09wZXJhIiwiUmVhZGFibGVTdHJlYW0iLCJpc01lZGlhUmVjb3JkZXJDb21wYXRpYmxlIiwiaXNUeXBlU3VwcG9ydGVkIiwiQXJyYXkiLCJNdWx0aVN0cmVhbVJlY29yZGVyIiwiaXNTYWZhcmkiLCJNUmVjb3JkUlRDIiwiYWRkU3RyZWFtIiwiX21lZGlhU3RyZWFtIiwibWVkaWFUeXBlIiwiYXVkaW9SZWNvcmRlciIsIm51bWJlck9mQXVkaW9DaGFubmVscyIsInRpbWVTbGljZSIsIm9uVGltZVN0YW1wIiwibmV3U3RyZWFtIiwidmlkZW9UcmFjayIsImlzRmlyZWZveCIsIk1lZGlhU3RyZWFtIiwiYWRkVHJhY2siLCJ2aWRlb1JlY29yZGVyIiwiY2FudmFzIiwiZnJhbWVJbnRlcnZhbCIsIndvcmtlclBhdGgiLCJ3ZWJBc3NlbWJseVBhdGgiLCJmcmFtZVJhdGUiLCJiaXRyYXRlIiwiaXNTaW5nbGVSZWNvcmRlciIsImdpZlJlY29yZGVyIiwicXVhbGl0eSIsImJsb2JVUkwiLCJvdXRwdXQiLCJfYXVkaW9EYXRhVVJMIiwiX3ZpZGVvRGF0YVVSTCIsImNhbGxiYWNrMDAiLCJ3ZWJraXRVUkwiLCJhcmdzIiwiYnJvd3NlckZha2VVc2VyQWdlbnQiLCJ0aGF0IiwiZ2xvYmFsIiwidXNlckFnZW50IiwiZ2V0VXNlck1lZGlhIiwiZXJyb3IiLCJhcmd1bWVudHMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwiY3JlYXRlRWxlbWVudCIsImNhcHR1cmVTdHJlYW0iLCJtb3pDYXB0dXJlU3RyZWFtIiwib2JqIiwiZ2V0Q29udGV4dCIsInBsYXkiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJzdHlsZSIsIkhUTUxWaWRlb0VsZW1lbnQiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaHJlZiIsImhhc2giLCJzY3JlZW4iLCJ3aWR0aCIsImhlaWdodCIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGFzdFRpbWUiLCJlbGVtZW50IiwiY3VyclRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsInRpbWVUb0NhbGwiLCJNYXRoIiwibWF4IiwiaWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtc0NhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYXJUaW1lb3V0IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwibW96QXVkaW9Db250ZXh0Iiwid2Via2l0R2V0VXNlck1lZGlhIiwiaW5kZXhPZiIsIm1zU2F2ZUJsb2IiLCJtc1NhdmVPck9wZW5CbG9iIiwib3BlcmEiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJpc0VsZWN0cm9uIiwid2Via2l0TWVkaWFTdHJlYW0iLCJ0cmFjayIsImJ5dGVzIiwiayIsInNpemVzIiwicGFyc2VJbnQiLCJmbG9vciIsInBvdyIsInRvUHJlY2lzaW9uIiwiZmlsZSIsImZpbGVFeHRlbnNpb24iLCJzcGxpdHRlZCIsImZpbGVGdWxsTmFtZSIsInJvdW5kIiwicmFuZG9tIiwiaHlwZXJsaW5rIiwiZG93bmxvYWQiLCJib2R5IiwiY2xpY2siLCJkaXNwYXRjaEV2ZW50IiwiTW91c2VFdmVudCIsInZpZXciLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsImVsZWN0cm9uIiwic3RyZWFtIiwia2luZCIsImZpbHRlciIsInQiLCJzZXRTcmNPYmplY3QiLCJzcmNPYmplY3QiLCJtb3pTcmNPYmplY3QiLCJnZXRTZWVrYWJsZUJsb2IiLCJpbnB1dEJsb2IiLCJFQk1MIiwiRXJyb3IiLCJSZWFkZXIiLCJkZWNvZGVyIiwiRGVjb2RlciIsInRvb2xzIiwiZmlsZVJlYWRlciIsImVibWxFbG1zIiwiZGVjb2RlIiwicmVhZCIsInJlZmluZWRNZXRhZGF0YUJ1ZiIsIm1ha2VNZXRhZGF0YVNlZWthYmxlIiwibWV0YWRhdGFzIiwiY3VlcyIsInNsaWNlIiwibWV0YWRhdGFTaXplIiwibmV3QmxvYiIsInJlYWRBc0FycmF5QnVmZmVyIiwiblZlciIsImFwcFZlcnNpb24iLCJuQWd0IiwiZnVsbFZlcnNpb24iLCJwYXJzZUZsb2F0IiwibWFqb3JWZXJzaW9uIiwibmFtZU9mZnNldCIsInZlck9mZnNldCIsIml4Iiwic3Vic3RyaW5nIiwiaXNOYU4iLCJhcnJheU9mQmxvYnMiLCJnZXRBcnJheU9mQmxvYnMiLCJ0aW1lc3RhbXBzIiwiYWxsU3RhdGVzIiwicmVjb3JkZXJIaW50cyIsImNhblJlY29yZE1pbWVUeXBlIiwib25kYXRhYXZhaWxhYmxlIiwidXBkYXRlVGltZVN0YW1wIiwiZ2V0TmF0aXZlQmxvYiIsImdldE1pbWVUeXBlIiwicmVjb3JkaW5nQ2FsbGJhY2siLCJvbnN0YXJ0Iiwib25wYXVzZSIsIm9ucmVzdW1lIiwib25zdG9wIiwib25lcnJvciIsImxvb3BlciIsIm1hbnVhbGx5U3RvcHBlZCIsInRpbWVzbGljZSIsInN0YXJ0Iiwic2Vjb25kT2JqZWN0IiwiY2xlYXJSZWNvcmRlZERhdGFDQiIsImlzTWVkaWFTdHJlYW1BY3RpdmUiLCJhY3RpdmUiLCJlbmRlZCIsImdldEFsbFN0YXRlcyIsImNoZWNrRm9ySW5hY3RpdmVUcmFja3MiLCJsZWZ0Y2hhbm5lbCIsInJpZ2h0Y2hhbm5lbCIsInJlY29yZGluZyIsInJlY29yZGluZ0xlbmd0aCIsImpzQXVkaW9Ob2RlIiwiZGVzaXJlZFNhbXBSYXRlIiwibGVmdENoYW5uZWwiLCJyZXNldFZhcmlhYmxlcyIsImlzQXVkaW9Qcm9jZXNzU3RhcnRlZCIsImlzUGF1c2VkIiwibWVyZ2VMZWZ0UmlnaHRCdWZmZXJzIiwibWVyZ2VBdWRpb0J1ZmZlcnMiLCJjYiIsImxlZnRCdWZmZXJzIiwicmlnaHRCdWZmZXJzIiwiaW50ZXJuYWxJbnRlcmxlYXZlZExlbmd0aCIsIm1lcmdlQnVmZmVycyIsImludGVycG9sYXRlQXJyYXkiLCJuZXdTYW1wbGVSYXRlIiwib2xkU2FtcGxlUmF0ZSIsImZpdENvdW50IiwibmV3RGF0YSIsInNwcmluZ0ZhY3RvciIsIk51bWJlciIsInRtcCIsImJlZm9yZSIsInRvRml4ZWQiLCJhZnRlciIsImNlaWwiLCJhdFBvaW50IiwibGluZWFySW50ZXJwb2xhdGUiLCJjaGFubmVsQnVmZmVyIiwickxlbmd0aCIsIkZsb2F0NjRBcnJheSIsIm9mZnNldCIsImxuZyIsInNldCIsImludGVybGVhdmUiLCJyaWdodENoYW5uZWwiLCJpbnB1dEluZGV4IiwiaW5kZXgiLCJ3cml0ZVVURkJ5dGVzIiwic3RyaW5nIiwic2V0VWludDgiLCJjaGFyQ29kZUF0IiwiaW50ZXJsZWF2ZWQiLCJpbnRlcmxlYXZlZExlbmd0aCIsInJlc3VsdGluZ0J1ZmZlckxlbmd0aCIsIkFycmF5QnVmZmVyIiwiRGF0YVZpZXciLCJzZXRVaW50MzIiLCJzZXRVaW50MTYiLCJ2b2x1bWUiLCJzZXRJbnQxNiIsIm5vV29ya2VyIiwid29ya2VyVVJMIiwidGVybWluYXRlIiwiYnl0ZUxlbmd0aCIsImNvbnRleHQiLCJhdWRpb0lucHV0IiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJsZWdhbEJ1ZmZlclZhbHVlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVKYXZhU2NyaXB0Tm9kZSIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsImNvbm5lY3QiLCJpbnRlcnZhbHNCYXNlZEJ1ZmZlcnMiLCJsZWZ0IiwicmlnaHQiLCJvbmF1ZGlvcHJvY2VzcyIsImRpc2Nvbm5lY3QiLCJvbkF1ZGlvUHJvY2Vzc0RhdGFBdmFpbGFibGUiLCJvbkF1ZGlvUHJvY2Vzc1N0YXJ0ZWQiLCJpbnB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiY2hMZWZ0IiwiRmxvYXQzMkFycmF5IiwiY2hSaWdodCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJkZXN0aW5hdGlvbiIsImh0bWxFbGVtZW50IiwiaHRtbDJjYW52YXMiLCJpc0NhbnZhc1N1cHBvcnRzU3RyZWFtQ2FwdHVyaW5nIiwiaXRlbSIsIl9pc0Nocm9tZSIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwiY2hyb21lIiwiY2hyb21lVmVyc2lvbiIsIm1hdGNoQXJyYXkiLCJtYXRjaCIsInVzZVdoYW1teVJlY29yZGVyIiwiZ2xvYmFsQ2FudmFzIiwibWVkaWFTdHJlYW1SZWNvcmRlciIsIkhUTUxDYW52YXNFbGVtZW50IiwiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIiwiaXNSZWNvcmRpbmciLCJjYW52YXNNZWRpYVN0cmVhbSIsIndlYmtpdENhcHR1cmVTdHJlYW0iLCJtZFN0cmVhbSIsIndoYW1teSIsImZyYW1lcyIsImRyYXdDYW52YXNGcmFtZSIsImdldFdlYlBJbWFnZXMiLCJub2RlTmFtZSIsImZyYW1lc0xlbmd0aCIsImZyYW1lIiwiaWR4IiwiZnJhbWVzUmVtYWluaW5nIiwib25FbmNvZGluZ0NhbGxiYWNrIiwid2VicCIsImNvbXBpbGUiLCJpc1BhdXNlZFJlY29yZGluZyIsImNsb25lQ2FudmFzIiwibmV3Q2FudmFzIiwiZ3JhYk1vdXNlIiwic2hvd01vdXNlUG9pbnRlciIsIm9ucmVuZGVyZWQiLCJXaGFtbXkiLCJWaWRlbyIsImNsb25lTm9kZSIsIm9ubG9hZGVkbWV0YWRhdGEiLCJtdXRlZCIsImRyYXdGcmFtZXMiLCJwYXVzZWQiLCJpc1N0b3BEcmF3aW5nIiwiYXN5bmNMb29wIiwibyIsImxvb3AiLCJmdW5jdGlvblRvTG9vcCIsImRyb3BCbGFja0ZyYW1lcyIsIl9mcmFtZXMiLCJfZnJhbWVzVG9DaGVjayIsIl9waXhUb2xlcmFuY2UiLCJfZnJhbWVUb2xlcmFuY2UiLCJsb2NhbENhbnZhcyIsImNvbnRleHQyZCIsInJlc3VsdEZyYW1lcyIsImNoZWNrVW50aWxOb3RCbGFjayIsImVuZENoZWNrRnJhbWUiLCJzYW1wbGVDb2xvciIsInIiLCJnIiwiYiIsIm1heENvbG9yRGlmZmVyZW5jZSIsInNxcnQiLCJwaXhUb2xlcmFuY2UiLCJmcmFtZVRvbGVyYW5jZSIsImRvTm90Q2hlY2tOZXh0IiwiZiIsIm1hdGNoUGl4Q291bnQiLCJlbmRQaXhDaGVjayIsIm1heFBpeENvdW50IiwiZmluaXNoSW1hZ2UiLCJJbWFnZSIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsInBpeCIsImN1cnJlbnRDb2xvciIsImNvbG9yRGlmZmVyZW5jZSIsInNyYyIsImNvbmNhdCIsIl90aGlzIiwiV2hhbW15VmlkZW8iLCJhZGQiLCJ3aGFtbXlJbldlYldvcmtlciIsIkFycmF5VG9XZWJNIiwiaW5mbyIsImNoZWNrRnJhbWVzIiwiY2x1c3Rlck1heER1cmF0aW9uIiwiZG91YmxlVG9TdHJpbmciLCJmcmFtZU51bWJlciIsImNsdXN0ZXJUaW1lY29kZSIsImNsdXN0ZXJGcmFtZXMiLCJjbHVzdGVyRHVyYXRpb24iLCJjbHVzdGVyQ291bnRlciIsImNsdXN0ZXIiLCJnZXRDbHVzdGVyRGF0YSIsImdlbmVyYXRlRUJNTCIsIm1hcCIsImJsb2NrIiwibWFrZVNpbXBsZUJsb2NrIiwiZGlzY2FyZGFibGUiLCJpbnZpc2libGUiLCJrZXlmcmFtZSIsImxhY2luZyIsInRyYWNrTnVtIiwidGltZWNvZGUiLCJudW1Ub0J1ZmZlciIsIm51bSIsInBhcnRzIiwiVWludDhBcnJheSIsInJldmVyc2UiLCJzdHJUb0J1ZmZlciIsInN0ciIsImJpdHNUb0J1ZmZlciIsImJpdHMiLCJwYWQiLCJqb2luIiwic3Vic3RyIiwianNvbiIsImVibWwiLCJsZW4iLCJ6ZXJvZXMiLCJzaXplVG9TdHJpbmciLCJwYWRkZWQiLCJ0b0JpblN0ck9sZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZsYWdzIiwib3V0IiwicGFyc2VXZWJQIiwicmlmZiIsIlZQOCIsIlJJRkYiLCJXRUJQIiwiZnJhbWVTdGFydCIsImMiLCJnZXRTdHJMZW5ndGgiLCJ1bnBhZGRlZCIsInBhcnNlUklGRiIsImNodW5rcyIsIndlYm0iLCJhdG9iIiwiaW5pdCIsImluZGV4ZWREQiIsIm9wZW4iLCJkYlZlcnNpb24iLCJkYk5hbWUiLCJkYiIsInJlcXVlc3QiLCJjcmVhdGVPYmplY3RTdG9yZSIsImRhdGFCYXNlIiwiZGF0YVN0b3JlTmFtZSIsInB1dEluREIiLCJ0cmFuc2FjdGlvbiIsIm9iamVjdFN0b3JlIiwicHV0IiwiZ2V0RnJvbVN0b3JlIiwicG9ydGlvbk5hbWUiLCJnZXQiLCJvbnN1Y2Nlc3MiLCJvbkVycm9yIiwic2V0VmVyc2lvbiIsIm9udXBncmFkZW5lZWRlZCIsIkdJRkVuY29kZXIiLCJzY3JpcHQiLCJpc0hUTUxPYmplY3QiLCJpc0xvYWRlZE1ldGFEYXRhIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJnaWZFbmNvZGVyIiwic2V0UmVwZWF0Iiwic2V0RGVsYXkiLCJzZXRRdWFsaXR5Iiwib25HaWZSZWNvcmRpbmdTdGFydGVkIiwic3RhcnRUaW1lIiwibm93IiwiZHJhd1ZpZGVvRnJhbWUiLCJ0aW1lIiwiY2xlYXJlZFJlY29yZGVkRGF0YSIsImxhc3RBbmltYXRpb25GcmFtZSIsImxhc3RGcmFtZVRpbWUiLCJ1bmRlZmluZWQiLCJvbkdpZlByZXZpZXciLCJhZGRGcmFtZSIsImVuZFRpbWUiLCJiaW4iLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwiTXVsdGlTdHJlYW1zTWl4ZXIiLCJhcnJheU9mTWVkaWFTdHJlYW1zIiwiZWxlbWVudENsYXNzIiwidmlkZW9zIiwiaXNTdG9wRHJhd2luZ0ZyYW1lcyIsIm9wYWNpdHkiLCJwb3NpdGlvbiIsInpJbmRleCIsInRvcCIsImNsYXNzTmFtZSIsInVzZUdhaW5Ob2RlIiwic3RhcnREcmF3aW5nRnJhbWVzIiwiZHJhd1ZpZGVvc1RvQ2FudmFzIiwidmlkZW9zTGVuZ3RoIiwiZnVsbGNhbnZhcyIsInJlbWFpbmluZyIsIngiLCJ5Iiwib25SZW5kZXIiLCJnZXRNaXhlZFN0cmVhbSIsIm1peGVkVmlkZW9TdHJlYW0iLCJnZXRNaXhlZFZpZGVvU3RyZWFtIiwibWl4ZWRBdWRpb1N0cmVhbSIsImdldE1peGVkQXVkaW9TdHJlYW0iLCJyZXNldFZpZGVvU3RyZWFtcyIsImNhcHR1cmVkU3RyZWFtIiwidmlkZW9TdHJlYW0iLCJhdWRpb0NvbnRleHQiLCJhdWRpb1NvdXJjZXMiLCJnYWluTm9kZSIsImNyZWF0ZUdhaW4iLCJnYWluIiwidmFsdWUiLCJhdWRpb1RyYWNrc0xlbmd0aCIsImF1ZGlvU291cmNlIiwiYXVkaW9EZXN0aW5hdGlvbiIsImdldFZpZGVvIiwiYXBwZW5kU3RyZWFtcyIsInN0cmVhbXMiLCJyZWxlYXNlU3RyZWFtcyIsInNvdXJjZSIsImNsZWFyUmVjdCIsIm1peGVyIiwiZ2V0QWxsVmlkZW9UcmFja3MiLCJwcmV2aWV3U3RyZWFtIiwidHJhY2tzIiwiYWRkU3RyZWFtcyIsImdldE1peGVyIiwiUmVjb3JkUlRDUHJvbWlzZXNIYW5kbGVyIiwicmVjb3JkUlRDIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJXcml0YWJsZVN0cmVhbSIsInJlYWx0aW1lIiwiY3JlYXRlQnVmZmVyVVJMIiwiZmluaXNoZWQiLCJjYW1lcmFTdHJlYW0iLCJjb250cm9sbGVyIiwiY3ZzIiwiZmlyc3QiLCJvbnBsYXlpbmciLCJjdHgiLCJmcmFtZVRpbWVvdXQiLCJjYW1lcmFUaW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9uVmlkZW9Qcm9jZXNzU3RhcnRlZCIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJlbnF1ZXVlIiwiZmV0Y2giLCJ0aGVuIiwiYXJyYXlCdWZmZXIiLCJhZGRFdmVudExpc3RlbmVyIiwidGltZWJhc2VEZW4iLCJwaXBlVG8iLCJ3cml0ZSIsImFycmF5T2ZCdWZmZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/recordrtc/RecordRTC.js\n");

/***/ })

};
;